## ams_version=1.0

LibraryModule PracticeLibrary {
    Prefix: pl;
    Interface: Public_Section;
    Section Public_Section {
        Procedure TransferData {
            Arguments: {
                (s_locPlants,s_locCostumers,p_locSupply,p_locDemand,p_locTransportCost,p_locTotalTransportCost,
                 p_locTransport)
            }
            Body: {
                Empty s_libPlants, s_libCostumers;
                
                For p_loc do
                	SetElementAdd(s_libPlants, ep_new1, p_loc);
                	ep_map1(ep_new1) := p_loc;
                EndFor;
                p_libSupply(p_lib) := p_locSupply( ep_map1(p_lib));
                
                For c_loc do
                	SetElementAdd(s_libCostumers, ep_new2, c_loc);
                	ep_map2(ep_new2) := c_loc;
                EndFor;
                p_libDemand(c_lib) := p_locDemand( ep_map2(c_lib));
                
                p_libTransportCost(p_lib,c_lib) :=
                	p_locTransportCost(ep_map1(p_lib), ep_map2(c_lib));
                
                Solve mp_LeastCostTransportPlan;
                
                p_locTotalTransportCost := v_libTotalTransportCost;
                p_locTransport(ep_map1(p_lib), ep_map2(c_lib)) 
                	:= v_libTransport(p_lib,c_lib);
            }
            Set s_locPlants {
                Index: p_loc;
                Property: Input;
            }
            Set s_locCostumers {
                Index: c_loc;
                Property: Input;
            }
            Parameter p_locSupply {
                IndexDomain: p_loc;
                Property: Input;
            }
            Parameter p_locDemand {
                IndexDomain: c_loc;
                Property: Input;
            }
            Parameter p_locTransportCost {
                IndexDomain: (p_loc, c_loc);
                Property: Input;
            }
            Parameter p_locTotalTransportCost {
                Property: Output;
            }
            Parameter p_locTransport {
                IndexDomain: (p_loc, c_loc);
                Property: Output;
            }
            ElementParameter ep_new1 {
                Range: s_libPlants;
            }
            ElementParameter ep_map1 {
                IndexDomain: p_lib;
                Range: s_locPlants;
            }
            ElementParameter ep_new2 {
                Range: s_libCostumers;
            }
            ElementParameter ep_map2 {
                IndexDomain: c_lib;
                Range: s_locCostumers;
            }
        }
    }
    Section Private_Section {
        Set s_libPlants {
            Index: p_lib;
        }
        Set s_libCostumers {
            Index: c_lib;
        }
        Parameter p_libSupply {
            IndexDomain: p_lib;
        }
        Parameter p_libDemand {
            IndexDomain: c_lib;
        }
        Parameter p_libTransportCost {
            IndexDomain: (p_lib, c_lib);
        }
        Variable v_libTotalTransportCost {
            Range: free;
            Definition: sum[(p_lib,c_lib), v_libTransport(p_lib,c_lib) * p_libTransportCost(p_lib,c_lib) ];
        }
        Variable v_libTransport {
            IndexDomain: (p_lib, c_lib);
            Range: nonnegative;
        }
        Constraint c_SupplyRestriction {
            IndexDomain: p_lib;
            Definition: sum[c_lib, v_libTransport(p_lib, c_lib)] <= p_libSupply(p_lib);
        }
        Constraint c_DemandRequirement {
            IndexDomain: c_lib;
            Definition: sum[p_lib, v_libTransport(p_lib,c_lib)] >= p_libDemand(c_lib);
        }
        MathematicalProgram mp_LeastCostTransportPlan {
            Objective: v_libTotalTransportCost;
            Direction: minimize;
            Constraints: AllConstraints;
            Variables: AllVariables;
            Type: Automatic;
        }
    }
    Procedure LibraryInitialization {
        Comment: "Add initialization statements here that do not require any other library being initialized already.";
    }
    Procedure PostLibraryInitialization {
        Comment: {
            "Add initialization statements here that require another library to be initialized already,
            or add statements that require the Data Management module to be initialized."
        }
    }
    Procedure PreLibraryTermination {
        Body: {
            return 1;
        }
        Comment: {
            "Add termination statements here that require all other libraries to be still alive.
            Return 1 if you allow the termination sequence to continue.
            Return 0 if you want to cancel the termination sequence."
        }
    }
    Procedure LibraryTermination {
        Body: {
            return 1;
        }
        Comment: {
            "Add termination statements here that do not require other libraries to be still alive.
            Return 1 to allow the termination sequence to continue.
            Return 0 if you want to cancel the termination sequence.
            It is recommended to only use the procedure PreLibraryTermination to cancel the termination sequence and let this procedure always return 1."
        }
    }
}
