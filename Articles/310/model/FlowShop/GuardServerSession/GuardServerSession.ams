## ams_version=1.0

LibraryModule Library_GuardServerSession {
    Prefix: gss;
    Interface: Public_Section;
    Section Public_Section {
        Section WebUI_Support {
            Property: NoSave;
            StringParameter sp_widgetActionMessageStack {
                IndexDomain: (webui::indexPageExtension, webui::indexWidgetActionSpec);
                Definition: {
                    {
                    	('1', 'displaytext' ) : "Model explorer",  
                    	('1', 'icon'        ) : "aimms-glasses",  
                    	('1', 'procedure'   ) : "gss::pr_OpenIdentifierOnStack",  
                    	('1', 'state'       ) : "Active"  
                    }
                }
            }
            StringParameter sp_widgetActionMessageList {
                IndexDomain: (webui::indexPageExtension, webui::indexWidgetActionSpec);
                Definition: {
                    {
                    	('1', 'displaytext' ) : "Model explorer",  
                    	('1', 'icon'        ) : "aimms-glasses",  
                    	('1', 'procedure'   ) : "gss::pr_OpenIdentifierOnMessageList",  
                    	('1', 'state'       ) : "Active"  
                    }
                }
            }
            StringParameter sp_widgetActionIdentifierProfiler {
                IndexDomain: (webui::indexPageExtension, webui::indexWidgetActionSpec);
                Definition: {
                    {
                    	('1', 'displaytext' ) : "Model explorer",  
                    	('1', 'icon'        ) : "aimms-glasses",  
                    	('1', 'procedure'   ) : "gss::pr_OpenProfiledIdentifier",  
                    	('1', 'state'       ) : "Active"  
                    }
                }
            }
            StringParameter sp_SidePanelErrorPage {
                IndexDomain: (webui::indexApplicationExtension,webui::indexSidePanelSpec);
                Definition: {
                    {
                      ( '1', 'displayText' ) : if p_noSignificantMessages then FormatString("%i msgs", p_noSignificantMessages ) else "" endif,
                      ( '1', 'pageId'      ) : if p_noSignificantMessages then "errorpanel_1"                                    else "" endif,
                      ( '1', 'tooltip'     ) : if p_noSignificantMessages then "Error handling"                                  else "" endif,  
                      ( '1', 'state'       ) : if p_noSignificantMessages then "Active"                                          else "" endif 
                    }
                }
            }
            StringParameter sp_messageStatusBar {
                IndexDomain: (webui::indexApplicationExtension,webui::indexStatusBarSpec);
                Definition: {
                    {
                    	('1', 'header'   ): "Messages",
                    	('1', 'icon'     ): "aimms-power", 
                    	('1', 'color'    ): "", 
                    	('1', 'text'     ): 
                    		FormatString("%i messages, %i warnings, and %i errors",
                    			p_noLogMessages, p_noWarnings, p_noErrors), 
                    	('1', 'tooltip'  ): "", 
                    	('1', 'procedure'): "", 
                    	('1', 'state'    ): if card(s_jobErrorMessageNumbers) then "Active" else "Hidden" endif 
                    }
                }
            }
            StringParameter sp_errorWarningMessageMenu {
                IndexDomain: (webui::indexPageExtension, webui::indexWidgetActionSpec);
            }
            StringParameter sp_titleProfilerDetail {
                Definition: FormatString("Profiler data for %e", ep_profilerDataSelectedIdentifier);
            }
            StringParameter sp_titleStackMessage {
                Definition: FormatString("Stack of \"%s\"", sp_jobErrorMessages( ep_errorWarningSelectedMessage ) );
            }
            ElementParameter ep_profilerDataSelectedIdentifier {
                Range: AllIdentifiers;
                InitialData: '';
            }
            ElementParameter ep_errorWarningSelectedMessage {
                Range: s_jobErrorMessageNumbers;
                InitialData: '';
            }
            ElementParameter ep_stackPos {
                Range: s_stackPositions;
            }
            Parameter p_noSignificantMessages {
                Definition: p_noLogMessages + p_NoWarnings + p_NoErrors;
            }
            Parameter p_noLogMessages {
                InitialData: 0;
            }
            Parameter p_noWarnings {
                InitialData: 0;
            }
            Parameter p_noErrors {
                InitialData: 0;
            }
            Set s_messageLevels {
                Index: i_messageLevel;
                Definition: {
                    data { logging, warning, error, severe } ;
                }
            }
            Set s_lineNumbers {
                SubsetOf: Integers;
                Index: i_lineNumber;
                Definition: ElementRange(0,1000);
            }
            Set s_positiveLineNumbers {
                SubsetOf: s_lineNumbers;
                Index: i_positiveLineNumber;
                Definition: ElementRange(1,1000);
            }
            Set s_actualLinenumbers {
                SubsetOf: s_lineNumbers;
                Index: i_actualLineNumber;
                Definition: ElementRange(1,if ep_lastHitLine then ep_lastHitLine else 1 endif);
            }
            Parameter ep_lastHitLine {
                Definition: {
                    last( i_positiveLineNumber | 
                    	p_jobProfilerData(ep_profilerDataSelectedIdentifier, 
                    	i_positiveLineNumber, 'hits'))
                }
            }
            Set s_stackPositions {
                SubsetOf: Integers;
                Index: i_stackPosition;
                Definition: ElementRange(1,255);
            }
        }
        Section Guard_session {
            DeclarationSection serverSessionProfilerErrorData {
                Parameter p_jobProfilerData {
                    IndexDomain: (IndexIdentifiers,i_lineNumber,IndexProfilerTypes );
                }
                Set s_jobErrorMessageNumbers {
                    SubsetOf: Integers;
                    Index: i_jobErrorMessageNumber;
                }
                StringParameter sp_jobErrorMessages {
                    IndexDomain: i_jobErrorMessageNumber;
                }
                StringParameter sp_jobErrorMoments {
                    IndexDomain: i_jobErrorMessageNumber;
                }
                ElementParameter ep_jobErrorSeverity {
                    IndexDomain: i_jobErrorMessageNumber;
                    Range: s_messageLevels;
                }
                ElementParameter ep_jobErrorNodes {
                    IndexDomain: (i_jobErrorMessageNumber,i_stackPosition);
                    Range: AllSymbols;
                }
                ElementParameter ep_jobErrorAttributes {
                    IndexDomain: (i_jobErrorMessageNumber,i_stackPosition);
                    Range: AllAttributeNames;
                }
                Parameter p_jobErrorLines {
                    IndexDomain: (i_jobErrorMessageNumber,i_stackPosition);
                }
            }
            Procedure pr_guardAndProfileServerJob {
                Arguments: (ep_work);
                Body: {
                    block
                    	empty s_jobErrorMessageNumbers ;
                    
                    	! Ensure that the error recorded and profiler data are transmitted via the output case:
                    	pro::ManagedSessionOutputCaseIdentifierSet += ServerSessionProfilerErrorData ;
                    
                    	! Actual work.
                    	apply( ep_work);
                    
                    	! Ensure that the definitions of all defined sets and defined parameters in 
                    	! output case identifier set are profiled.
                    	update pro::ManagedSessionOutputCaseIdentifierSet;
                    
                    onerror ep_err do
                    
                    	pr_appendError( ep_err );
                    
                    	! Don't let the server job be halted by this error; 
                    	! we still want the result case including the profiled data.
                    	errh::MarkAsHandled(ep_err);
                    
                    endblock ;
                    ProfilerCollectAllData(
                    	ProfilerData       :  p_jobProfilerData, 
                    	GrossTimeThreshold :  0, 
                    	NetTimeThreshold   :  0);
                }
                ElementParameter ep_err {
                    Range: errh::PendingErrors;
                }
                ElementParameter ep_work {
                    Range: AllProcedures;
                    Default: 'gss::pr_sampleProc';
                    Property: Input;
                }
            }
            Procedure pr_clearErrors {
                Body: {
                    empty s_jobErrorMessageNumbers;
                }
            }
            Procedure pr_reportCurrentErrorsToTextFile {
                Arguments: (sp_filename);
                Body: {
                    block where listing_page_width := 32000 ;
                    	f_out.pagewidth := 32000 ;
                    	put f_out;
                    	for i_jobErrorMessageNumber do
                    		put     ep_jobErrorSeverity(i_jobErrorMessageNumber), " ", 
                    			sp_jobErrorMoments( i_jobErrorMessageNumber), " : ",
                    			sp_jobErrorMessages(i_jobErrorMessageNumber), / ;
                    		for i_stackPosition | p_jobErrorLines(i_jobErrorMessageNumber, i_stackPosition) do
                    			put "    ", p_jobErrorLines(i_jobErrorMessageNumber, i_stackPosition):4:0, 
                    			" : ", ep_jobErrorNodes(i_jobErrorMessageNumber, i_stackPosition):0, / ;
                    		endfor ;
                    		put / ;
                    	endfor ;
                    	putclose ;
                    endblock ;
                }
                StringParameter sp_filename {
                    Property: Input;
                }
                File f_out {
                    Name: sp_filename;
                    Device: Disk;
                    Mode: replace;
                }
            }
            Procedure pr_globalErrorHandler {
                Arguments: (ep_err);
                Body: {
                    pr_appendError(ep_err );
                    
                    if bp_locSeenErrorsAreHandled then
                    	errh::MarkAsHandled( ep_err );
                    endif ;
                }
                ElementParameter ep_err {
                    Range: errh::PendingErrors;
                    Property: Input;
                }
                ElementParameter ep_jobErrorMessageNumber {
                    Range: s_jobErrorMessageNumbers;
                }
                Parameter p_errStackHeight;
                Parameter p_errStackPos;
                ElementParameter ep_stackPosition {
                    Range: s_stackPositions;
                }
            }
            Procedure pr_seenErrorsAreHandled {
                Arguments: (bp_areHandled);
                Body: {
                    bp_locSeenErrorsAreHandled := bp_areHandled ;
                }
                Parameter bp_areHandled {
                    Range: binary;
                    Default: 1;
                    Property: Input;
                }
            }
            Procedure pr_downloadErrorReport {
                Arguments: (fileLocation,statusCode,statusDescription);
                Body: {
                    fileLocation := "usage.errorLogging";
                    
                    ! we store the location of the file in string parameter FinalLocation
                    sp_finalLocation := webui::GetIOFilePath(fileLocation);
                    
                    ! writing the string parameter FinalLocation to a text file
                    pr_reportCurrentErrorsToTextFile(sp_finalLocation);
                    
                    ! checking if the previous write statement was successful or not
                    if FileExists(sp_finalLocation) then
                    
                       ! if successful, statusCode is set to 'CREATED' which will trigger the download widget to show the Get button
                       StatusCode := webui::ReturnStatusCode('CREATED');
                       ! displaying the status message as All perfect instead of the default "File ready to download"
                       StatusDescription := "All perfect!";
                    
                    else    !if previous write statement was not successful
                    
                       ! setting the statusCode to 'ERROR' and the download widget will not show the Get button anymore
                       statusCode := webui::ReturnStatusCode('ERROR');
                       !displaying a custom error message
                       statusDescription := "Something went wrong when creating the file.";
                    
                    endif;
                }
                StringParameter fileLocation {
                    Property: Output;
                }
                Parameter statusCode {
                    Property: Output;
                }
                StringParameter statusDescription {
                    Property: Output;
                }
                StringParameter sp_finalLocation;
            }
            Procedure pr_downloadErrorData {
                Arguments: (fileLocation,statusCode,statusDescription);
                Body: {
                    fileLocation := "usage.errorLogging";
                    
                    ! we store the location of the file in string parameter FinalLocation
                    sp_finalLocation := webui::GetIOFilePath(fileLocation);
                    
                    ! writing the string parameter FinalLocation to a text file
                    write ServerSessionProfilerErrorData to file sp_finalLocation ;
                    
                    ! checking if the previous write statement was successful or not
                    if FileExists(sp_finalLocation) then
                    
                       ! if successful, statusCode is set to 'CREATED' which will trigger the download widget to show the Get button
                       StatusCode := webui::ReturnStatusCode('CREATED');
                       ! displaying the status message as All perfect instead of the default "File ready to download"
                       StatusDescription := "All perfect!";
                    
                    else    !if previous write statement was not successful
                    
                       ! setting the statusCode to 'ERROR' and the download widget will not show the Get button anymore
                       statusCode := webui::ReturnStatusCode('ERROR');
                       !displaying a custom error message
                       statusDescription := "Something went wrong when creating the file.";
                    
                    endif;
                }
                StringParameter fileLocation {
                    Property: Output;
                }
                Parameter statusCode {
                    Property: Output;
                }
                StringParameter statusDescription {
                    Property: Output;
                }
                StringParameter sp_finalLocation;
            }
            Procedure pr_uploadErrorData {
                Arguments: (fileLocation,statusCode,statusDescription);
                Body: {
                    sp_fileUploadLocation := webui::GetIOFilePath(fileLocation);
                    ! The file is uploaded to the process specific temporary folder. 
                    
                    ! Now copy the uploaded file to Central Storage.
                    Read from file sp_fileUploadLocation ;
                    
                    statusCode := webui::ReturnStatusCode('OK');
                    statusDescription := "Nice.";
                }
                StringParameter sp_fileUploadLocation;
                StringParameter fileLocation {
                    Property: Input;
                }
                Parameter statusCode {
                    Property: Output;
                }
                StringParameter statusDescription {
                    Property: Output;
                }
            }
            Procedure pr_appendMessage {
                Arguments: (sp_msg);
                Body: {
                    ! Increase the number of recorded error messages.
                    s_jobErrorMessageNumbers += card(s_jobErrorMessageNumbers) + 1;
                    ep_jobErrorMessageNumber := last(s_jobErrorMessageNumbers);
                    
                    ! Record the message and severity.
                    sp_jobErrorMessages(ep_jobErrorMessageNumber) := sp_msg;
                    sp_jobErrorMoments( ep_jobErrorMessageNumber) := CurrentToString("%c%y-%m-%d %H:%M:%S:%T");
                    ep_jobErrorSeverity(ep_jobErrorMessageNumber) := 'logging';
                    
                    ! Record the entire stack of error positions
                    p_errStackHeight := callerNumberOfLocations();
                    p_errStackPos := 1 ;
                    while p_errStackPos <= p_errStackHeight do
                    	ep_stackPosition := p_errStackPos;
                    	ep_jobErrorNodes(     ep_jobErrorMessageNumber,ep_stackPosition) := callerNode(     ep_stackPosition);
                    	ep_JobErrorAttributes(ep_jobErrorMessageNumber,ep_stackPosition) := callerAttribute(ep_stackPosition);
                    	p_jobErrorLines(      ep_jobErrorMessageNumber,ep_stackPosition) := callerLine(     ep_stackPosition);
                    	p_errStackPos += 1 ;
                    endwhile ;
                    
                    p_noLogMessages += 1 ;
                }
                Comment: "Store the error in the data structures of the library.";
                Parameter p_errStackHeight;
                Parameter p_errStackPos;
                ElementParameter ep_stackPosition {
                    Range: s_stackPositions;
                }
                ElementParameter ep_jobErrorMessageNumber {
                    Range: s_jobErrorMessageNumbers;
                }
                StringParameter sp_msg {
                    Property: Input;
                }
            }
            Procedure pr_appendError {
                Arguments: (ep_err);
                Body: {
                    ! Increase the number of recorded error messages.
                    s_jobErrorMessageNumbers += card(s_jobErrorMessageNumbers) + 1;
                    ep_jobErrorMessageNumber := last(s_jobErrorMessageNumbers);
                    
                    ! Record the message and severity.
                    sp_jobErrorMessages(ep_jobErrorMessageNumber) := errh::Message( ep_err);
                    sp_jobErrorMoments( ep_jobErrorMessageNumber) := errh::CreationTime(ep_err,"%c%y-%m-%d %H:%M:%S:%T%TZ('local')");
                    ep_jobErrorSeverity(ep_jobErrorMessageNumber) := ep_errorToMessageLevelMap(errh::Severity(ep_err));
                    
                    ! Record the entire stack of error positions
                    p_errStackHeight := errh::NumberOfLocations(ep_err);
                    p_errStackPos := 1 ;
                    while p_errStackPos <= p_errStackHeight do
                    	ep_stackPosition := p_errStackPos;
                    	ep_jobErrorNodes(ep_jobErrorMessageNumber,ep_stackPosition) := errh::Node(ep_err,ep_stackPosition);
                    	ep_JobErrorAttributes(ep_jobErrorMessageNumber,ep_stackPosition) := errh::attribute(ep_err,ep_stackPosition);
                    	p_jobErrorLines( ep_jobErrorMessageNumber,ep_stackPosition) := errh::Line(ep_err,ep_stackPosition);
                    	p_errStackPos += 1 ;
                    endwhile ;
                    
                    if errh::Severity(ep_err) = 'warning' then
                    	p_noWarnings += 1 ;
                    else
                    	p_NoErrors += 1 ;
                    endif ;
                }
                Comment: "Store the error in the data structures of the library.";
                ElementParameter ep_err {
                    Range: errh::PendingErrors;
                    Property: Input;
                }
                Parameter p_errStackHeight;
                Parameter p_errStackPos;
                ElementParameter ep_stackPosition {
                    Range: s_stackPositions;
                }
                ElementParameter ep_jobErrorMessageNumber {
                    Range: s_jobErrorMessageNumbers;
                }
            }
            Procedure pr_openProfiledIdentifier {
                Body: {
                    IdentifierShowAttributes( ep_profilerDataSelectedIdentifier );
                }
            }
            Procedure pr_openIdentifierOnStack {
                Body: {
                    IdentifierShowAttributes(  
                    	ep_jobErrorNodes( ep_errorWarningSelectedMessage, ep_stackPos ));
                }
            }
            Procedure pr_openIdentifierOnMessageList {
                Body: {
                    IdentifierShowAttributes(  
                    	ep_jobErrorNodes( ep_errorWarningSelectedMessage, 1 ));
                }
            }
        }
        Section Inspect_state_session {
            Procedure pr_saveState {
                Arguments: (sp_label,s_selectedIdentifiers);
                Body: {
                    
                    Block ! Determine the subset of identifiers that actually have data to be written to file.
                    	s_selectedIdentifiersWithData := { i_someId |
                    		( i_someId in AllSets ) or
                    		( i_someId in AllParameters ) or
                    		( i_someId in AllVariables ) or
                    		( i_someId in AllConstraints ) };
                    	if not card( s_selectedIdentifiersWithData ) then
                    		raise warning "No data output from gss::SaveState, as no identifier contains data" ;
                    		return 0;
                    	endif ;
                    endblock ;
                    
                    Block ! Materials will be written first to a subfolder of the project folder.  Ensure this intermediate folder exists.
                    	if  not directoryExists( sp_label ) then
                    		directoryCreate( sp_label );
                    	endif ;
                    endblock ;
                    
                    block ! Ensure PRO is connected, initialized, and the PRO Storage folder exists that will contain all text output files
                    	if pro::GetPROEndPoint() then
                    		pro::Initialize();
                    		sp_slash := "/" ;
                    		sp_proStorageFolderName := "/Userdata/" + 
                    			pro::GetPROEnvironment() + sp_slash + 
                    			pro::GetPROUserName()    + sp_slash + 
                    			pro::ModelName           + sp_slash + 
                    			pro::modelversion        + sp_slash + 
                    			sp_label ;
                    		pr_ensurePath( sp_proStorageFolderName );
                    	endif ;
                    endblock ;
                    
                    block ! Each data identifier to be written to file is written to a separate file.
                    	where single_column_display := 1, listing_number_precision := 12, listing_number_width := 20 ;
                    	for i_someIdWithData do
                    		s_singleTonSet := {};
                    		s_singleTonSet += i_someIdWithData ;
                    		sp_filename := spfnc_fileFriendlyName( i_someIdWithData );
                    		sp_fullFilename := sp_label + "\\" + sp_filename;
                    		write s_singleTonSet to file sp_fullFilename ;
                    		if pro::GetPROEndPoint() then
                    			sp_proStorageFileName := sp_proStorageFolderName + sp_slash + sp_filename ;
                    			pro::SaveFileToCentralStorage(
                    				localPath     :  sp_fullFilename, 
                    				storagePath   :  sp_proStorageFileName);
                    		endif ;
                    	endfor ;
                    endblock ;
                }
                StringParameter sp_proStorageFolderName;
                StringParameter sp_proStorageFileName;
                StringParameter sp_slash;
                Set s_selectedIdentifiers {
                    SubsetOf: AllSymbols;
                    Index: i_someId;
                    Property: Input;
                }
                Set s_selectedIdentifiersWithData {
                    SubsetOf: AllIdentifiers;
                    Index: i_someIdWithData;
                }
                Set s_singleTonSet {
                    SubsetOf: AllIdentifiers;
                }
                StringParameter sp_label {
                    Property: Input;
                }
                StringParameter sp_filename;
                StringParameter sp_fullFilename;
            }
        }
    }
    Section Private_Section {
        Property: NoSave;
        Section Main_Library_procedures {
            Procedure LibraryInitialization {
                Comment: "Add initialization statements here that do not require any other library being initialized already.";
            }
            Procedure PostLibraryInitialization {
                Body: {
                    !CurrentInputs -= Library_GuardServerSession ;
                    CurrentInputs -= serverSessionProfilerErrorData ;
                }
                Comment: {
                    "Add initialization statements here that require another library to be initialized already,
                    or add statements that require the Data Management module to be initialized."
                }
            }
            Procedure PreLibraryTermination {
                Body: {
                    return 1;
                }
                Comment: {
                    "Add termination statements here that require all other libraries to be still alive.
                    Return 1 if you allow the termination sequence to continue.
                    Return 0 if you want to cancel the termination sequence."
                }
            }
            Procedure LibraryTermination {
                Body: {
                    return 1;
                }
                Comment: {
                    "Add termination statements here that do not require other libraries to be still alive.
                    Return 1 to allow the termination sequence to continue.
                    Return 0 if you want to cancel the termination sequence.
                    It is recommended to only use the procedure PreLibraryTermination to cancel the termination sequence and let this procedure always return 1."
                }
            }
        }
        Section Guard_utilities {
            Parameter bp_locSeenErrorsAreHandled {
                Range: binary;
                InitialData: 0;
            }
            Index i_errorSeverity {
                Range: errh::AllErrorSeverities;
            }
            ElementParameter ep_errorToMessageLevelMap {
                IndexDomain: i_errorSeverity;
                Range: s_messageLevels;
                Definition: data { 'severe' : 'severe', 'error' : 'error', 'warning' : 'warning' };
            }
            Procedure pr_sampleProc {
                Body: {
                    ! Do not delete this procedure, it is used as default of element parameter gss::ep_Work.
                }
            }
        }
        Section Inspect_utilities {
            Procedure pr_ensurePath {
                Arguments: (sp_path);
                Body: {
                    if not pr_proFolderExists( sp_path ) then
                    	pro::CreateStorageFolder( sp_path );
                    endif ;
                }
                StringParameter sp_path {
                    Property: Input;
                }
            }
            Function spfnc_fileFriendlyName {
                Arguments: (ep_id);
                Range: string;
                Body: {
                    sp_retVal := formatString("%e", ep_id );
                    sp_retVal := FindReplaceStrings( sp_retVal, ":", "_" );
                    
                    spfnc_fileFriendlyName := sp_retVal ;
                }
                ElementParameter ep_id {
                    Range: AllIdentifiers;
                    Property: Input;
                }
                StringParameter sp_retVal;
            }
            Procedure pr_proFolderExists {
                Arguments: (sp_filepath);
                Body: {
                    ! proFolderExists, proDirectoryExists, FolderExists, DirectoryExists
                    pro::NormalizeStoragePath(sp_filepath);
                    p_ret := pro::storage::ListBuckets(
                    			path       :  sp_filepath, 
                    			BucketSet  :  s_locBucketSet, 
                    			BucketSize :  p_locBucketSize, 
                    			BucketAuth :  sp_locBucketAuth, 
                    			BucketDate :  sp_locBucketDate);
                    return p_ret ;
                }
                StringParameter sp_filepath {
                    Property: Input;
                }
                Parameter p_ret;
                Set s_locBucketSet {
                    Index: bs;
                }
                Parameter p_locBucketSize {
                    IndexDomain: bs;
                }
                StringParameter sp_locBucketAuth {
                    IndexDomain: bs;
                }
                StringParameter sp_locBucketDate {
                    IndexDomain: bs;
                }
            }
            Procedure pr_proFileExists {
                Arguments: (sp_filename);
                Body: {
                    pro::NormalizeStoragePath(sp_filename);
                    pro::SplitStoragePath(sp_filename,sp_storageBucketPath,sp_storageFileWithoutPath);
                    if not pr_proFolderExists( sp_storageBucketPath ) then return 0 ; endif ;
                    p_ret := pro::storage::GetObjectInfo(sp_storageBucketPath, sp_storageFileWithoutPath,
                    		sp_tmpLocalFileName, sp_tmpType, p_tmpNum, sp_tmpAuth, p_tmpVersion );
                    if p_ret = 0 or p_tmpNum <= 0 then
                    	return 0 ;
                    endif ;
                    return 1 ;
                }
                Comment: {
                    "d:\\u\\s\\aimms3\\deps\\vc120_x64_Debug\\Libraries\\AimmsWebUI\\AimmsWebUI.ams line 1600
                    d:\\u\\s\\Customers\\K3 Delta\\Escalation March 2017\\6763\\UploadTool\\UploadTool\\UploadTool\\FileExistsFolderExists.ams line 40"
                }
                StringParameter sp_filename {
                    Property: Input;
                }
                Parameter p_ret;
                StringParameter sp_storageBucketPath;
                StringParameter sp_storageFileWithoutPath;
                Parameter p_tmpNum;
                StringParameter sp_tmpLocalFileName;
                StringParameter sp_tmpType;
                StringParameter sp_tmpAuth;
                Parameter p_tmpVersion;
            }
            Function fnc_hasProPrefix {
                Arguments: (sp_filename);
                Range: binary;
                Body: {
                    p_retval := 0 ;
                    
                    if Stringlength( sp_filename ) > 4 then
                    	if findstring( substring( sp_filename, 1, 4 ), "pro:", CaseSensitive:0 ) then
                    		p_retval := 1 ;
                    	else
                    		p_retval := 0 ;
                    	endif ;
                    else
                    	p_retval := 0 ;
                    endif ;
                    
                    fnc_hasProPrefix := p_retval ;
                }
                StringParameter sp_filename {
                    Property: Input;
                }
                Parameter p_retval {
                    Range: binary;
                }
            }
        }
    }
}
