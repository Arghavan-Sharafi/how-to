## ams_version=1.0

LibraryModule Library_GuardServerSession {
	Prefix: gss;
	Interface: Public_Section;
	Comment: {
		"Requirements:
		- Declaration of time, preferably as SI_Time_Duration, including unit s.
		- System library AIMMS PRO
		- Repository library DataExchange
		- AIMMS 4.76 or later
		
		Test WebUI and WinUI apps in Cloud/Prem/Developer"
	}
	Section Public_Section {
		Procedure pr_actionTemplate {
			Body: {
				pr_enter(sp_gssTime, p_gssMiU, ep_logLev: 'info');
				block 
					! Call procedure to do the actual work.
				onerror ep_err do
					gss::pr_appendError( ep_err );
					errh::MarkAsHandled( ep_err );
				endblock ;
				pr_leave(sp_gssTime, p_gssMiU, ep_logLev: 'info');
			}
			Comment: "Sample action procedure";
			DeclarationSection gss_logging_declarations {
				StringParameter sp_gssTime;
				Parameter p_gssMiU;
			}
			DeclarationSection error_reference_declaration {
				ElementParameter ep_err {
					Range: errh::PendingErrors;
				}
			}
		}
		Section WebUI_Support {
			Property: NoSave;
			StringParameter sp_widgetActionMessageList {
				IndexDomain: (webui::indexPageExtension, webui::indexWidgetActionSpec);
				Property: NoSave;
				Definition: {
					{
						('1', 'displaytext' ) : "Model explorer",  
						('1', 'icon'        ) : "aimms-glasses",  
						('1', 'procedure'   ) : "gss::pr_OpenIdentifierOnMessageList",  
						('1', 'state'       ) : "Active"  
					}
				}
				Comment: "Definition of the menu for table ErrorWarningMessageTable on page \"GSS page\".";
			}
			StringParameter sp_itemActionMessageList {
				IndexDomain: (webui::indexWidgetItemActionSpec, webui::indexPageExtension, webui::indexWidgetActionSpec);
				Definition: {
					{
						('gss::ep_shownJobErrorSeverity', '1', 'displaytext' ) : "Model explorer",  
						('gss::ep_shownJobErrorSeverity', '1', 'icon'        ) : "aimms-glasses",  
						('gss::ep_shownJobErrorSeverity', '1', 'procedure'   ) : "gss::pr_OpenIdentifierOnStack",  
						('gss::ep_shownJobErrorSeverity', '1', 'state'       ) : "Active" ,
					
						('gss::sp_shownJobErrorMoments',  '1', 'displaytext' ) : "Model explorer",  
						('gss::sp_shownJobErrorMoments',  '1', 'icon'        ) : "aimms-glasses",  
						('gss::sp_shownJobErrorMoments',  '1', 'procedure'   ) : "gss::pr_OpenIdentifierOnStack",  
						('gss::sp_shownJobErrorMoments',  '1', 'state'       ) : "Active" ,
					
						('gss::sp_shownJobErrorMessages',  '1', 'displaytext' ) : "Model explorer",  
						('gss::sp_shownJobErrorMessages',  '1', 'icon'        ) : "aimms-glasses",  
						('gss::sp_shownJobErrorMessages',  '1', 'procedure'   ) : "gss::pr_OpenIdentifierOnStack",  
						('gss::sp_shownJobErrorMessages',  '1', 'state'       ) : "Active" 
					
					}
				}
				Comment: "Defines the item actions on the table ErrorWarningMessageTable on page \"GSS page\"";
			}
			StringParameter sp_widgetActionMessageStack {
				IndexDomain: (webui::indexPageExtension, webui::indexWidgetActionSpec);
				Definition: {
					{
						('1', 'displaytext' ) : "Model explorer",  
						('1', 'icon'        ) : "aimms-glasses",  
						('1', 'procedure'   ) : "gss::pr_OpenIdentifierOnStack",  
						('1', 'state'       ) : "Active"  
					}
				}
				Comment: "Defines the menu of the table ErrorWarningStack on the GSS Page.";
			}
			StringParameter sp_itemActionMessageStack {
				IndexDomain: (webui::indexWidgetItemActionSpec, webui::indexPageExtension, webui::indexWidgetActionSpec);
				Definition: {
					
					
					{
						('gss::ep_shownJobErrorNodes',     '1', 'displaytext' ) : "Model explorer",  
						('gss::ep_shownJobErrorNodes',     '1', 'icon'        ) : "aimms-glasses",  
						('gss::ep_shownJobErrorNodes',     '1', 'procedure'   ) : "gss::pr_OpenIdentifierOnMessageList",  
						('gss::ep_shownJobErrorNodes',     '1', 'state'       ) : "Active",
					
						('gss::ep_shownJobErrorAttributes', '1', 'displaytext' ) : "Model explorer",  
						('gss::ep_shownJobErrorAttributes', '1', 'icon'        ) : "aimms-glasses",  
						('gss::ep_shownJobErrorAttributes', '1', 'procedure'   ) : "gss::pr_OpenIdentifierOnMessageList",  
						('gss::ep_shownJobErrorAttributes', '1', 'state'       ) : "Active",
					
						('gss::p_shownJobErrorLines',       '1', 'displaytext' ) : "Model explorer",  
						('gss::p_shownJobErrorLines',       '1', 'icon'        ) : "aimms-glasses",  
						('gss::p_shownJobErrorLines',       '1', 'procedure'   ) : "gss::pr_OpenIdentifierOnMessageList",  
						('gss::p_shownJobErrorLines',       '1', 'state'       ) : "Active"  
					}
				}
				Comment: "Defines the item actions for the table ErrorWarningStack on the GSS Page";
			}
			StringParameter sp_widgetActionIdentifierProfiler {
				IndexDomain: (webui::indexPageExtension, webui::indexWidgetActionSpec);
				Definition: {
					{
						('1', 'displaytext' ) : "Model explorer",  
						('1', 'icon'        ) : "aimms-glasses",  
						('1', 'procedure'   ) : "gss::pr_OpenProfiledIdentifier",  
						('1', 'state'       ) : "Active"  
					}
				}
				Comment: "Defines the widget actions for table JobProfilerData";
			}
			StringParameter sp_itemActionIdentifierProfiler {
				IndexDomain: (webui::indexWidgetItemActionSpec, webui::indexPageExtension, webui::indexWidgetActionSpec);
				Definition: {
					{
						('gss::p_shownJobProfilerData', '1', 'displaytext' ) : "Model explorer",  
						('gss::p_shownJobProfilerData', '1', 'icon'        ) : "aimms-glasses",  
						('gss::p_shownJobProfilerData', '1', 'procedure'   ) : "gss::pr_OpenProfiledIdentifier",  
						('gss::p_shownJobProfilerData', '1', 'state'       ) : "Active"  
					}
				}
				Comment: "Defines the item actions for the table JobProfilerData on page \"GSS page\"";
			}
			StringParameter sp_SidePanelErrorPage {
				IndexDomain: (webui::indexApplicationExtension,webui::indexSidePanelSpec);
				Definition: {
					{
						( '1', 'displayText' ) : if p_noSignificantMessages then FormatString("%i msgs", p_noSignificantMessages ) else "" endif,
						( '1', 'pageId'      ) : if p_noSignificantMessages then "errorpanel_1"                                    else "" endif,
						( '1', 'tooltip'     ) : if p_noSignificantMessages then "Error handling"                                  else "" endif,  
						( '1', 'state'       ) : if p_noSignificantMessages then "Active"                                          else "" endif 
					}
				}
			}
			StringParameter sp_messageStatusBar {
				IndexDomain: (webui::indexApplicationExtension,webui::indexStatusBarSpec);
				Definition: {
					{
					
						( '6', 'header'    ) : "", ! (Optional) The Header/Title text you want to display for the status message.
						( '6', 'icon'      ) : ! (Optional) The icon you want to display for the respective message.
							if gss::p_noErrors then "aimms-sad"   
							elseif gss::p_noWarnings then "aimms-wondering" 
							else "aimms-smile" 
							endif, 
						( '6', 'color'     ) : ! (Optional) The color you want to display for the icon.
							if gss::p_noErrors  then "red"  
							elseif gss::p_noWarnings then "orange"   
							else "green" 
							endif,
						( '6', 'text'      ) : ! (REQUIRED) The text you want to display for the status message.
							FormatString("%i warnings and %i errors", 
								gss::p_noWarnings, gss::p_noErrors ), 
						( '6', 'tooltip'   ) : ! (Optional) Tooltip to be displayed when the user hovers over the respective status message.
							if gss::p_noSignificantMessages then "Please visit the page \"GSS page\" for details on the warnings and errors" 
							else "Don't worry, be happy" 
							endif,                
						( '6', 'procedure' ) : ! (Optional) The procedure you want to call when the respective status message is clicked.
							if gss::p_noSignificantMessages then "gss::pr_openErrorHandlingPage" 
							else "gss::pr_openErrorHandlingPage" 
							endif,
						( '6', 'state'     ) : "Active" ! (Optional) Active (displayed and clickable), Inactive (displayed and not clickable) and Hidden (not displayed). By default, the state is Hidden.
					
					}
				}
				Comment: "The message";
			}
			StringParameter sp_titleErrorWarningMessagesTable {
				Definition: formatString("Error and warning messages for session %s", sp_shownSessionDescription);
				Comment: "The title of the table \"ErrorWarningMessageTable\" on page \"GSS page\".";
			}
			StringParameter sp_titleStackMessage {
				Definition: FormatString("Stack of \"%s\"", sp_shownJobErrorMessages( ep_errorWarningSelectedMessage ) );
				Comment: "Title for the table \"ErrorWarningStack\" on page \"GSS page\"";
			}
			StringParameter sp_titleProfilerDetail {
				Definition: FormatString("Profiler data for %e", ep_profilerDataSelectedIdentifier);
				Comment: "The title for the table LineBasedProfilerData on page \"GSS page\".";
			}
			ElementParameter ep_profilerDataSelectedIdentifier {
				Range: AllIdentifiers;
				InitialData: '';
				Comment: {
					"Links the tables JobProfilerData and LineBasedProfilerData
					Via store focus in table JobProfilerData ep_profilerSelectedData is set
					Via identifier settings in table LineBasedProfilerData the profiler details of that procedure are shown."
				}
			}
			ElementParameter ep_errorWarningSelectedMessage {
				Range: s_jobErrorMessageNumbers;
				InitialData: '';
				Comment: {
					"Links the tables ErrorWarningMessageTable and ErrorWarningStack on page \"GSS page\"
					- In table ErrorWarningMessageTable it is a store focus on the message selected.
					- In table ErrorWarningStack it is used to slice on the selected message."
				}
			}
			ElementParameter ep_stackPos {
				Range: s_stackPositions;
				InitialData: '';
				Comment: {
					"In table \"ErrorWarningStack\" on page \"GSS page\", it is used to store the selected position on the stack.
					In procedure gss::pr_openIdentifierOnStack it is used to select the attribute window to open."
				}
			}
			Set s_messageLevels {
				Index: i_messageLevel;
				Definition: {
					data { trace, debug, info, warn, error, fatal } ;
				}
				Comment: "The message levels for tracing";
			}
			Set s_lineNumbers {
				SubsetOf: Integers;
				Index: i_lineNumber;
				Definition: ElementRange(0,1000);
				Comment: "Used for profiler data, line number index.";
			}
			Set s_positiveLineNumbers {
				SubsetOf: s_lineNumbers;
				Index: i_positiveLineNumber;
				Definition: ElementRange(1,1000);
				Comment: "Used for profiling data, see";
			}
			Set s_actualLinenumbers {
				SubsetOf: s_lineNumbers;
				Index: i_actualLineNumber;
				Definition: ElementRange(1,if ep_lastHitLine then ep_lastHitLine else 1 endif);
			}
			Set s_stackPositions {
				SubsetOf: Integers;
				Index: i_stackPosition;
				Definition: ElementRange(1,255);
			}
			Procedure pr_openErrorHandlingPage {
				Body: {
					block 
						webui::OpenPage(pageId : 'gss_page' );
					onerror ep_err do
						pr_appendError( ep_err );
						errh::MarkAsHandled( ep_err );
					endblock ;
				}
				Comment: "Opens the page \"GSS page\" upon clicking the GSS notification/status bar (at the bottom of the screen).";
				ElementParameter ep_err {
					Range: errh::PendingErrors;
				}
			}
		}
		Section PRO_Support {
			Set s_inputCaseIdentifiers {
				SubsetOf: AllIdentifiers;
				Definition: controlServerSessionData;
				Comment: {
					"The set of identifiers in the GSS library that should be part of an \"input case\". 
					The \"input case\" is the case transferred from the client session to the solver session upon start of the solver session.
					Please ensure that pro::ManagedSessionInputCaseIdentifierSet contains the data from s_inputCaseIdentifiers"
				}
			}
			Set s_outputCaseIdentifiers {
				SubsetOf: AllIdentifiers;
				Definition: serverSessionErrorData;
				Comment: {
					"The data in the GSS library that is to be added to the output case.
					The output case is the case transferred from a solver session to the data session upon completion of that solver session.
					Please ensure that the set pro::ManagedSessionOutputCaseIdentifierSet contains the elements from 
					s_outputCaseIdentifiers before the delegated procedure returns in each solver session."
				}
			}
		}
		Section Guarding {
			Comment: "This section is about guarding server sessions and managing error data.";
			Section GSS_Error_WebUI_Support {
				Property: NoSave;
				DeclarationSection Declaration_selection_shown_session {
					ElementParameter ep_shownSession {
						Range: s_trackedSessions;
						InitialData: '';
						Comment: "By convention, if the shown session is the first then the running data session is selected.";
						webui::UponChangeProcedure: pr_uponChangeShownSession;
					}
				}
				Procedure pr_uponChangeShownSession {
					Body: {
						gss::pr_enter(sp_gssTime, p_gssMiU, ep_logLev: 'info', 
							formatString("Going to show %e", 
								ep_shownSession));
						block 
							empty Shown_session_data_exchange ;
						
							sp_shownSessionDescription :=
								if ep_shownSession = first( s_trackedSessions ) then
									"data session"
								else
									sp_sessionGivenDescriptions(ep_shownSession)
								endif ;
						
							p_shownJobProfilerData(IndexIdentifiers, i_lineNumber, IndexProfilerTypes ) := 
								if ep_shownSession <> first( s_trackedSessions ) then
									p_trackedJobProfilerData(ep_shownSession, IndexIdentifiers, i_lineNumber, IndexProfilerTypes)
								else
									p_dataSessionProfilerData(IndexIdentifiers, i_lineNumber, IndexProfilerTypes)
								endif;
						
							sp_shownJobErrorMessages(i_jobErrorMessageNumber) := 
								if ep_shownSession <> first( s_trackedSessions ) then
									sp_trackedJobErrorMessages(ep_shownSession, i_jobErrorMessageNumber)
								else
									sp_dataSessionErrorMessages(i_jobErrorMessageNumber)
								endif ;
						
							sp_shownJobErrorMoments(i_jobErrorMessageNumber) := 
								if ep_shownSession <> first( s_trackedSessions ) then
									sp_trackedJobErrorMoments(ep_shownSession, i_jobErrorMessageNumber)
								else
									sp_dataSessionErrorMoments(i_jobErrorMessageNumber)
								endif;
						
							ep_shownJobErrorSeverity(i_jobErrorMessageNumber) := 
								if ep_shownSession <> first( s_trackedSessions ) then
									ep_trackedJobErrorSeverity(ep_shownSession, i_jobErrorMessageNumber)
								else
									ep_dataSessionErrorSeverity(i_jobErrorMessageNumber)
								endif;
						
							ep_shownJobErrorNodes(i_jobErrorMessageNumber, i_stackPosition) := 
								if ep_shownSession <> first( s_trackedSessions ) then
									ep_trackedJobErrorNodes(ep_shownSession, i_jobErrorMessageNumber,i_stackPosition)
								else
									ep_dataSessionErrorNodes(i_jobErrorMessageNumber,i_stackPosition)
								endif;
						
							ep_shownJobErrorAttributes(i_jobErrorMessageNumber, i_stackPosition) := 
								if ep_shownSession <> first( s_trackedSessions ) then
									ep_trackedJobErrorAttributes(ep_shownSession, i_jobErrorMessageNumber,i_stackPosition)
								else
									ep_dataSessionErrorAttributes(i_jobErrorMessageNumber,i_stackPosition)
								endif;
						
							p_shownJobErrorLines(i_jobErrorMessageNumber, i_stackPosition) := 
								if ep_shownSession <> first( s_trackedSessions ) then
									p_trackedJobErrorLines(ep_shownSession, i_jobErrorMessageNumber,i_stackPosition)
								else
									p_dataSessionErrorLines(i_jobErrorMessageNumber,i_stackPosition)
								endif;
						onerror ep_err do
							pr_appendError( ep_err );
							errh::MarkAsHandled( ep_err );
						endblock ;
						gss::pr_leave(sp_gssTime, p_gssMiU, ep_logLev: 'info', 
							formatString("Now the error and profiler tables show %e with description %s", 
								ep_shownSession, sp_shownSessionDescription));
					}
					Comment: {
						"This procedure takes care of the following:
						When the element parameter ep_shownSession is modified in the dropdown, 
						the contents of all tables on page \"GSS page\" should be adapted accordingly."
					}
					DeclarationSection gss_logging_declarations {
						StringParameter sp_gssTime;
						Parameter p_gssMiU;
					}
					ElementParameter ep_err {
						Range: errh::PendingErrors;
					}
				}
				DeclarationSection Shown_session_data_exchange {
					StringParameter sp_shownSessionDescription {
						InitialData: "";
						Comment: {
							"- When the shown session is the data session, then the phrase \"data session\"
							- When the shown session is a solver session, then the description (if any) of that solver session.
							This string parameter is used in titles and so on."
						}
					}
					Parameter p_shownJobProfilerData {
						IndexDomain: (IndexIdentifiers,i_lineNumber,IndexProfilerTypes );
						Comment: "The profiler data shown on the GSS page in the tables JobProfilerData and LineBasedProfilerData.";
					}
					StringParameter sp_shownJobErrorMessages {
						IndexDomain: i_jobErrorMessageNumber;
						Comment: "The error messages shown in the table ErrorWarningMessageTable on page \"GSS page\"";
					}
					StringParameter sp_shownJobErrorMoments {
						IndexDomain: i_jobErrorMessageNumber;
						Comment: "The moment the error was recorded for each of the errors in the table ErrorWarningMessageTable on the page \"GSS page\"";
					}
					ElementParameter ep_shownJobErrorSeverity {
						IndexDomain: i_jobErrorMessageNumber;
						Range: s_messageLevels;
						Comment: "The severity of the error for each of the errors in the table \"ErrorWarningMessageTable\" on the page \"GSS page\".";
					}
					ElementParameter ep_shownJobErrorNodes {
						IndexDomain: (i_jobErrorMessageNumber,i_stackPosition);
						Range: AllSymbols;
						Comment: "For the selected error / warning the identifiers on the execution stack in the table \"ErrorWarningStack\" on page \"GSS page\"";
					}
					ElementParameter ep_shownJobErrorAttributes {
						IndexDomain: (i_jobErrorMessageNumber,i_stackPosition);
						Range: AllAttributeNames;
						Comment: {
							"The active attribute of the identifiers that are on the execution stack shown 
							in the table \"ErrorWarningStack\" on the page \"GSS page\""
						}
					}
					Parameter p_shownJobErrorLines {
						IndexDomain: (i_jobErrorMessageNumber,i_stackPosition);
						Comment: {
							"The active line of the identifiers that are on the execution stack shown 
							in the table \"ErrorWarningStack\" on the page \"GSS page\""
						}
					}
				}
			}
			Section Tracked_sessions {
				Property: NoSave;
				Comment: {
					"This section collects the error and profiler data coming from 
					data session, solver sessions and from uploaded sessions."
				}
				DeclarationSection tracked_sessions_error_and_profiler_data {
					Set s_trackedSessions {
						Index: i_trackedSession;
						Comment: "The names of all sessions tracked.";
						webui::ElementTextIdentifier: gss::sp_trackedSessionDescription;
					}
					StringParameter sp_trackedSessionDescription {
						IndexDomain: i_trackedSession;
						Definition: {
							if i_trackedSession = first( s_trackedSessions ) then
								formatString("%e : data session", i_trackedSession )
							else
								formatString("%e : %s",
									i_trackedSession, 
									sp_sessionGivenDescriptions( i_trackedSession ) )
							endif
						}
						Comment: {
							"The element description is the name of the sessio ( a guid ) extended with the description of the job given 
							by the call to pro::DelegateServer"
						}
					}
					StringParameter sp_sessionGivenDescriptions {
						IndexDomain: i_trackedSession;
						InitialData: data {};
						Comment: "Maintain the description given of the sessions collected.";
					}
					Parameter p_trackedJobProfilerData {
						IndexDomain: (i_trackedSession,IndexIdentifiers,i_lineNumber,IndexProfilerTypes );
						InitialData: data{};
						Comment: "Jobprofiler data, now per tracked session";
					}
					StringParameter sp_trackedJobErrorMessages {
						IndexDomain: (i_trackedSession,i_jobErrorMessageNumber);
						InitialData: data {};
						Comment: "Error messages, per tracked session";
					}
					StringParameter sp_trackedJobErrorMoments {
						IndexDomain: (i_trackedSession,i_jobErrorMessageNumber);
						InitialData: data {};
						Comment: "tracked per session, the moments the error occurred";
					}
					ElementParameter ep_trackedJobErrorSeverity {
						IndexDomain: (i_trackedSession,i_jobErrorMessageNumber);
						Range: s_messageLevels;
						InitialData: data {};
						Comment: "Tracked per session, the severity of each error";
					}
					ElementParameter ep_trackedJobErrorNodes {
						IndexDomain: (i_trackedSession,i_jobErrorMessageNumber,i_stackPosition);
						Range: AllSymbols;
						InitialData: data{};
						Comment: "Tracked per session, the stack of identifiers";
					}
					ElementParameter ep_trackedJobErrorAttributes {
						IndexDomain: (i_trackedSession,i_jobErrorMessageNumber,i_stackPosition);
						Range: AllAttributeNames;
						InitialData: data {};
						Comment: "Tracked per session, the stack of attribes per error";
					}
					Parameter p_trackedJobErrorLines {
						IndexDomain: (i_trackedSession,i_jobErrorMessageNumber,i_stackPosition);
						InitialData: data {};
						Comment: "Tracked per session, per error, the stack of line numbers";
					}
				}
				Procedure pr_saveTrackedSessionData {
					Arguments: (sp_sessionID);
					Body: {
						if not sp_sessionID then
							raise error "pr_saveTrackedSessionData() unable to store session data without identification" ;
						endif ;
						ep_trackedSession := stringToElement( s_trackedSessions, sp_sessionID, create:1);
						if not ep_trackedSession then
							raise error "pr_saveTrackedSessionData() unable to create effective session id";
						endif ;
						
						p_trackedJobProfilerData(ep_trackedSession, IndexIdentifiers, i_lineNumber, IndexProfilerTypes) := p_jobProfilerData(IndexIdentifiers, i_lineNumber, IndexProfilerTypes);
						
						sp_trackedJobErrorMessages(ep_trackedSession, i_jobErrorMessageNumber) := sp_jobErrorMessages(i_jobErrorMessageNumber);
						sp_trackedJobErrorMoments( ep_trackedSession, i_jobErrorMessageNumber) := sp_jobErrorMoments( i_jobErrorMessageNumber);
						ep_trackedJobErrorSeverity(ep_trackedSession, i_jobErrorMessageNumber) := ep_jobErrorSeverity(i_jobErrorMessageNumber);
						
						ep_trackedJobErrorNodes(     ep_trackedSession, i_jobErrorMessageNumber, i_stackPosition) := ep_jobErrorNodes(     i_jobErrorMessageNumber, i_stackPosition);
						ep_trackedJobErrorAttributes(ep_trackedSession, i_jobErrorMessageNumber, i_stackPosition) := ep_jobErrorAttributes(i_jobErrorMessageNumber, i_stackPosition);
						p_trackedJobErrorLines(      ep_trackedSession, i_jobErrorMessageNumber, i_stackPosition) := p_jobErrorLines(      i_jobErrorMessageNumber, i_stackPosition);
					}
					StringParameter sp_sessionID {
						Property: Input;
					}
					ElementParameter ep_trackedSession {
						Range: s_trackedSessions;
					}
				}
				Procedure pr_uploadErrorData {
					Arguments: (fileLocation,statusCode,statusDescription);
					Body: {
						gss::pr_enter(sp_gssTime, p_gssMiU, ep_logLev: 'info');
						block
							pr_logMsg(formatString("Uploading file %s", fileLocation),'info');
							sp_fileUploadLocation := webui::GetIOFilePath(fileLocation);
							! The file is uploaded to the process specific temporary folder. 
						
							empty Shown_session_data_exchange;
							ep_trackedSession := StringToElement( s_trackedSessions, fileLocation, create:1);
							read from file sp_fileUploadLocation ;
						
							block ! Copy the data loaded in from the case in the Tracked session container.
								sp_sessionGivenDescriptions( ep_trackedSession ) := sp_shownSessionDescription ;
								p_trackedJobProfilerData(ep_trackedSession, IndexIdentifiers, i_lineNumber, IndexProfilerTypes) := p_shownJobProfilerData(IndexIdentifiers, i_lineNumber, IndexProfilerTypes);
								sp_trackedJobErrorMessages(ep_trackedSession, i_jobErrorMessageNumber) := sp_shownJobErrorMessages(i_jobErrorMessageNumber);
								sp_trackedJobErrorMoments(ep_trackedSession, i_jobErrorMessageNumber) := sp_shownJobErrorMoments(i_jobErrorMessageNumber);
								ep_trackedJobErrorSeverity(ep_trackedSession, i_jobErrorMessageNumber) := ep_shownJobErrorSeverity(i_jobErrorMessageNumber);
								ep_trackedJobErrorNodes(ep_trackedSession, i_jobErrorMessageNumber, i_stackPosition) := ep_shownJobErrorNodes(i_jobErrorMessageNumber, i_stackPosition);
								ep_trackedJobErrorAttributes(ep_trackedSession, i_jobErrorMessageNumber, i_stackPosition) := ep_shownJobErrorAttributes(i_jobErrorMessageNumber, i_stackPosition);
								p_trackedJobErrorLines(ep_trackedSession, i_jobErrorMessageNumber, i_stackPosition) := p_shownJobErrorLines(i_jobErrorMessageNumber, i_stackPosition);
								ep_shownSession := ep_trackedSession ;
							endblock ;
						
							statusCode := webui::ReturnStatusCode('OK');
							statusDescription := "Succesfully uploaded file "+fileLocation;
						onerror ep_err do
							gss::pr_appendError(ep_err);
							errh::MarkAsHandled(ep_err);
							if errh::Severity(ep_err) <> 'warning' then
								statusCode := webui::ReturnStatusCode('ERROR');
								statusDescription := "Failed to upload file " + fileLocation ;
							endif ;
						endblock ;
						gss::pr_leave(sp_gssTime, p_gssMiU, ep_logLev: 'info');
					}
					DeclarationSection gss_logging_declarations {
						StringParameter sp_gssTime;
						Parameter p_gssMiU;
					}
					StringParameter fileLocation {
						Property: Input;
					}
					Parameter statusCode {
						Property: Output;
					}
					StringParameter statusDescription {
						Property: Output;
					}
					StringParameter sp_fileUploadLocation;
					ElementParameter ep_trackedSession {
						Range: s_trackedSessions;
					}
					ElementParameter ep_err {
						Range: errh::PendingErrors;
					}
				}
				Procedure pr_downloadErrorData {
					Arguments: (fileLocation,statusCode,statusDescription);
					Body: {
						gss::pr_enter(sp_gssTime, p_gssMiU, ep_logLev: 'info');
						block
						
							gss::pr_initErrorHandlingDownloadUploadButtons( ep_stat, statusCode,  statusDescription, bp_download:1 );
						
							!fileLocation := formatString("%e.errors.json", ep_shownSession );
							fileLocation := formatString("%e.errors", ep_shownSession );
						
							! we store the location of the file in string parameter sp_FinalLocation
							sp_finalLocation := webui::GetIOFilePath(fileLocation);
						
							! writing the string parameter FinalLocation to a text file
							sp_shownSessionDescription := sp_sessionGivenDescriptions( ep_shownSession );
							block where single_column_display := 1;
								write Shown_session_data_exchange to file sp_finalLocation ;
							endblock ;
						
							! checking if the previous write statement was successful or not
							if FileExists(sp_finalLocation) then
						
								! if successful, statusCode is set to 'CREATED' which will trigger the download widget to show the Get button
								StatusCode := webui::ReturnStatusCode('CREATED');
								! displaying the status message as All perfect instead of the default "File ready to download"
								StatusDescription := "All perfect!";
						
							else    ! if previous write statement was not successful
						
								! setting the statusCode to 'ERROR' and the download widget will not show the Get button anymore
								statusCode := webui::ReturnStatusCode('ERROR');
								! displaying a custom error message
								statusDescription := "Something went wrong when creating the file.";
						
							endif;
						
						onerror ep_err do
						
							gss::pr_appendError(ep_err);
							gss::pr_uploadDownloadWidgetErrorHandling( ep_err, ep_stat, statusCode, statusDescription); 
						
							errh::MarkAsHandled(ep_err);
						
						endblock ;
						gss::pr_leave(sp_gssTime, p_gssMiU, ep_logLev: 'info');
					}
					Comment: "Download profiler and error data of the selected data or solver session to file.";
					StringParameter fileLocation {
						Property: Output;
					}
					Parameter statusCode {
						Property: Output;
					}
					StringParameter statusDescription {
						Property: Output;
					}
					StringParameter sp_finalLocation;
					ElementParameter ep_stat {
						Range: errh::AllErrorSeverities;
					}
					ElementParameter ep_err {
						Range: errh::PendingErrors;
					}
					DeclarationSection gss_logging_declarations {
						StringParameter sp_gssTime;
						Parameter p_gssMiU;
					}
				}
				Procedure pr_downloadErrorReport {
					Arguments: (fileLocation,statusCode,statusDescription);
					Body: {
						gss::pr_enter(sp_gssTime, p_gssMiU, ep_logLev: 'info');
						block 
							gss::pr_initErrorHandlingDownloadUploadButtons( ep_stat, statusCode,  statusDescription, bp_download:1 );
						
							fileLocation := "usage.errorLogging";
						
							! we store the location of the file in string parameter FinalLocation
							sp_finalLocation := webui::GetIOFilePath(fileLocation);
						
							! writing the string parameter FinalLocation to a text file
							pr_openPageErrorWarningProfiler();
							pr_reportCurrentErrorsToTextFile( sp_finalLocation );
						
							! checking if the previous write statement was successful or not
							if FileExists(sp_finalLocation) then
						
								! if successful, statusCode is set to 'CREATED' which will trigger the download widget to show the Get button
								StatusCode := webui::ReturnStatusCode('CREATED');
								! displaying the status message as All perfect instead of the default "File ready to download"
								StatusDescription := "All perfect!";
						
							else    !if previous write statement was not successful
						
								! setting the statusCode to 'ERROR' and the download widget will not show the Get button anymore
								statusCode := webui::ReturnStatusCode('ERROR');
								!displaying a custom error message
								statusDescription := "Something went wrong when creating the file.";
						
							endif;
						
						onerror ep_err do
						
							gss::pr_appendError(ep_err);
							gss::pr_uploadDownloadWidgetErrorHandling( ep_err, ep_stat, statusCode, statusDescription); 
						
							errh::MarkAsHandled(ep_err);
						
						endblock ;
						gss::pr_leave(sp_gssTime, p_gssMiU, ep_logLev: 'info');
					}
					Comment: "Download the error data in a readable report.";
					DeclarationSection gss_logging_declarations {
						StringParameter sp_gssTime;
						Parameter p_gssMiU;
					}
					StringParameter fileLocation {
						Property: Output;
					}
					Parameter statusCode {
						Property: Output;
					}
					StringParameter statusDescription {
						Property: Output;
					}
					StringParameter sp_finalLocation;
					ElementParameter ep_err {
						Range: errh::PendingErrors;
					}
					ElementParameter ep_stat {
						Range: errh::AllErrorSeverities;
					}
				}
			}
			Section Data_session {
				Property: NoSave;
				DeclarationSection dataSessionProfilerErrorData {
					ElementParameter ep_dataSessionIncident {
						Range: s_jobErrorMessageNumbers;
					}
					Parameter p_dataSessionProfilerData {
						IndexDomain: (IndexIdentifiers,i_lineNumber,IndexProfilerTypes );
						InitialData: data{};
					}
					StringParameter sp_dataSessionErrorMessages {
						IndexDomain: i_dataSessionErrorMessageNumber;
						InitialData: data{};
					}
					StringParameter sp_dataSessionErrorMoments {
						IndexDomain: i_dataSessionErrorMessageNumber;
						InitialData: data{};
					}
					ElementParameter ep_dataSessionErrorSeverity {
						IndexDomain: i_dataSessionErrorMessageNumber;
						Range: s_messageLevels;
						InitialData: data{};
					}
					ElementParameter ep_dataSessionErrorNodes {
						IndexDomain: (i_dataSessionErrorMessageNumber,i_stackPosition);
						Range: AllSymbols;
						InitialData: data {};
					}
					ElementParameter ep_dataSessionErrorAttributes {
						IndexDomain: (i_dataSessionErrorMessageNumber,i_stackPosition);
						Range: AllAttributeNames;
						InitialData: data {};
					}
					Parameter p_dataSessionErrorLines {
						IndexDomain: (i_dataSessionErrorMessageNumber,i_stackPosition);
						InitialData: data {};
					}
				}
				DeclarationSection data_session_summary {
					Parameter p_noLogMessages {
						InitialData: 0;
					}
					Parameter p_noWarnings {
						InitialData: 0;
					}
					Parameter p_noErrors {
						InitialData: 0;
					}
				}
				Procedure pr_collectProfilerData {
					Body: {
						ProfilerCollectAllData(
							ProfilerData       :  p_dataSessionProfilerData, 
							GrossTimeThreshold :  0, 
							NetTimeThreshold   :  0);
					}
					Comment: "collect the profiler data of";
				}
				Procedure pr_dataSessionClearErrors {
					Body: {
						empty dataSessionProfilerErrorData;
						p_noLogMessages := 0 ;
						p_noWarnings := 0 ;
						p_noErrors := 0 ;
					}
				}
				Procedure pr_appendErrorDataSession {
					Arguments: (ep_err,sp_prefix);
					Body: {
						! Increase the number of recorded error messages.
						pr_newIncidentDataSession();
						
						ep_jobErrorMessageNumber := ep_dataSessionIncident ;
						
						sp_msg := sp_prefix + errh::Message( ep_err);
						
						! Record the message and severity.
						sp_dataSessionErrorMessages(ep_JobErrorMessageNumber) := sp_msg;
						sp_dataSessionErrorMoments( ep_jobErrorMessageNumber) := errh::CreationTime(ep_err,"%c%y-%m-%d %H:%M:%S:%T%TZ('local')");
						ep_dataSessionErrorSeverity(ep_jobErrorMessageNumber) := ep_errorToMessageLevelMap(errh::Severity(ep_err));
						
						! Record the entire stack of error positions
						p_errStackHeight := errh::NumberOfLocations(ep_err);
						p_errStackPos := 1 ;
						while p_errStackPos <= p_errStackHeight do
							ep_stackPosition := p_errStackPos;
							ep_dataSessionErrorNodes(ep_jobErrorMessageNumber,ep_stackPosition) := errh::Node(ep_err,ep_stackPosition);
							ep_dataSessionErrorAttributes(ep_jobErrorMessageNumber,ep_stackPosition) := errh::attribute(ep_err,ep_stackPosition);
							p_dataSessionErrorLines( ep_jobErrorMessageNumber,ep_stackPosition) := errh::Line(ep_err,ep_stackPosition);
							p_errStackPos += 1 ;
						endwhile ;
						
						if errh::Severity(ep_err) = 'warning' then
							p_noWarnings += 1 ;
						else
							p_NoErrors += 1 ;
						endif ;
					}
					Comment: "Store the error in the data structures of the library.";
					ElementParameter ep_err {
						Range: errh::PendingErrors;
						Property: Input;
					}
					Parameter p_errStackHeight;
					Parameter p_errStackPos;
					ElementParameter ep_stackPosition {
						Range: s_stackPositions;
					}
					ElementParameter ep_jobErrorMessageNumber {
						Range: s_jobErrorMessageNumbers;
					}
					StringParameter sp_prefix {
						Property: Optional;
					}
					StringParameter sp_msg;
				}
				Procedure pr_appendMessageDataSession {
					Arguments: (sp_msg,ep_lev);
					Body: {
						! Increase the number of recorded error messages.
						pr_newIncidentDataSession();
						ep_jobErrorMessageNumber := ep_dataSessionIncident;
						
						! Record the message and severity.
						sp_dataSessionErrorMessages(ep_jobErrorMessageNumber) := sp_msg;
						sp_dataSessionErrorMoments( ep_jobErrorMessageNumber) := CurrentToString("%c%y-%m-%d %H:%M:%S:%T");
						ep_dataSessionErrorSeverity(ep_jobErrorMessageNumber) := ep_lev;
						
						! Record the entire stack of error positions
						p_errStackHeight := callerNumberOfLocations();
						p_errStackPos := 1 ;
						while p_errStackPos <= p_errStackHeight do
							ep_stackPosition := p_errStackPos;
							ep_dataSessionErrorNodes(     ep_jobErrorMessageNumber,ep_stackPosition) := callerNode(     ep_stackPosition);
							ep_dataSessionErrorAttributes(ep_jobErrorMessageNumber,ep_stackPosition) := callerAttribute(ep_stackPosition);
							p_dataSessionErrorLines(      ep_jobErrorMessageNumber,ep_stackPosition) := callerLine(     ep_stackPosition);
							p_errStackPos += 1 ;
						endwhile ;
						
						p_noLogMessages += 1 ;
					}
					Comment: "Store the error in the data structures of the library.";
					Parameter p_errStackHeight;
					Parameter p_errStackPos;
					ElementParameter ep_stackPosition {
						Range: s_stackPositions;
					}
					ElementParameter ep_jobErrorMessageNumber {
						Range: s_jobErrorMessageNumbers;
					}
					StringParameter sp_msg {
						Property: Input;
					}
					ElementParameter ep_lev {
						Range: s_messageLevels;
						Default: 'info';
						Property: Optional;
					}
				}
			}
			Section Guard_server_session {
				DeclarationSection controlServerSessionData {
					Comment: {
						"Contains parameters that are used to control GSS library in server sessions.
						They are passed along in the input case."
					}
					ElementParameter ep_tracingFilterlevel {
						Range: s_messageLevels;
						InitialData: 'info';
						Comment: "The tracing level used during the session.";
					}
				}
				DeclarationSection serverSessionErrorData {
					StringParameter sp_serverSessionId {
						Comment: {
							"The session id of the server session. Also known as requestID.
							Often obtained by calling pro::session::CurrentSession directly after pro::delegate."
						}
					}
					Parameter p_jobProfilerData {
						IndexDomain: (IndexIdentifiers,i_lineNumber,IndexProfilerTypes );
						InitialData: data {};
						Comment: "The profiler data of the job just ran.";
					}
					StringParameter sp_jobErrorMessages {
						IndexDomain: i_jobErrorMessageNumber;
						Comment: "The error messages of the job just ran";
					}
					StringParameter sp_jobErrorMoments {
						IndexDomain: i_jobErrorMessageNumber;
						Comment: "The moments the errors occurred  of the job just ran";
					}
					ElementParameter ep_jobErrorSeverity {
						IndexDomain: i_jobErrorMessageNumber;
						Range: s_messageLevels;
						Comment: "The severities of the errors  of the job just ran";
					}
					ElementParameter ep_jobErrorNodes {
						IndexDomain: (i_jobErrorMessageNumber,i_stackPosition);
						Range: AllSymbols;
						Comment: "The identifiers on the execution stack of the errors  of the job just ran";
					}
					ElementParameter ep_jobErrorAttributes {
						IndexDomain: (i_jobErrorMessageNumber,i_stackPosition);
						Range: AllAttributeNames;
						Comment: "The attributes on the execution stack of the errors  of the job just ran";
					}
					Parameter p_jobErrorLines {
						IndexDomain: (i_jobErrorMessageNumber,i_stackPosition);
						Comment: "The line numbers on the execution stack of the errors  of the job just ran";
					}
				}
				Procedure pr_guardAndProfileServerJob {
					Arguments: (ep_work);
					Body: {
						block
							pr_openLogFile();
							empty serverSessionErrorData ;
							sp_serverSessionId := sp_thisSession ;
						
							! Ensure that the error recorded and profiler data are transmitted via the output case:
							pro::ManagedSessionOutputCaseIdentifierSet += s_outputCaseIdentifiers ;
						
							! Actual work.
							apply( ep_work);
						
							! Ensure that the definitions of all defined sets and defined parameters in 
							! output case identifier set are profiled.
							update pro::ManagedSessionOutputCaseIdentifierSet;
						
						onerror ep_err do
						
							pr_appendError( ep_err );
						
							! Don't let the server job be halted by this error; 
							! we still want the result case including the profiled data.
							errh::MarkAsHandled(ep_err);
						
						endblock ;
						ProfilerCollectAllData(
							ProfilerData       :  p_jobProfilerData, 
							GrossTimeThreshold :  0, 
							NetTimeThreshold   :  0);
						
						pr_saveActionLogFile();
					}
					Comment: {
						"To be called when a job is delegated; it will ensure that :
						1) Errors and warnings issued during the execution of the actual work in procedure ep_work are collected.
						2) That profiling information during the execution of the procedure ep_work is collected
						3) That the logging is saved and stored in AIMMS PRO Storage."
					}
					ElementParameter ep_err {
						Range: errh::PendingErrors;
					}
					ElementParameter ep_work {
						Range: AllProcedures;
						Default: 'gss::pr_sampleProc';
						Property: Input;
					}
				}
				Procedure pr_appendErrorJob {
					Arguments: (ep_err,sp_prefix);
					Body: {
						! Increase the number of recorded error messages.
						pr_newIncidentJob();
						ep_jobErrorMessageNumber := ep_jobIncident;
						
						sp_msg := sp_prefix + errh::Message( ep_err);
						
						! Record the message and severity.
						sp_jobErrorMessages(ep_JobErrorMessageNumber) := sp_msg;
						sp_jobErrorMoments( ep_jobErrorMessageNumber) := errh::CreationTime(ep_err,"%c%y-%m-%d %H:%M:%S:%T%TZ('local')");
						ep_jobErrorSeverity(ep_jobErrorMessageNumber) := ep_errorToMessageLevelMap(errh::Severity(ep_err));
						
						! Record the entire stack of error positions
						p_errStackHeight := errh::NumberOfLocations(ep_err);
						p_errStackPos := 1 ;
						while p_errStackPos <= p_errStackHeight do
							ep_stackPosition := p_errStackPos;
							ep_jobErrorNodes(ep_jobErrorMessageNumber,ep_stackPosition) := errh::Node(ep_err,ep_stackPosition);
							ep_JobErrorAttributes(ep_jobErrorMessageNumber,ep_stackPosition) := errh::attribute(ep_err,ep_stackPosition);
							p_jobErrorLines( ep_jobErrorMessageNumber,ep_stackPosition) := errh::Line(ep_err,ep_stackPosition);
							p_errStackPos += 1 ;
						endwhile ;
						
						if errh::Severity(ep_err) = 'warning' then
							p_noWarnings += 1 ;
						else
							p_NoErrors += 1 ;
						endif ;
					}
					Comment: "Store the error in the data structures of the library.";
					ElementParameter ep_err {
						Range: errh::PendingErrors;
						Property: Input;
					}
					Parameter p_errStackHeight;
					Parameter p_errStackPos;
					ElementParameter ep_stackPosition {
						Range: s_stackPositions;
					}
					ElementParameter ep_jobErrorMessageNumber {
						Range: s_jobErrorMessageNumbers;
					}
					StringParameter sp_prefix {
						Property: Optional;
					}
					StringParameter sp_msg;
				}
				Procedure pr_appendMessageJob {
					Arguments: (sp_msg,ep_lev);
					Body: {
						! Increase the number of recorded error messages.
						pr_newIncidentJob();
						ep_jobErrorMessageNumber := ep_jobIncident ;
						
						! Record the message and severity.
						sp_jobErrorMessages(ep_jobErrorMessageNumber) := sp_msg;
						sp_jobErrorMoments( ep_jobErrorMessageNumber) := CurrentToString("%c%y-%m-%d %H:%M:%S:%T");
						ep_jobErrorSeverity(ep_jobErrorMessageNumber) := ep_lev;
						
						! Record the entire stack of error positions
						p_errStackHeight := callerNumberOfLocations();
						p_errStackPos := 1 ;
						while p_errStackPos <= p_errStackHeight do
							ep_stackPosition := p_errStackPos;
							ep_jobErrorNodes(     ep_jobErrorMessageNumber,ep_stackPosition) := callerNode(     ep_stackPosition);
							ep_JobErrorAttributes(ep_jobErrorMessageNumber,ep_stackPosition) := callerAttribute(ep_stackPosition);
							p_jobErrorLines(      ep_jobErrorMessageNumber,ep_stackPosition) := callerLine(     ep_stackPosition);
							p_errStackPos += 1 ;
						endwhile ;
						
						p_noLogMessages += 1 ;
					}
					Comment: "Store the error in the data structures of the library.";
					Parameter p_errStackHeight;
					Parameter p_errStackPos;
					ElementParameter ep_stackPosition {
						Range: s_stackPositions;
					}
					ElementParameter ep_jobErrorMessageNumber {
						Range: s_jobErrorMessageNumbers;
					}
					StringParameter sp_msg {
						Property: Input;
					}
					ElementParameter ep_lev {
						Range: s_messageLevels;
						Default: 'info';
						Property: Optional;
					}
				}
				Procedure LoadResultsCallBack {
					Arguments: (sp_requestID);
					Body: {
						block
							pro::session::LoadResultsCallBack(sp_requestID);
							gss::pr_saveTrackedSessionData( sp_requestID );
						onerror ep_err do
							pr_appendError( ep_err );
							errh::MarkAsHandled( ep_err );
						endblock ;
					}
					Comment: {
						"The normal load results callback and store error and profiler data of the solver session
						in the Tracked sessions container."
					}
					StringParameter sp_requestID {
						Property: Input;
					}
					ElementParameter ep_err {
						Range: errh::PendingErrors;
					}
				}
			}
			Section Utility_section {
				Property: NoSave;
				Comment: "Catchall section.";
				Parameter p_maxNoErrorsPerSession {
					InitialData: 10000;
					Comment: "Max number of informational messages, warnings, and errors stored per job.";
				}
				Set s_jobErrorMessageNumbers {
					SubsetOf: Integers;
					Index: i_jobErrorMessageNumber, i_dataSessionErrorMessageNumber;
					Property: ElementsAreNumerical;
					Definition: ElementRange(1,p_maxNoErrorsPerSession);
				}
				Procedure pr_openProfiledIdentifier {
					Body: {
						block
							if ep_profilerDataSelectedIdentifier then
								IdentifierShowAttributes( ep_profilerDataSelectedIdentifier );
							endif ;
						onerror ep_err do
							pr_appendError( ep_err );
							errh::MarkAsHandled( ep_err );
						endblock ;
					}
					Comment: {
						"Open the attribute window of an identifier i
						Used in widget action and item action of the table JobProfilerData on page \"GSS page\""
					}
					ElementParameter ep_err {
						Range: errh::PendingErrors;
					}
				}
				Procedure pr_openIdentifierOnStack {
					Body: {
						block 
							if card(s_jobErrorMessageNumbers) then
								if not ep_errorWarningSelectedMessage then
									ep_errorWarningSelectedMessage := last( s_jobErrorMessageNumbers );
								endif ;
								if not ep_StackPos then
									ep_StackPos := first( s_stackPositions );
								endif ;
								if ep_errorWarningSelectedMessage and ep_StackPos then
									IdentifierShowAttributes(  
										ep_shownJobErrorNodes( ep_errorWarningSelectedMessage, ep_stackPos ));
								endif ;
							endif ;
						onerror ep_err do
							pr_appendError( ep_err );
							errh::MarkAsHandled( ep_err );
						endblock ;
					}
					ElementParameter ep_err {
						Range: errh::PendingErrors;
					}
				}
				Procedure pr_openIdentifierOnMessageList {
					Body: {
						block 
							if ep_errorWarningSelectedMessage and ep_shownJobErrorNodes( ep_errorWarningSelectedMessage, 1 ) then
								IdentifierShowAttributes(  
									ep_shownJobErrorNodes( ep_errorWarningSelectedMessage, ep_stackPos ));
							endif ;
						onerror ep_err do
							pr_appendError( ep_err );
							errh::MarkAsHandled( ep_err );
						endblock ;
					}
					ElementParameter ep_err {
						Range: errh::PendingErrors;
					}
				}
				Procedure pr_initErrorHandlingDownloadUploadButtons {
					Arguments: (ep_stat,statusCode,statusDescription,bp_download);
					Body: {
						ep_stat := '';
						statusCode := if bp_download then webui::ReturnStatusCode('CREATED') else webui::ReturnStatusCode('OK') endif ;
						statusDescription := "Nice.";
						
						! Best practice: declare ep_stat inside the calling procedure.
					}
					ElementParameter ep_stat {
						Range: errh::AllErrorSeverities;
						Property: Output;
					}
					Parameter statusCode {
						Property: Output;
					}
					StringParameter statusDescription {
						Property: Output;
					}
					Parameter bp_download {
						Property: Optional;
					}
				}
				Procedure pr_uploadDownloadWidgetErrorHandling {
					Arguments: (ep_err, ep_stat, statusCode, statusDescription);
					Body: {
						! Ensure that the single message shown to the user is the first error, and if there is none: the first warning.
						if errh::Severity(ep_err) = 'warning' then
							if ep_stat = '' then
								statusDescription := "OK, but note: " + errh::Message( ep_err );
								ep_stat := 'warning';
							endif ;
						else
							statusCode := webui::ReturnStatusCode('ERROR');
							if ep_stat <> 'error' then
								statusDescription := "Better luck next time: " + errh::Message( ep_err );
								ep_stat := 'error';
							endif;
						endif ;
						
						! Best practice: declare ep_err and ep_stat inside the calling procedure.
					}
					ElementParameter ep_err {
						Range: errh::PendingErrors;
						Property: Input;
					}
					ElementParameter ep_stat {
						Range: errh::AllErrorSeverities;
						Property: InOut;
					}
					Parameter statusCode {
						Property: InOut;
					}
					StringParameter statusDescription {
						Property: InOut;
					}
				}
				Procedure pr_appendError {
					Arguments: (ep_err,sp_prefix);
					Body: {
						ep_logLev := if errh::Severity(ep_err) = 'warning' then 'warn' else 'error' endif;
						pr_logMsg( errh::Message(ep_err), ep_logLev );
						if pro::GetPROEndPoint() then
							if pro::IsRunningAtServer() then
								pr_appendErrorJob(ep_err,sp_prefix);
							else
								pr_appendErrorDataSession(ep_err,sp_prefix);
							endif ;
						else
							pr_appendErrorDataSession(ep_err,sp_prefix);
						endif ;
					}
					Comment: "Store the error in the data structures of the library.";
					ElementParameter ep_err {
						Range: errh::PendingErrors;
						Property: Input;
					}
					Parameter p_errStackHeight;
					Parameter p_errStackPos;
					ElementParameter ep_stackPosition {
						Range: s_stackPositions;
					}
					ElementParameter ep_jobErrorMessageNumber {
						Range: s_jobErrorMessageNumbers;
					}
					StringParameter sp_prefix {
						Property: Optional;
					}
					StringParameter sp_msg;
					ElementParameter ep_logLev {
						Range: s_messageLevels;
					}
					DeclarationSection gss_logging_declarations {
						StringParameter sp_gssTime;
						Parameter p_gssMiU;
					}
				}
				Procedure pr_appendMessage {
					Arguments: (sp_msg,ep_lev);
					Body: {
						if pro::GetPROEndPoint() then
							if pro::IsRunningAtServer() then
								pr_appendMessageJob(sp_msg,ep_lev);
							else
								pr_appendMessageDataSession(sp_msg,ep_lev);
							endif ;
						else
							pr_appendMessageDataSession(sp_msg,ep_lev);
						endif ;
					}
					Comment: "Store the error in the data structures of the library.";
					Parameter p_errStackHeight;
					Parameter p_errStackPos;
					ElementParameter ep_stackPosition {
						Range: s_stackPositions;
					}
					ElementParameter ep_jobErrorMessageNumber {
						Range: s_jobErrorMessageNumbers;
					}
					StringParameter sp_msg {
						Property: Input;
					}
					ElementParameter ep_lev {
						Range: s_messageLevels;
						Default: 'info';
						Property: Optional;
					}
				}
				Procedure pr_globalErrorHandler {
					Arguments: (ep_err);
					Body: {
						pr_appendError(ep_err );
						
						if bp_locSeenErrorsAreHandled then
							errh::MarkAsHandled( ep_err );
						endif ;
					}
					ElementParameter ep_err {
						Range: errh::PendingErrors;
						Property: Input;
					}
					ElementParameter ep_jobErrorMessageNumber {
						Range: s_jobErrorMessageNumbers;
					}
					Parameter p_errStackHeight;
					Parameter p_errStackPos;
					ElementParameter ep_stackPosition {
						Range: s_stackPositions;
					}
				}
				Procedure pr_seenErrorsAreHandled {
					Arguments: (bp_areHandled);
					Body: {
						bp_locSeenErrorsAreHandled := bp_areHandled ;
					}
					Parameter bp_areHandled {
						Range: binary;
						Default: 1;
						Property: Input;
					}
				}
			}
		}
		Section Inspect_state_session {
			Procedure pr_saveState {
				Arguments: (sp_label,s_selectedIdentifiers);
				Body: {
					
					Block ! Determine the subset of identifiers that actually have data to be written to file.
						s_selectedIdentifiersWithData := { i_someId |
							( i_someId in AllSets ) or
							( i_someId in AllParameters ) or
							( i_someId in AllVariables ) or
							( i_someId in AllConstraints ) };
						if not card( s_selectedIdentifiersWithData ) then
							raise warning "No data output from gss::SaveState, as no identifier contains data" ;
							return 0;
						endif ;
					endblock ;
					
					Block ! Materials will be written first to a subfolder of the project folder.  Ensure this intermediate folder exists.
						if  not directoryExists( sp_label ) then
							directoryCreate( sp_label );
						endif ;
					endblock ;
					
					block ! Ensure PRO is connected, initialized, and the PRO Storage folder exists that will contain all text output files
						if pro::GetPROEndPoint() then
							pro::Initialize();
							sp_slash := "/" ;
							sp_proStorageFolderName := "/Userdata/" + 
								pro::GetPROEnvironment() + sp_slash + 
								pro::GetPROUserName()    + sp_slash + 
								pro::ModelName           + sp_slash + 
								pro::modelversion        + sp_slash + 
								sp_label ;
							pr_ensurePath( sp_proStorageFolderName );
						endif ;
					endblock ;
					
					block ! Each data identifier to be written to file is written to a separate file.
						where single_column_display := 1, listing_number_precision := 12, listing_number_width := 20 ;
						for i_someIdWithData do
							s_singleTonSet := {};
							s_singleTonSet += i_someIdWithData ;
							sp_filename := spfnc_fileFriendlyName( i_someIdWithData );
							sp_fullFilename := sp_label + "\\" + sp_filename;
							write s_singleTonSet to file sp_fullFilename ;
							if pro::GetPROEndPoint() then
								sp_proStorageFileName := sp_proStorageFolderName + sp_slash + sp_filename ;
								pro::SaveFileToCentralStorage(
									localPath     :  sp_fullFilename, 
									storagePath   :  sp_proStorageFileName);
							endif ;
						endfor ;
					endblock ;
				}
				StringParameter sp_proStorageFolderName;
				StringParameter sp_proStorageFileName;
				StringParameter sp_slash;
				Set s_selectedIdentifiers {
					SubsetOf: AllSymbols;
					Index: i_someId;
					Property: Input;
				}
				Set s_selectedIdentifiersWithData {
					SubsetOf: AllIdentifiers;
					Index: i_someIdWithData;
				}
				Set s_singleTonSet {
					SubsetOf: AllIdentifiers;
				}
				StringParameter sp_label {
					Property: Input;
				}
				StringParameter sp_filename;
				StringParameter sp_fullFilename;
			}
		}
		Section Logging {
			Property: NoSave;
			StringParameter sp_traceFilename {
				InitialData: "logging.txt";
			}
			StringParameter sp_downloadActionLogTitle {
				Definition: formatString("Download model log file of shown session %e", gss::ep_shownSession);
			}
			Procedure pr_openPageErrorWarningProfiler {
				Body: {
					pr_enter(sp_gssTime, p_gssMiU, ep_logLev: 'info');
					ep_shownSession := first( s_trackedSessions );
					
					ProfilerCollectAllData(
						ProfilerData       :  p_dataSessionProfilerData, 
						GrossTimeThreshold :  0, 
						NetTimeThreshold   :  0);
					
					p_trackedJobProfilerData(ep_shownSession, IndexIdentifiers, i_lineNumber, IndexProfilerTypes) := p_dataSessionProfilerData(IndexIdentifiers, i_lineNumber, IndexProfilerTypes);
					sp_trackedJobErrorMessages(ep_shownSession, i_jobErrorMessageNumber) := sp_dataSessionErrorMessages(i_jobErrorMessageNumber);
					sp_trackedJobErrorMoments(ep_shownSession, i_jobErrorMessageNumber) := sp_dataSessionErrorMoments(i_jobErrorMessageNumber);
					ep_trackedJobErrorSeverity(ep_shownSession, i_jobErrorMessageNumber) := ep_dataSessionErrorSeverity(i_jobErrorMessageNumber);
					ep_trackedJobErrorNodes(ep_shownSession, i_jobErrorMessageNumber, i_stackPosition) := ep_dataSessionErrorNodes(i_jobErrorMessageNumber, i_stackPosition);
					ep_trackedJobErrorAttributes(ep_shownSession, i_jobErrorMessageNumber, i_stackPosition) := ep_dataSessionErrorAttributes(i_jobErrorMessageNumber, i_stackPosition);
					p_trackedJobErrorLines(ep_shownSession, i_jobErrorMessageNumber, i_stackPosition) := p_dataSessionErrorLines(i_jobErrorMessageNumber, i_stackPosition);
					
					pr_uponChangeShownSession();
					pr_leave(sp_gssTime, p_gssMiU, ep_logLev: 'info');
				}
				Comment: "The procedure that is run upon opening the page \"GSS page\"";
				DeclarationSection gss_logging_declarations {
					StringParameter sp_gssTime;
					Parameter p_gssMiU;
				}
				DeclarationSection error_reference_declaration {
					ElementParameter ep_err {
						Range: errh::PendingErrors;
					}
				}
			}
			Procedure pr_logMsgTraceFile {
				Arguments: (sp_argMsg,ep_lev);
				Body: {
					if ep_lev >= ep_tracingFilterlevel then
						put f_traceFile ;
						put sp_argMsg, / ;
						putclose ;
					endif ;
					!
				}
				Comment: {
					"Trace to the log file; this procedure should not be called before PostLibraryInitialization finished."
				}
				StringParameter sp_argMsg {
					Property: Input;
				}
				ElementParameter ep_lev {
					Range: s_messageLevels;
					Default: 'trace';
					Property: Optional;
				}
			}
			Procedure pr_logMsg {
				Arguments: (sp_message,ep_messageImportance);
				Body: {
					if ep_messageImportance >= ep_tracingFilterlevel then
						pr_logMsgTraceFile(sp_message,ep_messageImportance);
					endif ;
				}
				Comment: {
					"Trace to the log file; this procedure should not be called before PostLibraryInitialization finished."
				}
				StringParameter sp_message {
					Property: Input;
				}
				ElementParameter ep_messageImportance {
					Range: s_messageLevels;
					Default: 'trace';
					Property: Optional;
				}
			}
			Procedure pr_enter {
				Arguments: (sp_procEnterTimestamp,p_procEnterMemoryInUse,ep_logLev,sp_procEnterContextMessage);
				Body: {
					sp_procEnterTimestamp := CurrentToString("%c%y-%m-%d %H:%M:%S:%t%TZ('UTC')");
					p_procEnterMemoryInUse := MemoryInUse();
					sp_node := formatString("%e",CallerNode(1));
					sp_fullMsg := formatString("Enter %s(%s) at %s [%.3n Mb] in use", 
						sp_node, sp_procEnterContextMessage, 
						MomentToString(
							Format        :  "%c%y-%m-%d %H:%M:%S:%t%TZ(gss::ep_traceTimezone)", 
							unit          :  [s], 
							ReferenceDate :  sp_procEnterTimestamp, 
							Elapsed       :  0[s]), 
						p_procEnterMemoryInUse );
					pr_logMsg( sp_fullMsg, ep_logLev );
				}
				Comment: {
					"Trace entry of procedure to the log file; this procedure should not be called before PostLibraryInitialization finished."
				}
				StringParameter sp_procEnterTimestamp {
					Property: Output;
				}
				Parameter p_procEnterMemoryInUse {
					Property: Output;
				}
				StringParameter sp_procEnterContextMessage {
					Property: Optional;
					Comment: {
						"If the traced procedure contains arguments, 
						you may want to summarize these arguments here."
					}
				}
				StringParameter sp_node;
				StringParameter sp_fullMsg;
				StringParameter sp_proc;
				ElementParameter ep_logLev {
					Range: s_messageLevels;
					Default: 'debug';
					Property: Optional;
				}
			}
			Procedure pr_leave {
				Arguments: (sp_procEnterTimestamp,p_procEnterMemoryInUse,ep_logLev,sp_msg);
				Body: {
					sp_leavingTime := CurrentToString("%c%y-%m-%d %H:%M:%S:%t%TZ('UTC')");
					p_duration := StringToMoment(
						Format        :  "%c%y-%m-%d %H:%M:%S:%t%TZ('UTC')", 
						Unit          :  [s], 
						ReferenceDate :  sp_procEnterTimestamp, 
						Timeslot      :  sp_leavingTime);
					sp_node := formatString("%e",CallerNode(1));
					p_leaveMemoryInUse := MemoryInUse();
					sp_fullMsg := 
						formatString( "Leave %s(%s) at %s [%.3n Mb] in use. ",
							sp_node, sp_msg, 
							MomentToString(
								Format        :  "%c%y-%m-%d %H:%M:%S:%t%TZ(gss::ep_traceTimezone)", 
								unit          :  [s], 
								ReferenceDate :  sp_leavingTime, 
								Elapsed       :  0[s]), 
							p_leaveMemoryInUse ) +
						formatString( "Duration is %.3n [seconds] and memory %s is %n Mb.", 
							p_duration,
							if p_leaveMemoryInUse >= p_procEnterMemoryInUse then "increase" else "decrease" endif, 
							abs( p_leaveMemoryInUse - p_procEnterMemoryInUse ) );
					pr_logMsg( sp_fullMsg, ep_logLev );
				}
				Comment: {
					"Trace leaving of procedure to the log file; this procedure should not be called before PostLibraryInitialization finished."
				}
				Parameter p_procEnterMemoryInUse {
					Property: Input;
				}
				StringParameter sp_procEnterTimestamp {
					Property: Input;
				}
				StringParameter sp_leavingTime;
				Parameter p_duration {
					Unit: s;
				}
				Parameter p_leaveMemoryInUse;
				StringParameter sp_msg {
					Property: Optional;
				}
				StringParameter sp_node;
				StringParameter sp_fullMsg;
				ElementParameter ep_logLev {
					Range: s_messageLevels;
					Default: 'debug';
					Property: Optional;
				}
			}
			Procedure pr_saveActionLogFile {
				Body: {
					if pro::GetPROEndPoint() then
						sp_slash := "/" ;
						sp_proStorageFolderName := sp_slash + "Userdata" + sp_slash + 
							pro::GetPROEnvironment() + sp_slash + 
							pro::GetPROUserName()    + sp_slash + 
							pro::ModelName           + sp_slash + 
							pro::modelversion        ;
						pr_ensurePath( sp_proStorageFolderName );
					
						pr_actuallySaveActionLogFile( sp_traceFilename, sp_proStorageFolderName );
					endif ;
				}
				Comment: "Save the log file in AIMMS PRO storage.";
				StringParameter sp_proStorageFileName;
				StringParameter sp_proStorageFolderName;
				StringParameter sp_slash;
			}
			Procedure pr_setTracingLevel {
				Arguments: (ep_newLev);
				Body: {
					ep_tracingFilterlevel := ep_newLev;
				}
				Comment: "Filter all tracing messages with a level lower than the argument value.";
				ElementParameter ep_newLev {
					Range: s_messageLevels;
					Property: Input;
				}
			}
			Procedure pr_downloadActionLog {
				Arguments: (FileLocation,StatusCode,StatusDescription);
				Body: {
					Block
						!FileLocation := "circle.png";
						sp_slash := "/" ;
						if ep_shownSession <> first( s_trackedSessions ) then
							! The first tracked session is the data session.
							! The other session, are server sessions, and they are stored
							! in /Userdata/<env>/<user>/<model>/<ver>/tracings" + 
							sp_proStorageFilename := sp_slash + "Userdata" + sp_slash + 
								pro::GetPROEnvironment() + sp_slash + 
								pro::GetPROUserName()    + sp_slash + 
								pro::ModelName           + sp_slash + 
								pro::modelversion        + sp_slash + 
								"tracings"               + sp_slash + 
								ep_shownSession          + ".actionLog";
							sp_localTraceFilename := "tracings" + sp_slash + ep_shownSession + ".actionLog" ;
							! Copy the .actionLog file from AIMMS PRO storage to the folder "tracings".
							pro::RetrieveFileFromCentralStorage(
								storagePath :  sp_proStorageFilename, 
								localPath   :  sp_localTraceFilename);
						else
							sp_localTraceFilename := sp_traceFilename ;
						endif ;
						p_slashFwd := FindNthString( sp_localTraceFilename, "/", -1 );
						p_slashBwd := FindNthString( sp_localTraceFilename, "\\", -1 );
						p_slash := max( p_slashFwd, p_slashBwd);
						if p_slash then
							p_len := StringLength( sp_localTraceFilename );
							fileLocation := SubString( sp_localTraceFilename, p_slash+1, p_len); 
							FileCopy( sp_localTraceFilename, fileLocation );
						else
							fileLocation := sp_localTraceFilename;
						endif ;
						sp_fullFileLocation := webui::GetIOFilePath(FileLocation);
						if FileLocation <> sp_fullFileLocation then
							FileCopy( FileLocation, sp_fullFileLocation );
						endif ;
					
						StatusCode := webui::ReturnStatusCode('CREATED');
						StatusDescription := "Nice.";
					OnError ep_err Do
						if errh::Severity( ep_err ) <> 'warning' then
							StatusCode := webui::ReturnStatusCode('ERROR');
							StatusDescription := "Oops: " + errh::Message(ep_err) ;
							errh::MarkAsHandled(ep_err);
							break ; ! Trick to reporting one error.
						endif ;
					EndBlock ;
				}
				StringParameter sp_proStorageFilename;
				StringParameter sp_localTraceFilename;
				StringParameter FileLocation {
					Property: Output;
				}
				Parameter StatusCode {
					Property: Output;
				}
				StringParameter StatusDescription {
					Property: Output;
				}
				StringParameter sp_fullFileLocation;
				ElementParameter ep_err {
					Range: errh::PendingErrors;
				}
				Parameter p_slashFwd;
				Parameter p_slashBwd;
				Parameter p_slash;
				Parameter p_len;
				StringParameter sp_slash;
			}
		}
		Section Additional_utilities {
			Function fnc_hasPropertyNosave {
				Arguments: (ep_id);
				Body: {
					bp_retval := 0 ;
					while ep_id do
						if FindString( AttributeToString( ep_id, 'property'), "Nosave", caseSensitive:0 ) then
							bp_retval := 1;
							break ;
						else
							ep_id := me::Parent( ep_id );
						endif ;
					endwhile ;
					fnc_hasPropertyNosave := bp_retval ;
				}
				Comment: {
					"Doesn\'t work for deployed apps; the attributes are encrypted and cannot be queried just like that."
				}
				ElementParameter ep_id {
					Range: AllSymbols;
					Property: Input;
				}
				Parameter bp_retval;
			}
		}
	}
	Section Private_Section {
		Property: NoSave;
		Section WebUI_helpers {
			Parameter p_noSignificantMessages {
				Definition: p_noLogMessages + p_NoWarnings + p_NoErrors;
				Comment: "This is a helper in the status bar";
			}
			Parameter ep_lastHitLine {
				Definition: {
					last( i_positiveLineNumber | 
						p_jobProfilerData(ep_profilerDataSelectedIdentifier, 
						i_positiveLineNumber, 'hits'))
				}
				Comment: "To define the line numbers visible in the table LineBasedProfilerData";
			}
		}
		Section Main_Library_procedures {
			Procedure LibraryInitialization {
				Body: {
					ep_jobIncident := '' ;
					ep_dataSessionIncident := '' ;
				}
				Comment: "Add initialization statements here that do not require any other library being initialized already.";
			}
			Procedure PostLibraryInitialization {
				Body: {
					! The error data shown should not be modified in the User Interface.
					CurrentInputs -= serverSessionErrorData;
					CurrentInputs -= Shown_session_data_exchange ;
					
					pr_GetThisSession(); 
					
					block ! Initialize logging
						if pro::GetPROEndPoint() then
							pro::Initialize();
							if not pro::IsRunningAtServer() then
								ep_trackedSession := stringToElement( s_trackedSessions, sp_thisSession, create:1);
							endif ;
						else
							ep_trackedSession := stringToElement( s_trackedSessions, sp_thisSession, create:1);
						endif ;
					
						if sp_thisSession then
							sp_traceFilename := sp_tracingsFolderName + "/" + sp_thisSession + ".actionLog" ;
						endif ;
					
						if not  DirectoryExists( sp_tracingsFolderName ) then
							DirectoryCreate( sp_tracingsFolderName );
						endif ;
						if fileExists( sp_traceFilename ) then
							FileDelete( sp_traceFilename );
						endif ;
					endblock ;
					
					! Open log file for data session or AIMMS Developer session.
					if pro::GetPROEndPoint() then
						if pro::openedAsWorker then
							! pr_openLogFile();
							! The log file for a server session is opened at the beginning of pr_guardAndProfileServerJob().
						else
							pr_openLogFile();
						endif ;
					else
						pr_openLogFile();
					endif ;
					
					block ! Ensure option "Use UTC forcaseandstartenddate" is turned on.
						bp_ogv := OptionGetValue("Use UTC forcaseandstartenddate", 
							p_optLow, p_optCur, p_optDef, p_optUpp );
						if not bp_ogv then
							raise error "my bad" ;
						endif ;
						if p_optCur <> 1 then raise warning 
							"The option \"Use UTC forcaseandstartenddate\" should be turned on"+
							" for correct logging of time in the library GuardServerSession." ;
						endif ;
					endblock ;
					! log file of a week old are to be deleted
				}
				Comment: {
					"Add initialization statements here that require another library to be initialized already,
					or add statements that require the Data Management module to be initialized."
				}
				ElementParameter ep_trackedSession {
					Range: s_trackedSessions;
				}
				Parameter bp_ogv {
					Range: binary;
				}
				Parameter p_optLow;
				Parameter p_optCur;
				Parameter p_optDef;
				Parameter p_optUpp;
			}
			Procedure PreLibraryTermination {
				Body: {
					
					return 1;
				}
				Comment: {
					"Add termination statements here that require all other libraries to be still alive.
					Return 1 if you allow the termination sequence to continue.
					Return 0 if you want to cancel the termination sequence."
				}
			}
			Procedure LibraryTermination {
				Body: {
					return 1;
				}
				Comment: {
					"Add termination statements here that do not require other libraries to be still alive.
					Return 1 to allow the termination sequence to continue.
					Return 0 if you want to cancel the termination sequence.
					It is recommended to only use the procedure PreLibraryTermination to cancel the termination sequence and let this procedure always return 1."
				}
			}
		}
		Section Guard_utilities {
			Parameter bp_locSeenErrorsAreHandled {
				Range: binary;
				InitialData: 0;
			}
			Index i_errorSeverity {
				Range: errh::AllErrorSeverities;
			}
			ElementParameter ep_errorToMessageLevelMap {
				IndexDomain: i_errorSeverity;
				Range: s_messageLevels;
				Definition: data { 'severe' : 'fatal', 'error' : 'error', 'warning' : 'warn' };
			}
			ElementParameter ep_jobIncident {
				Range: s_jobErrorMessageNumbers;
			}
			Procedure pr_reportCurrentErrorsToTextFile {
				Arguments: (sp_filename);
				Body: {
					block where listing_page_width := 32000 ;
						f_out.pagewidth := 32000 ;
						put f_out;
						for i_jobErrorMessageNumber | sp_shownJobErrorMessages(i_jobErrorMessageNumber) do
							put     ep_shownJobErrorSeverity(i_jobErrorMessageNumber), " ", 
								sp_shownJobErrorMoments( i_jobErrorMessageNumber), " : ",
								sp_shownJobErrorMessages(i_jobErrorMessageNumber), / ;
							for i_stackPosition | p_shownJobErrorLines(i_jobErrorMessageNumber, i_stackPosition) do
								put "    ", p_shownJobErrorLines(i_jobErrorMessageNumber, i_stackPosition):4:0, 
								" : ", ep_shownJobErrorNodes(i_jobErrorMessageNumber, i_stackPosition):0, / ;
							endfor ;
							put / ;
						endfor ;
						putclose ;
					endblock ;
				}
				Comment: {
					"Helper procedure of pr_downloadErrorReport; this will actually fill the put file."
				}
				StringParameter sp_filename {
					Property: Input;
				}
				File f_out {
					Name: sp_filename;
					Device: Disk;
					Mode: replace;
				}
			}
			Procedure pr_sampleProc {
				Body: {
					! Do not delete this procedure, it is used as default of element parameter gss::ep_Work.
				}
			}
			Procedure pr_newIncidentDataSession {
				Body: {
					if ep_dataSessionIncident then
						if ep_dataSessionIncident = last( s_jobErrorMessageNumbers ) then
							p_maxNoErrorsPerSession *= 2 ;		
						endif ;
						ep_dataSessionIncident += 1 ;
					else
						ep_dataSessionIncident := first( s_jobErrorMessageNumbers );
					endif;
				}
				Comment: "Get error possition for a new incident in a data session.";
			}
			Procedure pr_newIncidentJob {
				Body: {
					if ep_jobIncident then
						if ep_jobIncident = last( s_jobErrorMessageNumbers ) then
							p_maxNoErrorsPerSession *= 2 ;		
						endif ;
						ep_jobIncident += 1 ;
					else
						ep_jobIncident := first( s_jobErrorMessageNumbers );
					endif;
				}
				Comment: "Get error possition for a new incident in a solver session (job).";
			}
		}
		Section Inspect_utilities {
			Procedure pr_ensurePath {
				Arguments: (sp_path);
				Body: {
					if not pr_proFolderExists( sp_path ) then
					        pro::CreateStorageFolder( sp_path );
					endif ;
				}
				StringParameter sp_path {
					Property: Input;
				}
			}
			Function spfnc_fileFriendlyName {
				Arguments: (ep_id);
				Range: string;
				Body: {
					sp_retVal := formatString("%e", ep_id );
					sp_retVal := FindReplaceStrings( sp_retVal, ":", "_" );
					
					spfnc_fileFriendlyName := sp_retVal ;
				}
				Comment: "Replace : chars with _ chars to obtain name that is a valid file name.";
				ElementParameter ep_id {
					Range: AllIdentifiers;
					Property: Input;
				}
				StringParameter sp_retVal;
			}
			Procedure pr_proFolderExists {
				Arguments: (sp_filepath);
				Body: {
					! proFolderExists, proDirectoryExists, FolderExists, DirectoryExists
					pro::NormalizeStoragePath(sp_filepath);
					p_ret := pro::storage::ListBuckets(
								path       :  sp_filepath, 
								BucketSet  :  s_locBucketSet, 
								BucketSize :  p_locBucketSize, 
								BucketAuth :  sp_locBucketAuth, 
								BucketDate :  sp_locBucketDate);
					return p_ret ;
				}
				StringParameter sp_filepath {
					Property: Input;
				}
				Parameter p_ret;
				Set s_locBucketSet {
					Index: bs;
				}
				Parameter p_locBucketSize {
					IndexDomain: bs;
				}
				StringParameter sp_locBucketAuth {
					IndexDomain: bs;
				}
				StringParameter sp_locBucketDate {
					IndexDomain: bs;
				}
			}
			Procedure pr_proFileExists {
				Arguments: (sp_filename);
				Body: {
					pro::NormalizeStoragePath(sp_filename);
					pro::SplitStoragePath(sp_filename,sp_storageBucketPath,sp_storageFileWithoutPath);
					if not pr_proFolderExists( sp_storageBucketPath ) then return 0 ; endif ;
					p_ret := pro::storage::GetObjectInfo(sp_storageBucketPath, sp_storageFileWithoutPath,
							sp_tmpLocalFileName, sp_tmpType, p_tmpNum, sp_tmpAuth, p_tmpVersion );
					if p_ret = 0 or p_tmpNum <= 0 then
						return 0 ;
					endif ;
					return 1 ;
				}
				Comment: {
					"d:\\u\\s\\aimms3\\deps\\vc120_x64_Debug\\Libraries\\AimmsWebUI\\AimmsWebUI.ams line 1600
					d:\\u\\s\\Customers\\K3 Delta\\Escalation March 2017\\6763\\UploadTool\\UploadTool\\UploadTool\\FileExistsFolderExists.ams line 40"
				}
				StringParameter sp_filename {
					Property: Input;
				}
				Parameter p_ret;
				StringParameter sp_storageBucketPath;
				StringParameter sp_storageFileWithoutPath;
				Parameter p_tmpNum;
				StringParameter sp_tmpLocalFileName;
				StringParameter sp_tmpType;
				StringParameter sp_tmpAuth;
				Parameter p_tmpVersion;
			}
			Function fnc_hasProPrefix {
				Arguments: (sp_filename);
				Range: binary;
				Body: {
					p_retval := 0 ;
					
					if Stringlength( sp_filename ) > 4 then
						if findstring( substring( sp_filename, 1, 4 ), "pro:", CaseSensitive:0 ) then
							p_retval := 1 ;
						else
							p_retval := 0 ;
						endif ;
					else
						p_retval := 0 ;
					endif ;
					
					fnc_hasProPrefix := p_retval ;
				}
				StringParameter sp_filename {
					Property: Input;
				}
				Parameter p_retval {
					Range: binary;
				}
			}
		}
		Section Logging_utilities {
			Procedure pr_openLogFile {
				Body: {
					f_traceFile.pagewidth := 32000 ;
					putclose f_traceFile ;
					put f_traceFile;
					put "Opening log file ", sp_traceFilename, " at ", CurrentToSTring("%c%y-%m-%d %H:%M:%S"), / ;
					if pro::GetPROEndPoint() then
						if pro::openedAsWorker then
							put "This file contains the log of a solver session handling request ", 
								pro::workerRequestDescription, / ;
						else
							put "This file contains the log of a data session on behalf of ", 
								pro::GetPROUserName(), "@", pro::GetPROEnvironment(), / ;
						endif ;
					else
						put "This file contains the log of an AIMMS Developer session ", / ;
					endif ;
					putclose ;
				}
				Comment: "Open log file and add identifying first few lines.";
			}
			Procedure pr_GetThisSession {
				Body: {
					if pro::GetPROEndPoint() then
						if pro::ReadArguments('_pro-webui-session-id') then
							sp_thisSession := pro::ReadArguments('_pro-webui-session-id');
					
						else
							sp_thisSession := pro::ReadArguments('_pro-session-id');
						endif ;
						pro::management::LocalLogInfo(formatString(
							"pr_GetThisSession(): sp_thisSession = %s", sp_thisSession ));
					else
						sp_thisSession := CurrentToString("%c%y%m%dT%H%M%S%t%TZ('UTC')");
					endif ;
				}
				Comment: {
					"Get the unique identifier of this session. 
					Whenever possible, align with AIMMS PRO - to make matching with AIMMS PRO generated logging information easier.
					When not on PRO, use timestamp."
				}
			}
			Procedure pr_actuallySaveActionLogFile {
				Arguments: (sp_fn,sp_folder);
				Body: {
					sp_slash := "/" ;
					if fileExists( sp_fn ) then
						sp_proStorageFileName := sp_folder + sp_slash + sp_fn ;
						pro::SaveFileToCentralStorage(
							localPath     :  sp_fn, 
							storagePath   :  sp_proStorageFileName);
						pro::management::LocalLogInfo(formatString(
							"pr_actuallySaveActionLogFile(): pro::SaveFileToCentralStorage(%s,%s)",
							sp_fn, sp_proStorageFileName));
					else
						pro::management::LocalLogInfo(
							"pr_actuallySaveActionLogFile() sp_fn = " + 
							sp_fn + 
							" does not exist."
						);
					endif ;
				}
				Comment: "Helper procedure of pr_saveActionLogFile.";
				StringParameter sp_fn {
					Property: Input;
				}
				StringParameter sp_folder {
					Property: Input;
				}
				StringParameter sp_slash;
				StringParameter sp_proStorageFileName;
			}
			Procedure pr_artificialDataGSSPage {
				Body: {
					pr_enter(sp_gssTime, p_gssMiU, ep_logLev: 'info');
					block
						raise warning "Cry wolf" ;
					onerror ep_err do
						gss::pr_appendError(ep_err);
						errh::MarkAsHandled(ep_err);
					endblock ;
					pr_leave(sp_gssTime, p_gssMiU, ep_logLev: 'info');
				}
				Comment: {
					"Run this procedure to obtain some contents with which to tailor the 
					table ErrorWarningMessageTable and JobProfilerData"
				}
				ElementParameter ep_err {
					Range: errh::PendingErrors;
				}
				DeclarationSection gss_logging_declarations {
					StringParameter sp_gssTime;
					Parameter p_gssMiU;
				}
			}
			StringParameter sp_tracingsFolderName {
				Definition: "tracings";
				Comment: "Logging is first written to a subfolder of the project folder.";
			}
			StringParameter sp_thisSession {
				InitialData: "this-session";
				Comment: "the unique code for this session.";
			}
			File f_traceFile {
				Name: sp_traceFilename;
				Device: Disk;
				Mode: merge;
			}
			ElementParameter ep_traceTimezone {
				Range: AllTimeZones;
				InitialData: {
					!'local'
					'LocalDST'
					! 'UTC'
				}
				Comment: {
					"Tracing time zone.
					See ticket 11"
				}
			}
		}
	}
}
