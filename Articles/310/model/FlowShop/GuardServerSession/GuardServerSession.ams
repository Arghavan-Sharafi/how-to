## ams_version=1.0

LibraryModule Library_GuardServerSession {
	Prefix: gss;
	Interface: Public_Section;
	Comment: {
		"Requirements:
		- Declaration of time, preferably as SI_Time_Duration, including unit s.
		- System library AIMMS PRO
		- Repository library DataExchange
		- AIMMS 4.76 or later
		
		Test WebUI and WinUI apps in Cloud/Prem/Developer"
	}
	Section Public_Section {
		Section WebUI_Support {
			Property: NoSave;
			StringParameter sp_widgetActionMessageStack {
				IndexDomain: (webui::indexPageExtension, webui::indexWidgetActionSpec);
				Definition: {
					{
						('1', 'displaytext' ) : "Model explorer",  
						('1', 'icon'        ) : "aimms-glasses",  
						('1', 'procedure'   ) : "gss::pr_OpenIdentifierOnStack",  
						('1', 'state'       ) : "Active"  
					}
				}
			}
			StringParameter sp_widgetActionMessageList {
				IndexDomain: (webui::indexPageExtension, webui::indexWidgetActionSpec);
				Definition: {
					{
						('1', 'displaytext' ) : "Model explorer",  
						('1', 'icon'        ) : "aimms-glasses",  
						('1', 'procedure'   ) : "gss::pr_OpenIdentifierOnMessageList",  
						('1', 'state'       ) : "Active"  
					}
				}
			}
			StringParameter sp_widgetActionIdentifierProfiler {
				IndexDomain: (webui::indexPageExtension, webui::indexWidgetActionSpec);
				Definition: {
					{
						('1', 'displaytext' ) : "Model explorer",  
						('1', 'icon'        ) : "aimms-glasses",  
						('1', 'procedure'   ) : "gss::pr_OpenProfiledIdentifier",  
						('1', 'state'       ) : "Active"  
					}
				}
			}
			StringParameter sp_SidePanelErrorPage {
				IndexDomain: (webui::indexApplicationExtension,webui::indexSidePanelSpec);
				Definition: {
					{
						( '1', 'displayText' ) : if p_noSignificantMessages then FormatString("%i msgs", p_noSignificantMessages ) else "" endif,
						( '1', 'pageId'      ) : if p_noSignificantMessages then "errorpanel_1"                                    else "" endif,
						( '1', 'tooltip'     ) : if p_noSignificantMessages then "Error handling"                                  else "" endif,  
						( '1', 'state'       ) : if p_noSignificantMessages then "Active"                                          else "" endif 
					}
				}
			}
			StringParameter sp_messageStatusBar {
				IndexDomain: (webui::indexApplicationExtension,webui::indexStatusBarSpec);
				Definition: {
					{
						('1', 'header'   ): "Messages",
						('1', 'icon'     ): "aimms-power", 
						('1', 'color'    ): "", 
						('1', 'text'     ): 
							FormatString("%i messages, %i warnings, and %i errors",
								p_noLogMessages, p_noWarnings, p_noErrors), 
						('1', 'tooltip'  ): "", 
						('1', 'procedure'): "", 
						('1', 'state'    ): if card(s_jobErrorMessageNumbers) then "Active" else "Hidden" endif 
					}
				}
			}
			StringParameter sp_errorWarningMessageMenu {
				IndexDomain: (webui::indexPageExtension, webui::indexWidgetActionSpec);
			}
			StringParameter sp_titleProfilerDetail {
				Definition: FormatString("Profiler data for %e", ep_profilerDataSelectedIdentifier);
			}
			StringParameter sp_titleStackMessage {
				Definition: FormatString("Stack of \"%s\"", sp_jobErrorMessages( ep_errorWarningSelectedMessage ) );
			}
			ElementParameter ep_profilerDataSelectedIdentifier {
				Range: AllIdentifiers;
				InitialData: '';
			}
			ElementParameter ep_errorWarningSelectedMessage {
				Range: s_jobErrorMessageNumbers;
				InitialData: '';
			}
			ElementParameter ep_stackPos {
				Range: s_stackPositions;
				InitialData: '';
			}
			Parameter p_noSignificantMessages {
				Definition: p_noLogMessages + p_NoWarnings + p_NoErrors;
			}
			Parameter p_noLogMessages {
				InitialData: 0;
			}
			Parameter p_noWarnings {
				InitialData: 0;
			}
			Parameter p_noErrors {
				InitialData: 0;
			}
			Set s_messageLevels {
				Index: i_messageLevel;
				Definition: {
					data { trace, debug, info, warn, error, fatal } ;
				}
			}
			Set s_lineNumbers {
				SubsetOf: Integers;
				Index: i_lineNumber;
				Definition: ElementRange(0,1000);
			}
			Set s_positiveLineNumbers {
				SubsetOf: s_lineNumbers;
				Index: i_positiveLineNumber;
				Definition: ElementRange(1,1000);
			}
			Set s_actualLinenumbers {
				SubsetOf: s_lineNumbers;
				Index: i_actualLineNumber;
				Definition: ElementRange(1,if ep_lastHitLine then ep_lastHitLine else 1 endif);
			}
			Parameter ep_lastHitLine {
				Definition: {
					last( i_positiveLineNumber | 
						p_jobProfilerData(ep_profilerDataSelectedIdentifier, 
						i_positiveLineNumber, 'hits'))
				}
			}
			Set s_stackPositions {
				SubsetOf: Integers;
				Index: i_stackPosition;
				Definition: ElementRange(1,255);
			}
			Parameter bp_uploadErrorDataVisible {
				Range: binary;
				Definition: ProjectDeveloperMode;
			}
		}
		Section Guard_session {
			DeclarationSection serverSessionProfilerErrorData {
				Parameter p_jobProfilerData {
					IndexDomain: (IndexIdentifiers,i_lineNumber,IndexProfilerTypes );
				}
				Set s_jobErrorMessageNumbers {
					SubsetOf: Integers;
					Index: i_jobErrorMessageNumber;
				}
				StringParameter sp_jobErrorMessages {
					IndexDomain: i_jobErrorMessageNumber;
				}
				StringParameter sp_jobErrorMoments {
					IndexDomain: i_jobErrorMessageNumber;
				}
				ElementParameter ep_jobErrorSeverity {
					IndexDomain: i_jobErrorMessageNumber;
					Range: s_messageLevels;
				}
				ElementParameter ep_jobErrorNodes {
					IndexDomain: (i_jobErrorMessageNumber,i_stackPosition);
					Range: AllSymbols;
				}
				ElementParameter ep_jobErrorAttributes {
					IndexDomain: (i_jobErrorMessageNumber,i_stackPosition);
					Range: AllAttributeNames;
				}
				Parameter p_jobErrorLines {
					IndexDomain: (i_jobErrorMessageNumber,i_stackPosition);
				}
			}
			Procedure pr_guardAndProfileServerJob {
				Arguments: (ep_work);
				Body: {
					block
						empty s_jobErrorMessageNumbers ;
					
						! Ensure that the error recorded and profiler data are transmitted via the output case:
						pro::ManagedSessionOutputCaseIdentifierSet += ServerSessionProfilerErrorData ;
					
						! Actual work.
						apply( ep_work);
					
						! Ensure that the definitions of all defined sets and defined parameters in 
						! output case identifier set are profiled.
						update pro::ManagedSessionOutputCaseIdentifierSet;
					
					onerror ep_err do
					
						pr_appendError( ep_err );
					
						! Don't let the server job be halted by this error; 
						! we still want the result case including the profiled data.
						errh::MarkAsHandled(ep_err);
					
					endblock ;
					ProfilerCollectAllData(
						ProfilerData       :  p_jobProfilerData, 
						GrossTimeThreshold :  0, 
						NetTimeThreshold   :  0);
				}
				ElementParameter ep_err {
					Range: errh::PendingErrors;
				}
				ElementParameter ep_work {
					Range: AllProcedures;
					Default: 'gss::pr_sampleProc';
					Property: Input;
				}
			}
			Procedure pr_clearErrors {
				Body: {
					empty s_jobErrorMessageNumbers;
					p_noLogMessages := 0 ;
					p_noWarnings := 0 ;
					p_noErrors := 0 ;
				}
			}
			Procedure pr_reportCurrentErrorsToTextFile {
				Arguments: (sp_filename);
				Body: {
					block where listing_page_width := 32000 ;
						f_out.pagewidth := 32000 ;
						put f_out;
						for i_jobErrorMessageNumber do
							put     ep_jobErrorSeverity(i_jobErrorMessageNumber), " ", 
								sp_jobErrorMoments( i_jobErrorMessageNumber), " : ",
								sp_jobErrorMessages(i_jobErrorMessageNumber), / ;
							for i_stackPosition | p_jobErrorLines(i_jobErrorMessageNumber, i_stackPosition) do
								put "    ", p_jobErrorLines(i_jobErrorMessageNumber, i_stackPosition):4:0, 
								" : ", ep_jobErrorNodes(i_jobErrorMessageNumber, i_stackPosition):0, / ;
							endfor ;
							put / ;
						endfor ;
						putclose ;
					endblock ;
				}
				StringParameter sp_filename {
					Property: Input;
				}
				File f_out {
					Name: sp_filename;
					Device: Disk;
					Mode: replace;
				}
			}
			Procedure pr_globalErrorHandler {
				Arguments: (ep_err);
				Body: {
					pr_appendError(ep_err );
					
					if bp_locSeenErrorsAreHandled then
						errh::MarkAsHandled( ep_err );
					endif ;
				}
				ElementParameter ep_err {
					Range: errh::PendingErrors;
					Property: Input;
				}
				ElementParameter ep_jobErrorMessageNumber {
					Range: s_jobErrorMessageNumbers;
				}
				Parameter p_errStackHeight;
				Parameter p_errStackPos;
				ElementParameter ep_stackPosition {
					Range: s_stackPositions;
				}
			}
			Procedure pr_seenErrorsAreHandled {
				Arguments: (bp_areHandled);
				Body: {
					bp_locSeenErrorsAreHandled := bp_areHandled ;
				}
				Parameter bp_areHandled {
					Range: binary;
					Default: 1;
					Property: Input;
				}
			}
			Procedure pr_downloadErrorReport {
				Arguments: (fileLocation,statusCode,statusDescription);
				Body: {
					block 
						gss::pr_initErrorHandlingDownloadUploadButtons( ep_stat, statusCode,  statusDescription, bp_download:1 );
					
						fileLocation := "usage.errorLogging";
					
						! we store the location of the file in string parameter FinalLocation
						sp_finalLocation := webui::GetIOFilePath(fileLocation);
					
						! writing the string parameter FinalLocation to a text file
						pr_reportCurrentErrorsToTextFile(sp_finalLocation);
					
						! checking if the previous write statement was successful or not
						if FileExists(sp_finalLocation) then
					
							! if successful, statusCode is set to 'CREATED' which will trigger the download widget to show the Get button
							StatusCode := webui::ReturnStatusCode('CREATED');
							! displaying the status message as All perfect instead of the default "File ready to download"
							StatusDescription := "All perfect!";
					
						else    !if previous write statement was not successful
					
							! setting the statusCode to 'ERROR' and the download widget will not show the Get button anymore
							statusCode := webui::ReturnStatusCode('ERROR');
							!displaying a custom error message
							statusDescription := "Something went wrong when creating the file.";
					
						endif;
					
					onerror ep_err do
					
						gss::pr_appendError(ep_err);
						gss::pr_uploadDownloadWidgetErrorHandling( ep_err, ep_stat, statusCode, statusDescription); 
					
						errh::MarkAsHandled(ep_err);
					
					endblock ;
				}
				StringParameter fileLocation {
					Property: Output;
				}
				Parameter statusCode {
					Property: Output;
				}
				StringParameter statusDescription {
					Property: Output;
				}
				StringParameter sp_finalLocation;
				ElementParameter ep_err {
					Range: errh::PendingErrors;
				}
				ElementParameter ep_stat {
					Range: errh::AllErrorSeverities;
				}
			}
			Procedure pr_downloadErrorData {
				Arguments: (fileLocation,statusCode,statusDescription);
				Body: {
					block
					
						gss::pr_initErrorHandlingDownloadUploadButtons( ep_stat, statusCode,  statusDescription, bp_download:1 );
					
						fileLocation := "Errors.json";
					
						! we store the location of the file in string parameter sp_FinalLocation
						sp_finalLocation := webui::GetIOFilePath(fileLocation);
					
						! writing the string parameter FinalLocation to a text file
						! write serverSessionProfilerErrorData to file sp_finalLocation ;
						pr_writeErrorDataToJSONFile( sp_finalLocation );
					
						! checking if the previous write statement was successful or not
						if FileExists(sp_finalLocation) then
					
							! if successful, statusCode is set to 'CREATED' which will trigger the download widget to show the Get button
							StatusCode := webui::ReturnStatusCode('CREATED');
							! displaying the status message as All perfect instead of the default "File ready to download"
							StatusDescription := "All perfect!";
					
						else    !if previous write statement was not successful
					
							! setting the statusCode to 'ERROR' and the download widget will not show the Get button anymore
							statusCode := webui::ReturnStatusCode('ERROR');
							!displaying a custom error message
							statusDescription := "Something went wrong when creating the file.";
					
						endif;
					
					onerror ep_err do
					
						gss::pr_appendError(ep_err);
						gss::pr_uploadDownloadWidgetErrorHandling( ep_err, ep_stat, statusCode, statusDescription); 
					
						errh::MarkAsHandled(ep_err);
					
					endblock ;
				}
				StringParameter fileLocation {
					Property: Output;
				}
				Parameter statusCode {
					Property: Output;
				}
				StringParameter statusDescription {
					Property: Output;
				}
				StringParameter sp_finalLocation;
				ElementParameter ep_stat {
					Range: errh::AllErrorSeverities;
				}
				ElementParameter ep_err {
					Range: errh::PendingErrors;
				}
			}
			Procedure pr_uploadErrorData {
				Arguments: (fileLocation,statusCode,statusDescription);
				Body: {
					sp_fileUploadLocation := webui::GetIOFilePath(fileLocation);
					! The file is uploaded to the process specific temporary folder. 
					
					pr_readErrorDataFromJSONFile(sp_fileUploadLocation);
					
					statusCode := webui::ReturnStatusCode('OK');
					statusDescription := "Nice.";
				}
				StringParameter sp_fileUploadLocation;
				StringParameter fileLocation {
					Property: Input;
				}
				Parameter statusCode {
					Property: Output;
				}
				StringParameter statusDescription {
					Property: Output;
				}
			}
			Procedure pr_uploadDownloadWidgetErrorHandling {
				Arguments: (ep_err, ep_stat, statusCode, statusDescription);
				Body: {
					! Ensure that the single message shown to the user is the first error, and if there is none: the first warning.
					if errh::Severity(ep_err) = 'warning' then
						if ep_stat = '' then
							statusDescription := "OK, but note: " + errh::Message( ep_err );
							ep_stat := 'warning';
						endif ;
					else
						statusCode := webui::ReturnStatusCode('ERROR');
						if ep_stat <> 'error' then
							statusDescription := "Better luck next time: " + errh::Message( ep_err );
							ep_stat := 'error';
						endif;
					endif ;
					
					! Best practice: declare ep_err and ep_stat inside the calling procedure.
				}
				ElementParameter ep_err {
					Range: errh::PendingErrors;
					Property: Input;
				}
				ElementParameter ep_stat {
					Range: errh::AllErrorSeverities;
					Property: InOut;
				}
				Parameter statusCode {
					Property: InOut;
				}
				StringParameter statusDescription {
					Property: InOut;
				}
			}
			Procedure pr_initErrorHandlingDownloadUploadButtons {
				Arguments: (ep_stat,statusCode,statusDescription,bp_download);
				Body: {
					ep_stat := '';
					statusCode := if bp_download then webui::ReturnStatusCode('CREATED') else webui::ReturnStatusCode('OK') endif ;
					statusDescription := "Nice.";
					
					! Best practice: declare ep_stat inside the calling procedure.
				}
				ElementParameter ep_stat {
					Range: errh::AllErrorSeverities;
					Property: Output;
				}
				Parameter statusCode {
					Property: Output;
				}
				StringParameter statusDescription {
					Property: Output;
				}
				Parameter bp_download {
					Property: Optional;
				}
			}
			Procedure pr_appendError {
				Arguments: (ep_err,sp_prefix);
				Body: {
					! Increase the number of recorded error messages.
					s_jobErrorMessageNumbers += card(s_jobErrorMessageNumbers) + 1;
					ep_jobErrorMessageNumber := last(s_jobErrorMessageNumbers);
					
					sp_msg := sp_prefix + errh::Message( ep_err);
					
					! Record the message and severity.
					sp_jobErrorMessages(ep_JobErrorMessageNumber) := sp_msg;
					sp_jobErrorMoments( ep_jobErrorMessageNumber) := errh::CreationTime(ep_err,"%c%y-%m-%d %H:%M:%S:%T%TZ('local')");
					ep_jobErrorSeverity(ep_jobErrorMessageNumber) := ep_errorToMessageLevelMap(errh::Severity(ep_err));
					
					! Record the entire stack of error positions
					p_errStackHeight := errh::NumberOfLocations(ep_err);
					p_errStackPos := 1 ;
					while p_errStackPos <= p_errStackHeight do
						ep_stackPosition := p_errStackPos;
						ep_jobErrorNodes(ep_jobErrorMessageNumber,ep_stackPosition) := errh::Node(ep_err,ep_stackPosition);
						ep_JobErrorAttributes(ep_jobErrorMessageNumber,ep_stackPosition) := errh::attribute(ep_err,ep_stackPosition);
						p_jobErrorLines( ep_jobErrorMessageNumber,ep_stackPosition) := errh::Line(ep_err,ep_stackPosition);
						p_errStackPos += 1 ;
					endwhile ;
					
					if errh::Severity(ep_err) = 'warning' then
						p_noWarnings += 1 ;
					else
						p_NoErrors += 1 ;
					endif ;
				}
				Comment: "Store the error in the data structures of the library.";
				ElementParameter ep_err {
					Range: errh::PendingErrors;
					Property: Input;
				}
				Parameter p_errStackHeight;
				Parameter p_errStackPos;
				ElementParameter ep_stackPosition {
					Range: s_stackPositions;
				}
				ElementParameter ep_jobErrorMessageNumber {
					Range: s_jobErrorMessageNumbers;
				}
				StringParameter sp_prefix {
					Property: Optional;
				}
				StringParameter sp_msg;
			}
			Procedure pr_appendMessage {
				Arguments: (sp_msg,ep_lev);
				Body: {
					! Increase the number of recorded error messages.
					s_jobErrorMessageNumbers += card(s_jobErrorMessageNumbers) + 1;
					ep_jobErrorMessageNumber := last(s_jobErrorMessageNumbers);
					
					! Record the message and severity.
					sp_jobErrorMessages(ep_jobErrorMessageNumber) := sp_msg;
					sp_jobErrorMoments( ep_jobErrorMessageNumber) := CurrentToString("%c%y-%m-%d %H:%M:%S:%T");
					ep_jobErrorSeverity(ep_jobErrorMessageNumber) := ep_lev;
					
					! Record the entire stack of error positions
					p_errStackHeight := callerNumberOfLocations();
					p_errStackPos := 1 ;
					while p_errStackPos <= p_errStackHeight do
						ep_stackPosition := p_errStackPos;
						ep_jobErrorNodes(     ep_jobErrorMessageNumber,ep_stackPosition) := callerNode(     ep_stackPosition);
						ep_JobErrorAttributes(ep_jobErrorMessageNumber,ep_stackPosition) := callerAttribute(ep_stackPosition);
						p_jobErrorLines(      ep_jobErrorMessageNumber,ep_stackPosition) := callerLine(     ep_stackPosition);
						p_errStackPos += 1 ;
					endwhile ;
					
					p_noLogMessages += 1 ;
				}
				Comment: "Store the error in the data structures of the library.";
				Parameter p_errStackHeight;
				Parameter p_errStackPos;
				ElementParameter ep_stackPosition {
					Range: s_stackPositions;
				}
				ElementParameter ep_jobErrorMessageNumber {
					Range: s_jobErrorMessageNumbers;
				}
				StringParameter sp_msg {
					Property: Input;
				}
				ElementParameter ep_lev {
					Range: s_messageLevels;
					Default: 'info';
					Property: Optional;
				}
			}
			Procedure pr_openProfiledIdentifier {
				Body: {
					IdentifierShowAttributes( ep_profilerDataSelectedIdentifier );
				}
			}
			Procedure pr_openIdentifierOnStack {
				Body: {
					if card(s_jobErrorMessageNumbers) then
						if not ep_errorWarningSelectedMessage then
							ep_errorWarningSelectedMessage := last( s_jobErrorMessageNumbers );
						endif ;
						if not ep_StackPos then
							ep_StackPos := first( s_stackPositions );
						endif ;
						if ep_errorWarningSelectedMessage and ep_StackPos then
							IdentifierShowAttributes(  
								ep_jobErrorNodes( ep_errorWarningSelectedMessage, ep_stackPos ));
						endif ;
					endif ;
				}
			}
			Procedure pr_openIdentifierOnMessageList {
				Body: {
					IdentifierShowAttributes(  
						ep_jobErrorNodes( ep_errorWarningSelectedMessage, 1 ));
				}
			}
		}
		Section Inspect_state_session {
			Procedure pr_saveState {
				Arguments: (sp_label,s_selectedIdentifiers);
				Body: {
					
					Block ! Determine the subset of identifiers that actually have data to be written to file.
						s_selectedIdentifiersWithData := { i_someId |
							( i_someId in AllSets ) or
							( i_someId in AllParameters ) or
							( i_someId in AllVariables ) or
							( i_someId in AllConstraints ) };
						if not card( s_selectedIdentifiersWithData ) then
							raise warning "No data output from gss::SaveState, as no identifier contains data" ;
							return 0;
						endif ;
					endblock ;
					
					Block ! Materials will be written first to a subfolder of the project folder.  Ensure this intermediate folder exists.
						if  not directoryExists( sp_label ) then
							directoryCreate( sp_label );
						endif ;
					endblock ;
					
					block ! Ensure PRO is connected, initialized, and the PRO Storage folder exists that will contain all text output files
						if pro::GetPROEndPoint() then
							pro::Initialize();
							sp_slash := "/" ;
							sp_proStorageFolderName := "/Userdata/" + 
								pro::GetPROEnvironment() + sp_slash + 
								pro::GetPROUserName()    + sp_slash + 
								pro::ModelName           + sp_slash + 
								pro::modelversion        + sp_slash + 
								sp_label ;
							pr_ensurePath( sp_proStorageFolderName );
						endif ;
					endblock ;
					
					block ! Each data identifier to be written to file is written to a separate file.
						where single_column_display := 1, listing_number_precision := 12, listing_number_width := 20 ;
						for i_someIdWithData do
							s_singleTonSet := {};
							s_singleTonSet += i_someIdWithData ;
							sp_filename := spfnc_fileFriendlyName( i_someIdWithData );
							sp_fullFilename := sp_label + "\\" + sp_filename;
							write s_singleTonSet to file sp_fullFilename ;
							if pro::GetPROEndPoint() then
								sp_proStorageFileName := sp_proStorageFolderName + sp_slash + sp_filename ;
								pro::SaveFileToCentralStorage(
									localPath     :  sp_fullFilename, 
									storagePath   :  sp_proStorageFileName);
							endif ;
						endfor ;
					endblock ;
				}
				StringParameter sp_proStorageFolderName;
				StringParameter sp_proStorageFileName;
				StringParameter sp_slash;
				Set s_selectedIdentifiers {
					SubsetOf: AllSymbols;
					Index: i_someId;
					Property: Input;
				}
				Set s_selectedIdentifiersWithData {
					SubsetOf: AllIdentifiers;
					Index: i_someIdWithData;
				}
				Set s_singleTonSet {
					SubsetOf: AllIdentifiers;
				}
				StringParameter sp_label {
					Property: Input;
				}
				StringParameter sp_filename;
				StringParameter sp_fullFilename;
			}
		}
		Section Logging {
			Property: NoSave;
			Procedure pr_logMsgTraceFile {
				Arguments: (sp_msg,ep_lev);
				Body: {
					if ep_lev >= ep_tracinglevel then
						put f_traceFile ;
						put sp_msg, / ;
						putclose ;
						p_noLogLinesWritten += 1 ;
					endif ;
				}
				StringParameter sp_msg {
					Property: Input;
				}
				ElementParameter ep_lev {
					Range: s_messageLevels;
					Default: 'trace';
					Property: Optional;
				}
			}
			Procedure pr_logMsg {
				Arguments: (sp_msg,ep_lev);
				Body: {
					if ep_lev >= ep_tracingLevel then
						if bp_loggingToFile then
							pr_logMsgTraceFile(sp_msg,ep_lev);
						else
							switch ep_lev do
								'error', 'warn': 
									pro::management::LocalLogError( sp_msg );
								'info': 
									pro::management::LocalLogInfo( sp_msg );
								'debug': 
									pro::management::LocalLogDebug( sp_msg );
								'trace': 
									pro::management::LocalLogTrace( sp_msg );
								default:
									raise warning "Unknown message level: " + ep_lev ;
									pro::management::LocalLogInfo( sp_msg );
							endswitch ;
						endif ;
					endif ;
				}
				StringParameter sp_msg {
					Property: Input;
				}
				ElementParameter ep_lev {
					Range: s_messageLevels;
					Default: 'trace';
					Property: Optional;
				}
			}
			Procedure pr_enter {
				Arguments: (sp_procEnterTimestamp,p_procEnterMemoryInUse,sp_procEnterContextMessage);
				Body: {
					sp_procEnterTimestamp := CurrentToString("%c%y-%m-%d %H:%M:%S:%t%TZ('UTC')");
					p_procEnterMemoryInUse := MemoryInUse();
					sp_node := formatString("%e",CallerNode(1));
					sp_fullMsg := formatString("Enter %s(%s) at %s [%.3n Mb] in use", 
						sp_node, sp_procEnterContextMessage, 
						MomentToString(
							Format        :  "%c%y-%m-%d %H:%M:%S:%t%TZ(ep_traceTimezone)", 
							unit          :  [s], 
							ReferenceDate :  sp_procEnterTimestamp, 
							Elapsed       :  0[s]), 
						p_procEnterMemoryInUse );
					pr_logMsg( sp_fullMsg );
				}
				StringParameter sp_procEnterTimestamp {
					Property: InOut;
				}
				Parameter p_procEnterMemoryInUse {
					Property: InOut;
				}
				StringParameter sp_procEnterContextMessage {
					Property: Optional;
					Comment: {
						"If the traced procedure contains arguments, 
						you may want to summarize these arguments here."
					}
				}
				StringParameter sp_node;
				StringParameter sp_fullMsg;
			}
			Procedure pr_leave {
				Arguments: (sp_procEnterTimestamp,p_procEnterMemoryInUse,sp_msg);
				Body: {
					sp_leavingTime := CurrentToString("%c%y-%m-%d %H:%M:%S:%t%TZ('UTC')");
					p_duration := StringToMoment(
						Format        :  "%c%y-%m-%d %H:%M:%S:%t%TZ('UTC')", 
						Unit          :  [s], 
						ReferenceDate :  sp_procEnterTimestamp, 
						Timeslot      :  sp_leavingTime);
					sp_node := formatString("%e",CallerNode(1));
					p_leaveMemoryInUse := MemoryInUse();
					sp_fullMsg := 
						formatString( "Leave %s(%s) at %s [%.3n Mb] in use. ",
							sp_node, sp_msg, 
							MomentToString(
								Format        :  "%c%y-%m-%d %H:%M:%S:%t%TZ(ep_traceTimezone)", 
								unit          :  [s], 
								ReferenceDate :  sp_leavingTime, 
								Elapsed       :  0[s]), 
							p_leaveMemoryInUse ) +
						formatString( "Duration is %.3n [seconds] and memory %s is %n Mb.", 
							p_duration,
							if p_leaveMemoryInUse >= p_procEnterMemoryInUse then "increase" else "decrease" endif, 
							abs( p_leaveMemoryInUse - p_procEnterMemoryInUse ) );
					pr_logMsg( sp_fullMsg );
				}
				Parameter p_procEnterMemoryInUse {
					Property: Input;
				}
				StringParameter sp_procEnterTimestamp {
					Property: Input;
				}
				StringParameter sp_leavingTime;
				Parameter p_duration {
					Unit: s;
				}
				Parameter p_leaveMemoryInUse;
				StringParameter sp_msg {
					Property: Optional;
				}
				StringParameter sp_node;
				StringParameter sp_fullMsg;
			}
		}
	}
	Section Private_Section {
		Property: NoSave;
		Section Main_Library_procedures {
			Procedure LibraryInitialization {
				Comment: "Add initialization statements here that do not require any other library being initialized already.";
			}
			Procedure PostLibraryInitialization {
				Body: {
					CurrentInputs -= serverSessionProfilerErrorData ;
					
					block ! Initialize logging
						if pro::GetPROEndPoint() then
							if pro::management::IsRunningOnCloud() then
								! if DirectoryExists( "MainProject/WebUI" to be tested (WinUI apps might be ble to log to file version of session logs anyway).
								bp_loggingOnCloud := 1 ;
								bp_loggingToFile  := 1 ;
							else
								bp_loggingOnCloud := 0 ;
								bp_loggingToFile  := 0 ;
							endif ;
						else
							bp_loggingOnCloud := 0 ;
							bp_loggingToFile  := 1 ;
						endif ;
						if bp_loggingToFile then
							if fileExists( sp_traceFilename ) then
								FileDelete( sp_traceFilename );
							endif ;
						endif ;
					endblock ;
					
					! log file of a week old are to be deleted
				}
				Comment: {
					"Add initialization statements here that require another library to be initialized already,
					or add statements that require the Data Management module to be initialized."
				}
			}
			Procedure PreLibraryTermination {
				Body: {
					
					
					return 1;
				}
				Comment: {
					"Add termination statements here that require all other libraries to be still alive.
					Return 1 if you allow the termination sequence to continue.
					Return 0 if you want to cancel the termination sequence."
				}
			}
			Procedure LibraryTermination {
				Body: {
					return 1;
				}
				Comment: {
					"Add termination statements here that do not require other libraries to be still alive.
					Return 1 to allow the termination sequence to continue.
					Return 0 if you want to cancel the termination sequence.
					It is recommended to only use the procedure PreLibraryTermination to cancel the termination sequence and let this procedure always return 1."
				}
			}
		}
		Section Guard_utilities {
			Parameter bp_locSeenErrorsAreHandled {
				Range: binary;
				InitialData: 0;
			}
			Index i_errorSeverity {
				Range: errh::AllErrorSeverities;
			}
			ElementParameter ep_errorToMessageLevelMap {
				IndexDomain: i_errorSeverity;
				Range: s_messageLevels;
				Definition: data { 'severe' : 'fatal', 'error' : 'error', 'warning' : 'warn' };
			}
			Procedure pr_sampleProc {
				Body: {
					! Do not delete this procedure, it is used as default of element parameter gss::ep_Work.
				}
			}
			Procedure pr_writeErrorDataToJSONFile {
				Arguments: (sp_finalLocation);
				Body: {
					dex::AddMapping("JSONERRORmap","GuardServerSession/mappings/JSONErrors.xml");
					dex::WriteToFile(
						dataFile    :  sp_finalLocation, 
						mappingName :  "JSONERRORmap", 
						pretty      :  1);
				}
				StringParameter sp_finalLocation {
					Property: Input;
				}
			}
			Procedure pr_readErrorDataFromJSONFile {
				Arguments: (sp_finalLocation);
				Body: {
					dex::AddMapping("JSONERRORmap","GuardServerSession/mappings/JSONErrors.xml");
					dex::ReadFromFile(
						dataFile    	 :  sp_finalLocation, 
						mappingName 	 :  "JSONERRORmap", 
						emptyIdentifiers :  0, 
						emptySets        :  0, 
						resetCounters    :  1);
				}
				StringParameter sp_finalLocation {
					Property: Input;
				}
			}
		}
		Section Inspect_utilities {
			Procedure pr_ensurePath {
				Arguments: (sp_path);
				Body: {
					if not pr_proFolderExists( sp_path ) then
					        pro::CreateStorageFolder( sp_path );
					endif ;
				}
				StringParameter sp_path {
					Property: Input;
				}
			}
			Function spfnc_fileFriendlyName {
				Arguments: (ep_id);
				Range: string;
				Body: {
					sp_retVal := formatString("%e", ep_id );
					sp_retVal := FindReplaceStrings( sp_retVal, ":", "_" );
					
					spfnc_fileFriendlyName := sp_retVal ;
				}
				ElementParameter ep_id {
					Range: AllIdentifiers;
					Property: Input;
				}
				StringParameter sp_retVal;
			}
			Procedure pr_proFolderExists {
				Arguments: (sp_filepath);
				Body: {
					! proFolderExists, proDirectoryExists, FolderExists, DirectoryExists
					pro::NormalizeStoragePath(sp_filepath);
					p_ret := pro::storage::ListBuckets(
								path       :  sp_filepath, 
								BucketSet  :  s_locBucketSet, 
								BucketSize :  p_locBucketSize, 
								BucketAuth :  sp_locBucketAuth, 
								BucketDate :  sp_locBucketDate);
					return p_ret ;
				}
				StringParameter sp_filepath {
					Property: Input;
				}
				Parameter p_ret;
				Set s_locBucketSet {
					Index: bs;
				}
				Parameter p_locBucketSize {
					IndexDomain: bs;
				}
				StringParameter sp_locBucketAuth {
					IndexDomain: bs;
				}
				StringParameter sp_locBucketDate {
					IndexDomain: bs;
				}
			}
			Procedure pr_proFileExists {
				Arguments: (sp_filename);
				Body: {
					pro::NormalizeStoragePath(sp_filename);
					pro::SplitStoragePath(sp_filename,sp_storageBucketPath,sp_storageFileWithoutPath);
					if not pr_proFolderExists( sp_storageBucketPath ) then return 0 ; endif ;
					p_ret := pro::storage::GetObjectInfo(sp_storageBucketPath, sp_storageFileWithoutPath,
							sp_tmpLocalFileName, sp_tmpType, p_tmpNum, sp_tmpAuth, p_tmpVersion );
					if p_ret = 0 or p_tmpNum <= 0 then
						return 0 ;
					endif ;
					return 1 ;
				}
				Comment: {
					"d:\\u\\s\\aimms3\\deps\\vc120_x64_Debug\\Libraries\\AimmsWebUI\\AimmsWebUI.ams line 1600
					d:\\u\\s\\Customers\\K3 Delta\\Escalation March 2017\\6763\\UploadTool\\UploadTool\\UploadTool\\FileExistsFolderExists.ams line 40"
				}
				StringParameter sp_filename {
					Property: Input;
				}
				Parameter p_ret;
				StringParameter sp_storageBucketPath;
				StringParameter sp_storageFileWithoutPath;
				Parameter p_tmpNum;
				StringParameter sp_tmpLocalFileName;
				StringParameter sp_tmpType;
				StringParameter sp_tmpAuth;
				Parameter p_tmpVersion;
			}
			Function fnc_hasProPrefix {
				Arguments: (sp_filename);
				Range: binary;
				Body: {
					p_retval := 0 ;
					
					if Stringlength( sp_filename ) > 4 then
						if findstring( substring( sp_filename, 1, 4 ), "pro:", CaseSensitive:0 ) then
							p_retval := 1 ;
						else
							p_retval := 0 ;
						endif ;
					else
						p_retval := 0 ;
					endif ;
					
					fnc_hasProPrefix := p_retval ;
				}
				StringParameter sp_filename {
					Property: Input;
				}
				Parameter p_retval {
					Range: binary;
				}
			}
		}
		Section Logging_utilities {
			ElementParameter ep_tracinglevel {
				Range: s_messageLevels;
				InitialData: 'info';
			}
			Parameter p_noLogLinesWritten {
				InitialData: 0;
			}
			StringParameter sp_traceFilename {
				InitialData: "logging.txt";
			}
			File f_traceFile {
				Name: sp_traceFilename;
				Device: Disk;
				Mode: merge;
			}
			ElementParameter ep_traceTimezone {
				Range: AllTimeZones;
				InitialData: 'localDST';
			}
			Parameter bp_loggingOnCloud {
				Range: binary;
				InitialData: 0;
			}
			Parameter bp_loggingToFile {
				Range: binary;
				InitialData: 1;
				Comment: {
					"Both vi AIMMS Developer, and when running in the cloud, this binary will be initialized to 1.
					0 otherwise."
				}
			}
		}
	}
}
