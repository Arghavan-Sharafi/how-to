## ams_version=1.0

LibraryModule Library_GuardServerSession {
	Prefix: gss;
	Interface: Public_Section;
	Comment: {
		"Requirements:
		- Declaration of time, preferably as SI_Time_Duration, including unit s.
		- System library AIMMS PRO
		- Repository library DataExchange
		- AIMMS 4.76 or later
		
		Test WebUI and WinUI apps in Cloud/Prem/Developer"
	}
	Section Public_Section {
		Section WebUI_Support {
			Property: NoSave;
			StringParameter sp_widgetActionMessageStack {
				IndexDomain: (webui::indexPageExtension, webui::indexWidgetActionSpec);
				Definition: {
					{
						('1', 'displaytext' ) : "Model explorer",  
						('1', 'icon'        ) : "aimms-glasses",  
						('1', 'procedure'   ) : "gss::pr_OpenIdentifierOnStack",  
						('1', 'state'       ) : "Active"  
					}
				}
			}
			StringParameter sp_itemActionMessageStack {
				IndexDomain: (webui::indexWidgetItemActionSpec, webui::indexPageExtension, webui::indexWidgetActionSpec);
				Definition: {
					{
						('gss::ep_shownJobErrorSeverity', '1', 'displaytext' ) : "Model explorer",  
						('gss::ep_shownJobErrorSeverity', '1', 'icon'        ) : "aimms-glasses",  
						('gss::ep_shownJobErrorSeverity', '1', 'procedure'   ) : "gss::pr_OpenIdentifierOnStack",  
						('gss::ep_shownJobErrorSeverity', '1', 'state'       ) : "Active" ,
					
						('gss::sp_shownJobErrorMoments',  '1', 'displaytext' ) : "Model explorer",  
						('gss::sp_shownJobErrorMoments',  '1', 'icon'        ) : "aimms-glasses",  
						('gss::sp_shownJobErrorMoments',  '1', 'procedure'   ) : "gss::pr_OpenIdentifierOnStack",  
						('gss::sp_shownJobErrorMoments',  '1', 'state'       ) : "Active" ,
					
						('gss::sp_shownJobErrorMessages',  '1', 'displaytext' ) : "Model explorer",  
						('gss::sp_shownJobErrorMessages',  '1', 'icon'        ) : "aimms-glasses",  
						('gss::sp_shownJobErrorMessages',  '1', 'procedure'   ) : "gss::pr_OpenIdentifierOnStack",  
						('gss::sp_shownJobErrorMessages',  '1', 'state'       ) : "Active" 
					
					}
				}
			}
			StringParameter sp_widgetActionMessageList {
				IndexDomain: (webui::indexPageExtension, webui::indexWidgetActionSpec);
				Definition: {
					{
						('1', 'displaytext' ) : "Model explorer",  
						('1', 'icon'        ) : "aimms-glasses",  
						('1', 'procedure'   ) : "gss::pr_OpenIdentifierOnMessageList",  
						('1', 'state'       ) : "Active"  
					}
				}
			}
			StringParameter sp_itemActionMessageList {
				IndexDomain: (webui::indexWidgetItemActionSpec, webui::indexPageExtension, webui::indexWidgetActionSpec);
				Definition: {
					{
						('gss::ep_shownJobErrorNodes',     '1', 'displaytext' ) : "Model explorer",  
						('gss::ep_shownJobErrorNodes',     '1', 'icon'        ) : "aimms-glasses",  
						('gss::ep_shownJobErrorNodes',     '1', 'procedure'   ) : "gss::pr_OpenIdentifierOnMessageList",  
						('gss::ep_shownJobErrorNodes',     '1', 'state'       ) : "Active",
					
						('gss::ep_shownJobErrorAttributes', '1', 'displaytext' ) : "Model explorer",  
						('gss::ep_shownJobErrorAttributes', '1', 'icon'        ) : "aimms-glasses",  
						('gss::ep_shownJobErrorAttributes', '1', 'procedure'   ) : "gss::pr_OpenIdentifierOnMessageList",  
						('gss::ep_shownJobErrorAttributes', '1', 'state'       ) : "Active",
					
						('gss::p_shownJobErrorLines',       '1', 'displaytext' ) : "Model explorer",  
						('gss::p_shownJobErrorLines',       '1', 'icon'        ) : "aimms-glasses",  
						('gss::p_shownJobErrorLines',       '1', 'procedure'   ) : "gss::pr_OpenIdentifierOnMessageList",  
						('gss::p_shownJobErrorLines',       '1', 'state'       ) : "Active"  
					}
				}
			}
			StringParameter sp_widgetActionIdentifierProfiler {
				IndexDomain: (webui::indexPageExtension, webui::indexWidgetActionSpec);
				Definition: {
					{
						('1', 'displaytext' ) : "Model explorer",  
						('1', 'icon'        ) : "aimms-glasses",  
						('1', 'procedure'   ) : "gss::pr_OpenProfiledIdentifier",  
						('1', 'state'       ) : "Active"  
					}
				}
			}
			StringParameter sp_itemActionIdentifierProfiler {
				IndexDomain: (webui::indexWidgetItemActionSpec, webui::indexPageExtension, webui::indexWidgetActionSpec);
				Definition: {
					{
						('gss::p_shownJobProfilerData', '1', 'displaytext' ) : "Model explorer",  
						('gss::p_shownJobProfilerData', '1', 'icon'        ) : "aimms-glasses",  
						('gss::p_shownJobProfilerData', '1', 'procedure'   ) : "gss::pr_OpenProfiledIdentifier",  
						('gss::p_shownJobProfilerData', '1', 'state'       ) : "Active"  
					}
				}
			}
			StringParameter sp_SidePanelErrorPage {
				IndexDomain: (webui::indexApplicationExtension,webui::indexSidePanelSpec);
				Definition: {
					{
						( '1', 'displayText' ) : if p_noSignificantMessages then FormatString("%i msgs", p_noSignificantMessages ) else "" endif,
						( '1', 'pageId'      ) : if p_noSignificantMessages then "errorpanel_1"                                    else "" endif,
						( '1', 'tooltip'     ) : if p_noSignificantMessages then "Error handling"                                  else "" endif,  
						( '1', 'state'       ) : if p_noSignificantMessages then "Active"                                          else "" endif 
					}
				}
			}
			StringParameter sp_messageStatusBar {
				IndexDomain: (webui::indexApplicationExtension,webui::indexStatusBarSpec);
				Definition: {
					{
						('1', 'header'   ): "Messages",
						('1', 'icon'     ): "aimms-power", 
						('1', 'color'    ): "", 
						('1', 'text'     ): 
							FormatString("%i messages, %i warnings, and %i errors",
								p_noLogMessages, p_noWarnings, p_noErrors), 
						('1', 'tooltip'  ): "", 
						('1', 'procedure'): "", 
						('1', 'state'    ): if card(s_jobErrorMessageNumbers) then "Active" else "Hidden" endif 
					}
				}
			}
			StringParameter sp_errorWarningMessageMenu {
				IndexDomain: (webui::indexPageExtension, webui::indexWidgetActionSpec);
			}
			StringParameter sp_titleProfilerDetail {
				Definition: FormatString("Profiler data for %e", ep_profilerDataSelectedIdentifier);
			}
			StringParameter sp_titleStackMessage {
				Definition: FormatString("Stack of \"%s\"", sp_jobErrorMessages( ep_errorWarningSelectedMessage ) );
			}
			ElementParameter ep_profilerDataSelectedIdentifier {
				Range: AllIdentifiers;
				InitialData: '';
			}
			ElementParameter ep_errorWarningSelectedMessage {
				Range: s_jobErrorMessageNumbers;
				InitialData: '';
			}
			ElementParameter ep_stackPos {
				Range: s_stackPositions;
				InitialData: '';
			}
			Parameter p_noSignificantMessages {
				Definition: p_noLogMessages + p_NoWarnings + p_NoErrors;
			}
			Set s_messageLevels {
				Index: i_messageLevel;
				Definition: {
					data { trace, debug, info, warn, error, fatal } ;
				}
			}
			Set s_lineNumbers {
				SubsetOf: Integers;
				Index: i_lineNumber;
				Definition: ElementRange(0,1000);
			}
			Set s_positiveLineNumbers {
				SubsetOf: s_lineNumbers;
				Index: i_positiveLineNumber;
				Definition: ElementRange(1,1000);
			}
			Set s_actualLinenumbers {
				SubsetOf: s_lineNumbers;
				Index: i_actualLineNumber;
				Definition: ElementRange(1,if ep_lastHitLine then ep_lastHitLine else 1 endif);
			}
			Parameter ep_lastHitLine {
				Definition: {
					last( i_positiveLineNumber | 
						p_jobProfilerData(ep_profilerDataSelectedIdentifier, 
						i_positiveLineNumber, 'hits'))
				}
			}
			Set s_stackPositions {
				SubsetOf: Integers;
				Index: i_stackPosition;
				Definition: ElementRange(1,255);
			}
			Parameter bp_uploadErrorDataVisible {
				Range: binary;
				Definition: ProjectDeveloperMode;
			}
		}
		Section PRO_Support;
		Section Guarding {
			Section Generic {
				Section GSS_Error_WebUI_Support {
					Property: NoSave;
					DeclarationSection Declaration_selection_shown_session {
						ElementParameter ep_shownSession {
							Range: s_trackedSessions;
							InitialData: '';
							Comment: "By convention, if the shown session is the first then the running data session is selected.";
							webui::UponChangeProcedure: pr_uponChangeShownSession;
						}
						StringParameter sp_titleErrorWarningMessagesTable {
							Definition: formatString("Error and warning messages for session %s", sp_shownSessionDescription);
						}
					}
					Procedure pr_uponChangeShownSession {
						Body: {
							empty Shown_session_data_exchange ;
							
							sp_shownSessionDescription :=
								if ep_shownSession = first( s_trackedSessions ) then
									"data session"
								else
									sp_sessionGivenDescriptions(ep_shownSession)
								endif ;
							
							p_shownJobProfilerData(IndexIdentifiers, i_lineNumber, IndexProfilerTypes ) := 
								if ep_shownSession <> first( s_trackedSessions ) then
									p_trackedJobProfilerData(ep_shownSession, IndexIdentifiers, i_lineNumber, IndexProfilerTypes)
								else
									p_dataSessionProfilerData(IndexIdentifiers, i_lineNumber, IndexProfilerTypes)
								endif;
							
							sp_shownJobErrorMessages(i_jobErrorMessageNumber) := 
								if ep_shownSession <> first( s_trackedSessions ) then
									sp_trackedJobErrorMessages(ep_shownSession, i_jobErrorMessageNumber)
								else
									sp_dataSessionErrorMessages(i_jobErrorMessageNumber)
								endif ;
							
							sp_shownJobErrorMoments(i_jobErrorMessageNumber) := 
								if ep_shownSession <> first( s_trackedSessions ) then
									sp_trackedJobErrorMoments(ep_shownSession, i_jobErrorMessageNumber)
								else
									sp_dataSessionErrorMoments(i_jobErrorMessageNumber)
								endif;
							
							ep_shownJobErrorSeverity(i_jobErrorMessageNumber) := 
								if ep_shownSession <> first( s_trackedSessions ) then
									ep_trackedJobErrorSeverity(ep_shownSession, i_jobErrorMessageNumber)
								else
									ep_dataSessionErrorSeverity(i_jobErrorMessageNumber)
								endif;
							
							ep_shownJobErrorNodes(i_jobErrorMessageNumber, i_stackPosition) := 
								if ep_shownSession <> first( s_trackedSessions ) then
									ep_trackedJobErrorNodes(ep_shownSession, i_jobErrorMessageNumber,i_stackPosition)
								else
									ep_dataSessionErrorNodes(i_jobErrorMessageNumber,i_stackPosition)
								endif;
							
							ep_shownJobErrorAttributes(i_jobErrorMessageNumber, i_stackPosition) := 
								if ep_shownSession <> first( s_trackedSessions ) then
									ep_trackedJobErrorAttributes(ep_shownSession, i_jobErrorMessageNumber,i_stackPosition)
								else
									ep_dataSessionErrorAttributes(i_jobErrorMessageNumber,i_stackPosition)
								endif;
							
							p_shownJobErrorLines(i_jobErrorMessageNumber, i_stackPosition) := 
								if ep_shownSession <> first( s_trackedSessions ) then
									p_trackedJobErrorLines(ep_shownSession, i_jobErrorMessageNumber,i_stackPosition)
								else
									p_dataSessionErrorLines(i_jobErrorMessageNumber,i_stackPosition)
								endif;
						}
					}
					Procedure pr_clearShownSession;
					DeclarationSection Shown_session_data_exchange {
						StringParameter sp_shownSessionDescription {
							InitialData: "";
						}
						Parameter p_shownJobProfilerData {
							IndexDomain: (IndexIdentifiers,i_lineNumber,IndexProfilerTypes );
						}
						StringParameter sp_shownJobErrorMessages {
							IndexDomain: i_jobErrorMessageNumber;
						}
						StringParameter sp_shownJobErrorMoments {
							IndexDomain: i_jobErrorMessageNumber;
						}
						ElementParameter ep_shownJobErrorSeverity {
							IndexDomain: i_jobErrorMessageNumber;
							Range: s_messageLevels;
						}
						ElementParameter ep_shownJobErrorNodes {
							IndexDomain: (i_jobErrorMessageNumber,i_stackPosition);
							Range: AllSymbols;
						}
						ElementParameter ep_shownJobErrorAttributes {
							IndexDomain: (i_jobErrorMessageNumber,i_stackPosition);
							Range: AllAttributeNames;
						}
						Parameter p_shownJobErrorLines {
							IndexDomain: (i_jobErrorMessageNumber,i_stackPosition);
						}
					}
				}
				Parameter p_maxNoErrorsPerSession {
					InitialData: 10000;
				}
				Set s_jobErrorMessageNumbers {
					SubsetOf: Integers;
					Index: i_jobErrorMessageNumber, i_dataSessionErrorMessageNumber;
					Property: ElementsAreNumerical;
					Definition: ElementRange(1,p_maxNoErrorsPerSession);
				}
				Procedure pr_openProfiledIdentifier {
					Body: {
						if ep_profilerDataSelectedIdentifier then
							IdentifierShowAttributes( ep_profilerDataSelectedIdentifier );
						endif ;
					}
				}
				Procedure pr_openIdentifierOnStack {
					Body: {
						if card(s_jobErrorMessageNumbers) then
							if not ep_errorWarningSelectedMessage then
								ep_errorWarningSelectedMessage := last( s_jobErrorMessageNumbers );
							endif ;
							if not ep_StackPos then
								ep_StackPos := first( s_stackPositions );
							endif ;
							if ep_errorWarningSelectedMessage and ep_StackPos then
								IdentifierShowAttributes(  
									ep_shownJobErrorNodes( ep_errorWarningSelectedMessage, ep_stackPos ));
							endif ;
						endif ;
					}
				}
				Procedure pr_openIdentifierOnMessageList {
					Body: {
						if ep_errorWarningSelectedMessage and ep_shownJobErrorNodes( ep_errorWarningSelectedMessage, 1 ) then
							IdentifierShowAttributes(  
								ep_shownJobErrorNodes( ep_errorWarningSelectedMessage, ep_stackPos ));
						endif ;
					}
				}
				Procedure pr_initErrorHandlingDownloadUploadButtons {
					Arguments: (ep_stat,statusCode,statusDescription,bp_download);
					Body: {
						ep_stat := '';
						statusCode := if bp_download then webui::ReturnStatusCode('CREATED') else webui::ReturnStatusCode('OK') endif ;
						statusDescription := "Nice.";
						
						! Best practice: declare ep_stat inside the calling procedure.
					}
					ElementParameter ep_stat {
						Range: errh::AllErrorSeverities;
						Property: Output;
					}
					Parameter statusCode {
						Property: Output;
					}
					StringParameter statusDescription {
						Property: Output;
					}
					Parameter bp_download {
						Property: Optional;
					}
				}
				Procedure pr_uploadDownloadWidgetErrorHandling {
					Arguments: (ep_err, ep_stat, statusCode, statusDescription);
					Body: {
						! Ensure that the single message shown to the user is the first error, and if there is none: the first warning.
						if errh::Severity(ep_err) = 'warning' then
							if ep_stat = '' then
								statusDescription := "OK, but note: " + errh::Message( ep_err );
								ep_stat := 'warning';
							endif ;
						else
							statusCode := webui::ReturnStatusCode('ERROR');
							if ep_stat <> 'error' then
								statusDescription := "Better luck next time: " + errh::Message( ep_err );
								ep_stat := 'error';
							endif;
						endif ;
						
						! Best practice: declare ep_err and ep_stat inside the calling procedure.
					}
					ElementParameter ep_err {
						Range: errh::PendingErrors;
						Property: Input;
					}
					ElementParameter ep_stat {
						Range: errh::AllErrorSeverities;
						Property: InOut;
					}
					Parameter statusCode {
						Property: InOut;
					}
					StringParameter statusDescription {
						Property: InOut;
					}
				}
				Procedure pr_appendError {
					Arguments: (ep_err,sp_prefix);
					Body: {
						gss::pr_enter(sp_gssTime, p_gssMiU, errh::Message(ep_err));
						if pro::GetPROEndPoint() then
							if pro::IsRunningAtServer() then
								pr_appendErrorJob(ep_err,sp_prefix);
							else
								pr_appendErrorDataSession(ep_err,sp_prefix);
							endif ;
						else
							pr_appendErrorDataSession(ep_err,sp_prefix);
						endif ;
						gss::pr_leave(sp_gssTime, p_gssMiU, errh::Message(ep_err));
					}
					Comment: "Store the error in the data structures of the library.";
					ElementParameter ep_err {
						Range: errh::PendingErrors;
						Property: Input;
					}
					Parameter p_errStackHeight;
					Parameter p_errStackPos;
					ElementParameter ep_stackPosition {
						Range: s_stackPositions;
					}
					ElementParameter ep_jobErrorMessageNumber {
						Range: s_jobErrorMessageNumbers;
					}
					StringParameter sp_prefix {
						Property: Optional;
					}
					StringParameter sp_msg;
					DeclarationSection gss_logging_declarations {
						StringParameter sp_gssTime;
						Parameter p_gssMiU;
					}
				}
				Procedure pr_appendMessage {
					Arguments: (sp_msg,ep_lev);
					Body: {
						if pro::GetPROEndPoint() then
							if pro::IsRunningAtServer() then
								pr_appendMessageJob(sp_msg,ep_lev);
							else
								pr_appendMessageDataSession(sp_msg,ep_lev);
							endif ;
						else
							pr_appendMessageDataSession(sp_msg,ep_lev);
						endif ;
					}
					Comment: "Store the error in the data structures of the library.";
					Parameter p_errStackHeight;
					Parameter p_errStackPos;
					ElementParameter ep_stackPosition {
						Range: s_stackPositions;
					}
					ElementParameter ep_jobErrorMessageNumber {
						Range: s_jobErrorMessageNumbers;
					}
					StringParameter sp_msg {
						Property: Input;
					}
					ElementParameter ep_lev {
						Range: s_messageLevels;
						Default: 'info';
						Property: Optional;
					}
				}
				Procedure pr_globalErrorHandler {
					Arguments: (ep_err);
					Body: {
						pr_appendError(ep_err );
						
						if bp_locSeenErrorsAreHandled then
							errh::MarkAsHandled( ep_err );
						endif ;
					}
					ElementParameter ep_err {
						Range: errh::PendingErrors;
						Property: Input;
					}
					ElementParameter ep_jobErrorMessageNumber {
						Range: s_jobErrorMessageNumbers;
					}
					Parameter p_errStackHeight;
					Parameter p_errStackPos;
					ElementParameter ep_stackPosition {
						Range: s_stackPositions;
					}
				}
				Procedure pr_seenErrorsAreHandled {
					Arguments: (bp_areHandled);
					Body: {
						bp_locSeenErrorsAreHandled := bp_areHandled ;
					}
					Parameter bp_areHandled {
						Range: binary;
						Default: 1;
						Property: Input;
					}
				}
			}
			Section Tracked_sessions {
				Property: NoSave;
				DeclarationSection tracked_sessions_error_and_profiler_data {
					Set s_trackedSessions {
						Index: i_trackedSession;
						webui::ElementTextIdentifier: gss::sp_trackedSessionDescription;
					}
					StringParameter sp_trackedSessionDescription {
						IndexDomain: i_trackedSession;
						Definition: {
							if i_trackedSession = first( s_trackedSessions ) then
								formatString("%e : data session", i_trackedSession )
							else
								formatString("%e : %s",
									i_trackedSession, 
									sp_sessionGivenDescriptions( i_trackedSession ) )
							endif
						}
					}
					StringParameter sp_sessionGivenDescriptions {
						IndexDomain: i_trackedSession;
						InitialData: data {};
					}
					Parameter p_trackedJobProfilerData {
						IndexDomain: (i_trackedSession,IndexIdentifiers,i_lineNumber,IndexProfilerTypes );
						InitialData: data{};
					}
					StringParameter sp_trackedJobErrorMessages {
						IndexDomain: (i_trackedSession,i_jobErrorMessageNumber);
						InitialData: data {};
					}
					StringParameter sp_trackedJobErrorMoments {
						IndexDomain: (i_trackedSession,i_jobErrorMessageNumber);
						InitialData: data {};
					}
					ElementParameter ep_trackedJobErrorSeverity {
						IndexDomain: (i_trackedSession,i_jobErrorMessageNumber);
						Range: s_messageLevels;
						InitialData: data {};
					}
					ElementParameter ep_trackedJobErrorNodes {
						IndexDomain: (i_trackedSession,i_jobErrorMessageNumber,i_stackPosition);
						Range: AllSymbols;
						InitialData: data{};
					}
					ElementParameter ep_trackedJobErrorAttributes {
						IndexDomain: (i_trackedSession,i_jobErrorMessageNumber,i_stackPosition);
						Range: AllAttributeNames;
						InitialData: data {};
					}
					Parameter p_trackedJobErrorLines {
						IndexDomain: (i_trackedSession,i_jobErrorMessageNumber,i_stackPosition);
						InitialData: data {};
					}
				}
				Procedure pr_saveTrackedSessionData {
					Arguments: (sp_sessionID);
					Body: {
						if not sp_sessionID then
							raise error "pr_saveTrackedSessionData() unable to store session data without identification" ;
						endif ;
						ep_trackedSession := stringToElement( s_trackedSessions, sp_sessionID, create:1);
						if not ep_trackedSession then
							raise error "pr_saveTrackedSessionData() unable to create effective session id";
						endif ;
						
						p_trackedJobProfilerData(ep_trackedSession, IndexIdentifiers, i_lineNumber, IndexProfilerTypes) := p_jobProfilerData(IndexIdentifiers, i_lineNumber, IndexProfilerTypes);
						
						sp_trackedJobErrorMessages(ep_trackedSession, i_jobErrorMessageNumber) := sp_jobErrorMessages(i_jobErrorMessageNumber);
						sp_trackedJobErrorMoments( ep_trackedSession, i_jobErrorMessageNumber) := sp_jobErrorMoments( i_jobErrorMessageNumber);
						ep_trackedJobErrorSeverity(ep_trackedSession, i_jobErrorMessageNumber) := ep_jobErrorSeverity(i_jobErrorMessageNumber);
						
						ep_trackedJobErrorNodes(     ep_trackedSession, i_jobErrorMessageNumber, i_stackPosition) := ep_jobErrorNodes(     i_jobErrorMessageNumber, i_stackPosition);
						ep_trackedJobErrorAttributes(ep_trackedSession, i_jobErrorMessageNumber, i_stackPosition) := ep_jobErrorAttributes(i_jobErrorMessageNumber, i_stackPosition);
						p_trackedJobErrorLines(      ep_trackedSession, i_jobErrorMessageNumber, i_stackPosition) := p_jobErrorLines(      i_jobErrorMessageNumber, i_stackPosition);
					}
					StringParameter sp_sessionID {
						Property: Input;
					}
					ElementParameter ep_trackedSession {
						Range: s_trackedSessions;
					}
				}
				Procedure pr_uploadErrorData {
					Arguments: (fileLocation,statusCode,statusDescription);
					Body: {
						block
							pr_logMsg(formatString("Uploading file %s", fileLocation),'info');
							sp_fileUploadLocation := webui::GetIOFilePath(fileLocation);
							! The file is uploaded to the process specific temporary folder. 
						
							!pr_readErrorDataFromJSONFile(sp_fileUploadLocation);
							empty Shown_session_data_exchange;
							ep_trackedSession := StringToElement( s_trackedSessions, fileLocation, create:1);
							read from file sp_fileUploadLocation ;
							sp_sessionGivenDescriptions( ep_trackedSession ) := sp_shownSessionDescription ;
							p_trackedJobProfilerData(ep_trackedSession, IndexIdentifiers, i_lineNumber, IndexProfilerTypes) := p_shownJobProfilerData(IndexIdentifiers, i_lineNumber, IndexProfilerTypes);
							sp_trackedJobErrorMessages(ep_trackedSession, i_jobErrorMessageNumber) := sp_shownJobErrorMessages(i_jobErrorMessageNumber);
							sp_trackedJobErrorMoments(ep_trackedSession, i_jobErrorMessageNumber) := sp_shownJobErrorMoments(i_jobErrorMessageNumber);
							ep_trackedJobErrorSeverity(ep_trackedSession, i_jobErrorMessageNumber) := ep_shownJobErrorSeverity(i_jobErrorMessageNumber);
							ep_trackedJobErrorNodes(ep_trackedSession, i_jobErrorMessageNumber, i_stackPosition) := ep_shownJobErrorNodes(i_jobErrorMessageNumber, i_stackPosition);
							ep_trackedJobErrorAttributes(ep_trackedSession, i_jobErrorMessageNumber, i_stackPosition) := ep_shownJobErrorAttributes(i_jobErrorMessageNumber, i_stackPosition);
							p_trackedJobErrorLines(ep_trackedSession, i_jobErrorMessageNumber, i_stackPosition) := p_shownJobErrorLines(i_jobErrorMessageNumber, i_stackPosition);
							ep_shownSession := ep_trackedSession ;
						
							statusCode := webui::ReturnStatusCode('OK');
							statusDescription := "Succesfully uploaded file "+fileLocation;
						onerror ep_err do
							gss::pr_appendError(ep_err);
							errh::MarkAsHandled(ep_err);
							if errh::Severity(ep_err) <> 'warning' then
								statusCode := webui::ReturnStatusCode('ERROR');
								statusDescription := "Failed to upload file " + fileLocation ;
							endif ;
						endblock ;
					}
					StringParameter sp_fileUploadLocation;
					StringParameter fileLocation {
						Property: Input;
					}
					Parameter statusCode {
						Property: Output;
					}
					StringParameter statusDescription {
						Property: Output;
					}
					ElementParameter ep_err {
						Range: errh::PendingErrors;
					}
					ElementParameter ep_trackedSession {
						Range: s_trackedSessions;
					}
				}
				Procedure pr_downloadErrorData {
					Arguments: (fileLocation,statusCode,statusDescription);
					Body: {
						block
						
							gss::pr_initErrorHandlingDownloadUploadButtons( ep_stat, statusCode,  statusDescription, bp_download:1 );
						
							!fileLocation := formatString("%e.errors.json", ep_shownSession );
							fileLocation := formatString("%e.errors", ep_shownSession );
						
							! we store the location of the file in string parameter sp_FinalLocation
							sp_finalLocation := webui::GetIOFilePath(fileLocation);
						
							! writing the string parameter FinalLocation to a text file
							sp_shownSessionDescription := sp_sessionGivenDescriptions( ep_shownSession );
							block where single_column_display := 1;
								write Shown_session_data_exchange to file sp_finalLocation ;
							endblock ;
							! pr_writeErrorDataToJSONFile( sp_finalLocation );
						
							! checking if the previous write statement was successful or not
							if FileExists(sp_finalLocation) then
						
								! if successful, statusCode is set to 'CREATED' which will trigger the download widget to show the Get button
								StatusCode := webui::ReturnStatusCode('CREATED');
								! displaying the status message as All perfect instead of the default "File ready to download"
								StatusDescription := "All perfect!";
						
							else    !if previous write statement was not successful
						
								! setting the statusCode to 'ERROR' and the download widget will not show the Get button anymore
								statusCode := webui::ReturnStatusCode('ERROR');
								!displaying a custom error message
								statusDescription := "Something went wrong when creating the file.";
						
							endif;
						
						onerror ep_err do
						
							gss::pr_appendError(ep_err);
							gss::pr_uploadDownloadWidgetErrorHandling( ep_err, ep_stat, statusCode, statusDescription); 
						
							errh::MarkAsHandled(ep_err);
						
						endblock ;
					}
					StringParameter fileLocation {
						Property: Output;
					}
					Parameter statusCode {
						Property: Output;
					}
					StringParameter statusDescription {
						Property: Output;
					}
					StringParameter sp_finalLocation;
					ElementParameter ep_stat {
						Range: errh::AllErrorSeverities;
					}
					ElementParameter ep_err {
						Range: errh::PendingErrors;
					}
				}
				Procedure pr_downloadErrorReport {
					Arguments: (fileLocation,statusCode,statusDescription);
					Body: {
						block 
							gss::pr_initErrorHandlingDownloadUploadButtons( ep_stat, statusCode,  statusDescription, bp_download:1 );
						
							fileLocation := "usage.errorLogging";
						
							! we store the location of the file in string parameter FinalLocation
							sp_finalLocation := webui::GetIOFilePath(fileLocation);
						
							! writing the string parameter FinalLocation to a text file
							pr_reportCurrentErrorsToTextFile( sp_finalLocation );
						
							! checking if the previous write statement was successful or not
							if FileExists(sp_finalLocation) then
						
								! if successful, statusCode is set to 'CREATED' which will trigger the download widget to show the Get button
								StatusCode := webui::ReturnStatusCode('CREATED');
								! displaying the status message as All perfect instead of the default "File ready to download"
								StatusDescription := "All perfect!";
						
							else    !if previous write statement was not successful
						
								! setting the statusCode to 'ERROR' and the download widget will not show the Get button anymore
								statusCode := webui::ReturnStatusCode('ERROR');
								!displaying a custom error message
								statusDescription := "Something went wrong when creating the file.";
						
							endif;
						
						onerror ep_err do
						
							gss::pr_appendError(ep_err);
							gss::pr_uploadDownloadWidgetErrorHandling( ep_err, ep_stat, statusCode, statusDescription); 
						
							errh::MarkAsHandled(ep_err);
						
						endblock ;
					}
					StringParameter fileLocation {
						Property: Output;
					}
					Parameter statusCode {
						Property: Output;
					}
					StringParameter statusDescription {
						Property: Output;
					}
					StringParameter sp_finalLocation;
					ElementParameter ep_err {
						Range: errh::PendingErrors;
					}
					ElementParameter ep_stat {
						Range: errh::AllErrorSeverities;
					}
				}
				Procedure pr_reportCurrentErrorsToTextFile {
					Arguments: (sp_filename);
					Body: {
						block where listing_page_width := 32000 ;
							f_out.pagewidth := 32000 ;
							put f_out;
							for i_jobErrorMessageNumber | sp_shownJobErrorMessages(i_jobErrorMessageNumber) do
								put     ep_shownJobErrorSeverity(i_jobErrorMessageNumber), " ", 
									sp_shownJobErrorMoments( i_jobErrorMessageNumber), " : ",
									sp_shownJobErrorMessages(i_jobErrorMessageNumber), / ;
								for i_stackPosition | p_shownJobErrorLines(i_jobErrorMessageNumber, i_stackPosition) do
									put "    ", p_shownJobErrorLines(i_jobErrorMessageNumber, i_stackPosition):4:0, 
									" : ", ep_shownJobErrorNodes(i_jobErrorMessageNumber, i_stackPosition):0, / ;
								endfor ;
								put / ;
							endfor ;
							putclose ;
						endblock ;
					}
					StringParameter sp_filename {
						Property: Input;
					}
					File f_out {
						Name: sp_filename;
						Device: Disk;
						Mode: replace;
					}
				}
				Procedure pr_describeTrackedSession {
					Arguments: (sp_session,sp_descr);
					Body: {
						if not sp_session then
							raise error "gss::pr_describeTrackedSession(): sp_session not specified" ;
						endif ;
						
						ep_locTrackedSession := StringToElement( s_trackedSessions , sp_session, create:1 );
						
						sp_sessionGivenDescriptions( ep_locTrackedSession ) := sp_descr ;
					}
					StringParameter sp_session {
						Property: Input;
					}
					StringParameter sp_descr {
						Property: Input;
					}
					ElementParameter ep_locTrackedSession {
						Range: s_trackedSessions;
					}
				}
			}
			Section Data_session {
				Property: NoSave;
				DeclarationSection dataSessionProfilerErrorData {
					ElementParameter ep_dataSessionIncident {
						Range: s_jobErrorMessageNumbers;
					}
					Parameter p_dataSessionProfilerData {
						IndexDomain: (IndexIdentifiers,i_lineNumber,IndexProfilerTypes );
						InitialData: data{};
					}
					StringParameter sp_dataSessionErrorMessages {
						IndexDomain: i_dataSessionErrorMessageNumber;
						InitialData: data{};
					}
					StringParameter sp_dataSessionErrorMoments {
						IndexDomain: i_dataSessionErrorMessageNumber;
						InitialData: data{};
					}
					ElementParameter ep_dataSessionErrorSeverity {
						IndexDomain: i_dataSessionErrorMessageNumber;
						Range: s_messageLevels;
						InitialData: data{};
					}
					ElementParameter ep_dataSessionErrorNodes {
						IndexDomain: (i_dataSessionErrorMessageNumber,i_stackPosition);
						Range: AllSymbols;
						InitialData: data {};
					}
					ElementParameter ep_dataSessionErrorAttributes {
						IndexDomain: (i_dataSessionErrorMessageNumber,i_stackPosition);
						Range: AllAttributeNames;
						InitialData: data {};
					}
					Parameter p_dataSessionErrorLines {
						IndexDomain: (i_dataSessionErrorMessageNumber,i_stackPosition);
						InitialData: data {};
					}
				}
				DeclarationSection data_session_summary {
					Parameter p_noLogMessages {
						InitialData: 0;
					}
					Parameter p_noWarnings {
						InitialData: 0;
					}
					Parameter p_noErrors {
						InitialData: 0;
					}
				}
				Procedure pr_collectProfilerData {
					Body: {
						ProfilerCollectAllData(
							ProfilerData       :  p_dataSessionProfilerData, 
							GrossTimeThreshold :  0, 
							NetTimeThreshold   :  0);
					}
				}
				Procedure pr_dataSessionClearErrors {
					Body: {
						empty dataSessionProfilerErrorData;
						p_noLogMessages := 0 ;
						p_noWarnings := 0 ;
						p_noErrors := 0 ;
					}
				}
				Procedure pr_appendErrorDataSession {
					Arguments: (ep_err,sp_prefix);
					Body: {
						! Increase the number of recorded error messages.
						pr_newIncidentDataSession();
						
						ep_jobErrorMessageNumber := ep_dataSessionIncident ;
						
						sp_msg := sp_prefix + errh::Message( ep_err);
						
						! Record the message and severity.
						sp_dataSessionErrorMessages(ep_JobErrorMessageNumber) := sp_msg;
						sp_dataSessionErrorMoments( ep_jobErrorMessageNumber) := errh::CreationTime(ep_err,"%c%y-%m-%d %H:%M:%S:%T%TZ('local')");
						ep_dataSessionErrorSeverity(ep_jobErrorMessageNumber) := ep_errorToMessageLevelMap(errh::Severity(ep_err));
						
						! Record the entire stack of error positions
						p_errStackHeight := errh::NumberOfLocations(ep_err);
						p_errStackPos := 1 ;
						while p_errStackPos <= p_errStackHeight do
							ep_stackPosition := p_errStackPos;
							ep_dataSessionErrorNodes(ep_jobErrorMessageNumber,ep_stackPosition) := errh::Node(ep_err,ep_stackPosition);
							ep_dataSessionErrorAttributes(ep_jobErrorMessageNumber,ep_stackPosition) := errh::attribute(ep_err,ep_stackPosition);
							p_dataSessionErrorLines( ep_jobErrorMessageNumber,ep_stackPosition) := errh::Line(ep_err,ep_stackPosition);
							p_errStackPos += 1 ;
						endwhile ;
						
						if errh::Severity(ep_err) = 'warning' then
							p_noWarnings += 1 ;
						else
							p_NoErrors += 1 ;
						endif ;
					}
					Comment: "Store the error in the data structures of the library.";
					ElementParameter ep_err {
						Range: errh::PendingErrors;
						Property: Input;
					}
					Parameter p_errStackHeight;
					Parameter p_errStackPos;
					ElementParameter ep_stackPosition {
						Range: s_stackPositions;
					}
					ElementParameter ep_jobErrorMessageNumber {
						Range: s_jobErrorMessageNumbers;
					}
					StringParameter sp_prefix {
						Property: Optional;
					}
					StringParameter sp_msg;
				}
				Procedure pr_appendMessageDataSession {
					Arguments: (sp_msg,ep_lev);
					Body: {
						! Increase the number of recorded error messages.
						pr_newIncidentDataSession();
						ep_jobErrorMessageNumber := ep_dataSessionIncident;
						
						! Record the message and severity.
						sp_dataSessionErrorMessages(ep_jobErrorMessageNumber) := sp_msg;
						sp_dataSessionErrorMoments( ep_jobErrorMessageNumber) := CurrentToString("%c%y-%m-%d %H:%M:%S:%T");
						ep_dataSessionErrorSeverity(ep_jobErrorMessageNumber) := ep_lev;
						
						! Record the entire stack of error positions
						p_errStackHeight := callerNumberOfLocations();
						p_errStackPos := 1 ;
						while p_errStackPos <= p_errStackHeight do
							ep_stackPosition := p_errStackPos;
							ep_dataSessionErrorNodes(     ep_jobErrorMessageNumber,ep_stackPosition) := callerNode(     ep_stackPosition);
							ep_dataSessionErrorAttributes(ep_jobErrorMessageNumber,ep_stackPosition) := callerAttribute(ep_stackPosition);
							p_dataSessionErrorLines(      ep_jobErrorMessageNumber,ep_stackPosition) := callerLine(     ep_stackPosition);
							p_errStackPos += 1 ;
						endwhile ;
						
						p_noLogMessages += 1 ;
					}
					Comment: "Store the error in the data structures of the library.";
					Parameter p_errStackHeight;
					Parameter p_errStackPos;
					ElementParameter ep_stackPosition {
						Range: s_stackPositions;
					}
					ElementParameter ep_jobErrorMessageNumber {
						Range: s_jobErrorMessageNumbers;
					}
					StringParameter sp_msg {
						Property: Input;
					}
					ElementParameter ep_lev {
						Range: s_messageLevels;
						Default: 'info';
						Property: Optional;
					}
				}
			}
			Section Guard_server_session {
				DeclarationSection serverSessionErrorData {
					ElementParameter ep_jobIncident {
						Range: s_jobErrorMessageNumbers;
					}
					StringParameter sp_serverSessionId;
					Parameter p_jobProfilerData {
						IndexDomain: (IndexIdentifiers,i_lineNumber,IndexProfilerTypes );
						InitialData: data {};
					}
					StringParameter sp_jobErrorMessages {
						IndexDomain: i_jobErrorMessageNumber;
					}
					StringParameter sp_jobErrorMoments {
						IndexDomain: i_jobErrorMessageNumber;
					}
					ElementParameter ep_jobErrorSeverity {
						IndexDomain: i_jobErrorMessageNumber;
						Range: s_messageLevels;
					}
					ElementParameter ep_jobErrorNodes {
						IndexDomain: (i_jobErrorMessageNumber,i_stackPosition);
						Range: AllSymbols;
					}
					ElementParameter ep_jobErrorAttributes {
						IndexDomain: (i_jobErrorMessageNumber,i_stackPosition);
						Range: AllAttributeNames;
					}
					Parameter p_jobErrorLines {
						IndexDomain: (i_jobErrorMessageNumber,i_stackPosition);
					}
				}
				Procedure pr_guardAndProfileServerJob {
					Arguments: (ep_work);
					Body: {
						block
							empty serverSessionErrorData ;
							sp_serverSessionId := sp_thisSession ;
							pro::management::LocalLogInfo("pr_guardAndProfileServerJob(): sp_serverSessionId = " + sp_serverSessionId );
						
							! Ensure that the error recorded and profiler data are transmitted via the output case:
							pro::ManagedSessionOutputCaseIdentifierSet += serverSessionErrorData ;
						
							! Actual work.
							apply( ep_work);
						
							! Ensure that the definitions of all defined sets and defined parameters in 
							! output case identifier set are profiled.
							update pro::ManagedSessionOutputCaseIdentifierSet;
						
						onerror ep_err do
						
							pr_appendError( ep_err );
						
							! Don't let the server job be halted by this error; 
							! we still want the result case including the profiled data.
							errh::MarkAsHandled(ep_err);
						
						endblock ;
						ProfilerCollectAllData(
							ProfilerData       :  p_jobProfilerData, 
							GrossTimeThreshold :  0, 
							NetTimeThreshold   :  0);
						
						pr_saveModelLogFile();
					}
					Comment: {
						"!sp_thisSession
						!gss::sp_serverSessionId"
					}
					ElementParameter ep_err {
						Range: errh::PendingErrors;
					}
					ElementParameter ep_work {
						Range: AllProcedures;
						Default: 'gss::pr_sampleProc';
						Property: Input;
					}
				}
				Procedure pr_appendErrorJob {
					Arguments: (ep_err,sp_prefix);
					Body: {
						! Increase the number of recorded error messages.
						pr_newIncidentJob();
						ep_jobErrorMessageNumber := ep_jobIncident;
						
						sp_msg := sp_prefix + errh::Message( ep_err);
						
						! Record the message and severity.
						sp_jobErrorMessages(ep_JobErrorMessageNumber) := sp_msg;
						sp_jobErrorMoments( ep_jobErrorMessageNumber) := errh::CreationTime(ep_err,"%c%y-%m-%d %H:%M:%S:%T%TZ('local')");
						ep_jobErrorSeverity(ep_jobErrorMessageNumber) := ep_errorToMessageLevelMap(errh::Severity(ep_err));
						
						! Record the entire stack of error positions
						p_errStackHeight := errh::NumberOfLocations(ep_err);
						p_errStackPos := 1 ;
						while p_errStackPos <= p_errStackHeight do
							ep_stackPosition := p_errStackPos;
							ep_jobErrorNodes(ep_jobErrorMessageNumber,ep_stackPosition) := errh::Node(ep_err,ep_stackPosition);
							ep_JobErrorAttributes(ep_jobErrorMessageNumber,ep_stackPosition) := errh::attribute(ep_err,ep_stackPosition);
							p_jobErrorLines( ep_jobErrorMessageNumber,ep_stackPosition) := errh::Line(ep_err,ep_stackPosition);
							p_errStackPos += 1 ;
						endwhile ;
						
						if errh::Severity(ep_err) = 'warning' then
							p_noWarnings += 1 ;
						else
							p_NoErrors += 1 ;
						endif ;
					}
					Comment: "Store the error in the data structures of the library.";
					ElementParameter ep_err {
						Range: errh::PendingErrors;
						Property: Input;
					}
					Parameter p_errStackHeight;
					Parameter p_errStackPos;
					ElementParameter ep_stackPosition {
						Range: s_stackPositions;
					}
					ElementParameter ep_jobErrorMessageNumber {
						Range: s_jobErrorMessageNumbers;
					}
					StringParameter sp_prefix {
						Property: Optional;
					}
					StringParameter sp_msg;
				}
				Procedure pr_appendMessageJob {
					Arguments: (sp_msg,ep_lev);
					Body: {
						! Increase the number of recorded error messages.
						pr_newIncidentJob();
						ep_jobErrorMessageNumber := ep_jobIncident ;
						
						! Record the message and severity.
						sp_jobErrorMessages(ep_jobErrorMessageNumber) := sp_msg;
						sp_jobErrorMoments( ep_jobErrorMessageNumber) := CurrentToString("%c%y-%m-%d %H:%M:%S:%T");
						ep_jobErrorSeverity(ep_jobErrorMessageNumber) := ep_lev;
						
						! Record the entire stack of error positions
						p_errStackHeight := callerNumberOfLocations();
						p_errStackPos := 1 ;
						while p_errStackPos <= p_errStackHeight do
							ep_stackPosition := p_errStackPos;
							ep_jobErrorNodes(     ep_jobErrorMessageNumber,ep_stackPosition) := callerNode(     ep_stackPosition);
							ep_JobErrorAttributes(ep_jobErrorMessageNumber,ep_stackPosition) := callerAttribute(ep_stackPosition);
							p_jobErrorLines(      ep_jobErrorMessageNumber,ep_stackPosition) := callerLine(     ep_stackPosition);
							p_errStackPos += 1 ;
						endwhile ;
						
						p_noLogMessages += 1 ;
					}
					Comment: "Store the error in the data structures of the library.";
					Parameter p_errStackHeight;
					Parameter p_errStackPos;
					ElementParameter ep_stackPosition {
						Range: s_stackPositions;
					}
					ElementParameter ep_jobErrorMessageNumber {
						Range: s_jobErrorMessageNumbers;
					}
					StringParameter sp_msg {
						Property: Input;
					}
					ElementParameter ep_lev {
						Range: s_messageLevels;
						Default: 'info';
						Property: Optional;
					}
				}
			}
		}
		Section Inspect_state_session {
			Procedure pr_saveState {
				Arguments: (sp_label,s_selectedIdentifiers);
				Body: {
					
					Block ! Determine the subset of identifiers that actually have data to be written to file.
						s_selectedIdentifiersWithData := { i_someId |
							( i_someId in AllSets ) or
							( i_someId in AllParameters ) or
							( i_someId in AllVariables ) or
							( i_someId in AllConstraints ) };
						if not card( s_selectedIdentifiersWithData ) then
							raise warning "No data output from gss::SaveState, as no identifier contains data" ;
							return 0;
						endif ;
					endblock ;
					
					Block ! Materials will be written first to a subfolder of the project folder.  Ensure this intermediate folder exists.
						if  not directoryExists( sp_label ) then
							directoryCreate( sp_label );
						endif ;
					endblock ;
					
					block ! Ensure PRO is connected, initialized, and the PRO Storage folder exists that will contain all text output files
						if pro::GetPROEndPoint() then
							pro::Initialize();
							sp_slash := "/" ;
							sp_proStorageFolderName := "/Userdata/" + 
								pro::GetPROEnvironment() + sp_slash + 
								pro::GetPROUserName()    + sp_slash + 
								pro::ModelName           + sp_slash + 
								pro::modelversion        + sp_slash + 
								sp_label ;
							pr_ensurePath( sp_proStorageFolderName );
						endif ;
					endblock ;
					
					block ! Each data identifier to be written to file is written to a separate file.
						where single_column_display := 1, listing_number_precision := 12, listing_number_width := 20 ;
						for i_someIdWithData do
							s_singleTonSet := {};
							s_singleTonSet += i_someIdWithData ;
							sp_filename := spfnc_fileFriendlyName( i_someIdWithData );
							sp_fullFilename := sp_label + "\\" + sp_filename;
							write s_singleTonSet to file sp_fullFilename ;
							if pro::GetPROEndPoint() then
								sp_proStorageFileName := sp_proStorageFolderName + sp_slash + sp_filename ;
								pro::SaveFileToCentralStorage(
									localPath     :  sp_fullFilename, 
									storagePath   :  sp_proStorageFileName);
							endif ;
						endfor ;
					endblock ;
				}
				StringParameter sp_proStorageFolderName;
				StringParameter sp_proStorageFileName;
				StringParameter sp_slash;
				Set s_selectedIdentifiers {
					SubsetOf: AllSymbols;
					Index: i_someId;
					Property: Input;
				}
				Set s_selectedIdentifiersWithData {
					SubsetOf: AllIdentifiers;
					Index: i_someIdWithData;
				}
				Set s_singleTonSet {
					SubsetOf: AllIdentifiers;
				}
				StringParameter sp_label {
					Property: Input;
				}
				StringParameter sp_filename;
				StringParameter sp_fullFilename;
			}
		}
		Section Logging {
			Property: NoSave;
			StringParameter sp_traceFilename {
				InitialData: "logging.txt";
			}
			StringParameter sp_downloadModelLogTitle {
				Definition: formatString("Download model log file of shown session %e", gss::ep_shownSession);
			}
			Procedure pr_openPageErrorWarningProfiler {
				Body: {
					ep_shownSession := first( s_trackedSessions );
					
					ProfilerCollectAllData(
						ProfilerData       :  p_dataSessionProfilerData, 
						GrossTimeThreshold :  0, 
						NetTimeThreshold   :  0);
					
					p_trackedJobProfilerData(ep_shownSession, IndexIdentifiers, i_lineNumber, IndexProfilerTypes) := p_dataSessionProfilerData(IndexIdentifiers, i_lineNumber, IndexProfilerTypes);
					sp_trackedJobErrorMessages(ep_shownSession, i_jobErrorMessageNumber) := sp_dataSessionErrorMessages(i_jobErrorMessageNumber);
					sp_trackedJobErrorMoments(ep_shownSession, i_jobErrorMessageNumber) := sp_dataSessionErrorMoments(i_jobErrorMessageNumber);
					ep_trackedJobErrorSeverity(ep_shownSession, i_jobErrorMessageNumber) := ep_dataSessionErrorSeverity(i_jobErrorMessageNumber);
					ep_trackedJobErrorNodes(ep_shownSession, i_jobErrorMessageNumber, i_stackPosition) := ep_dataSessionErrorNodes(i_jobErrorMessageNumber, i_stackPosition);
					ep_trackedJobErrorAttributes(ep_shownSession, i_jobErrorMessageNumber, i_stackPosition) := ep_dataSessionErrorAttributes(i_jobErrorMessageNumber, i_stackPosition);
					p_trackedJobErrorLines(ep_shownSession, i_jobErrorMessageNumber, i_stackPosition) := p_dataSessionErrorLines(i_jobErrorMessageNumber, i_stackPosition);
					
					pr_uponChangeShownSession();
				}
			}
			Procedure pr_logMsgTraceFile {
				Arguments: (sp_argMsg,ep_lev);
				Body: {
					!if ep_lev >= ep_tracinglevel then
						if pro::GetPROEndPoint() then
							pro::management::LocalLogInfo("pr_logMsgTraceFile(): sp_traceFilename = " + sp_traceFilename + " sp_argMsg = " + sp_argMsg );
						endif ;
						put f_traceFile ;
						put sp_argMsg, / ;
						putclose ;
						p_noLogLinesWritten += 1 ;
					!endif ;
					!
				}
				Comment: {
					"Trace to the log file; this procedure should not be called before PostLibraryInitialization finished."
				}
				StringParameter sp_argMsg {
					Property: Input;
				}
				ElementParameter ep_lev {
					Range: s_messageLevels;
					Default: 'trace';
					Property: Optional;
				}
			}
			Procedure pr_logMsg {
				Arguments: (sp_msg,ep_lev);
				Body: {
					!if ep_lev >= ep_tracingLevel then
					!	if bp_loggingToFile then
							pr_logMsgTraceFile(sp_msg,ep_lev);
					!	else
					!		switch ep_lev do
					!			'error', 'warn': 
					!				pro::management::LocalLogError( sp_msg );
					!			'info': 
					!				pro::management::LocalLogInfo( sp_msg );
					!			'debug': 
					!				pro::management::LocalLogDebug( sp_msg );
					!			'trace': 
					!				pro::management::LocalLogTrace( sp_msg );
					!			default:
					!				raise warning "Unknown message level: " + ep_lev ;
					!				pro::management::LocalLogInfo( sp_msg );
					!		endswitch ;
					!	endif ;
					!endif ;
					!
				}
				Comment: {
					"Trace to the log file; this procedure should not be called before PostLibraryInitialization finished."
				}
				StringParameter sp_msg {
					Property: Input;
				}
				ElementParameter ep_lev {
					Range: s_messageLevels;
					Default: 'trace';
					Property: Optional;
				}
			}
			Procedure pr_enter {
				Arguments: (sp_procEnterTimestamp,p_procEnterMemoryInUse,sp_procEnterContextMessage);
				Body: {
					sp_procEnterTimestamp := CurrentToString("%c%y-%m-%d %H:%M:%S:%t%TZ('UTC')");
					p_procEnterMemoryInUse := MemoryInUse();
					sp_node := formatString("%e",CallerNode(1));
					sp_fullMsg := formatString("Enter %s(%s) at %s [%.3n Mb] in use", 
						sp_node, sp_procEnterContextMessage, 
						MomentToString(
							Format        :  "%c%y-%m-%d %H:%M:%S:%t%TZ(gss::ep_traceTimezone)", 
							unit          :  [s], 
							ReferenceDate :  sp_procEnterTimestamp, 
							Elapsed       :  0[s]), 
						p_procEnterMemoryInUse );
					pr_logMsg( sp_fullMsg, 'debug' );
				}
				Comment: {
					"Trace entry of procedure to the log file; this procedure should not be called before PostLibraryInitialization finished."
				}
				StringParameter sp_procEnterTimestamp {
					Property: InOut;
				}
				Parameter p_procEnterMemoryInUse {
					Property: InOut;
				}
				StringParameter sp_procEnterContextMessage {
					Property: Optional;
					Comment: {
						"If the traced procedure contains arguments, 
						you may want to summarize these arguments here."
					}
				}
				StringParameter sp_node;
				StringParameter sp_fullMsg;
				StringParameter sp_proc;
			}
			Procedure pr_leave {
				Arguments: (sp_procEnterTimestamp,p_procEnterMemoryInUse,sp_msg);
				Body: {
					sp_leavingTime := CurrentToString("%c%y-%m-%d %H:%M:%S:%t%TZ('UTC')");
					p_duration := StringToMoment(
						Format        :  "%c%y-%m-%d %H:%M:%S:%t%TZ('UTC')", 
						Unit          :  [s], 
						ReferenceDate :  sp_procEnterTimestamp, 
						Timeslot      :  sp_leavingTime);
					sp_node := formatString("%e",CallerNode(1));
					p_leaveMemoryInUse := MemoryInUse();
					sp_fullMsg := 
						formatString( "Leave %s(%s) at %s [%.3n Mb] in use. ",
							sp_node, sp_msg, 
							MomentToString(
								Format        :  "%c%y-%m-%d %H:%M:%S:%t%TZ(gss::ep_traceTimezone)", 
								unit          :  [s], 
								ReferenceDate :  sp_leavingTime, 
								Elapsed       :  0[s]), 
							p_leaveMemoryInUse ) +
						formatString( "Duration is %.3n [seconds] and memory %s is %n Mb.", 
							p_duration,
							if p_leaveMemoryInUse >= p_procEnterMemoryInUse then "increase" else "decrease" endif, 
							abs( p_leaveMemoryInUse - p_procEnterMemoryInUse ) );
					pr_logMsg( sp_fullMsg, 'debug' );
				}
				Comment: {
					"Trace leaving of procedure to the log file; this procedure should not be called before PostLibraryInitialization finished."
				}
				Parameter p_procEnterMemoryInUse {
					Property: Input;
				}
				StringParameter sp_procEnterTimestamp {
					Property: Input;
				}
				StringParameter sp_leavingTime;
				Parameter p_duration {
					Unit: s;
				}
				Parameter p_leaveMemoryInUse;
				StringParameter sp_msg {
					Property: Optional;
				}
				StringParameter sp_node;
				StringParameter sp_fullMsg;
			}
			Procedure pr_saveModelLogFile {
				Body: {
					sp_slash := "/" ;
					sp_proStorageFolderName := sp_slash + "Userdata" + sp_slash + 
						pro::GetPROEnvironment() + sp_slash + 
						pro::GetPROUserName()    + sp_slash + 
						pro::ModelName           + sp_slash + 
						pro::modelversion        ;
					pr_ensurePath( sp_proStorageFolderName );
					
					pr_actuallySaveModelLogFile( sp_traceFilename, sp_proStorageFolderName );
				}
				StringParameter sp_proStorageFileName;
				StringParameter sp_proStorageFolderName;
				StringParameter sp_slash;
			}
			Procedure pr_setTracingLevel {
				Arguments: (ep_newLev);
				Body: {
					ep_tracinglevel := ep_newLev;
				}
				ElementParameter ep_newLev {
					Range: s_messageLevels;
					Property: Input;
				}
			}
			Procedure pr_setLoggingToModelLog {
				Arguments: (bp_ltf);
				Body: {
					bp_loggingToFile := bp_ltf ;
				}
				Parameter bp_ltf {
					Range: binary;
					Property: Input;
				}
			}
			Procedure pr_downloadModelLog {
				Arguments: (FileLocation,StatusCode,StatusDescription);
				Body: {
					Block
						!FileLocation := "circle.png";
						sp_slash := "/" ;
						if ep_shownSession <> first( s_trackedSessions ) then
							! The first tracked session is the data session.
							! The other session, are server sessions, and they are stored
							! in /Userdata/<env>/<user>/<model>/<ver>/tracings" + 
							sp_proStorageFilename := sp_slash + "Userdata" + sp_slash + 
								pro::GetPROEnvironment() + sp_slash + 
								pro::GetPROUserName()    + sp_slash + 
								pro::ModelName           + sp_slash + 
								pro::modelversion        + sp_slash + 
								"tracings"               + sp_slash + 
								ep_shownSession          + ".modelLog";
							sp_localTraceFilename := "tracings" + sp_slash + ep_shownSession + ".modelLog" ;
							! Copy the .modelLog file from AIMMS PRO storage to the folder "tracings".
							pro::RetrieveFileFromCentralStorage(
								storagePath :  sp_proStorageFilename, 
								localPath   :  sp_localTraceFilename);
						else
							sp_localTraceFilename := sp_traceFilename ;
						endif ;
						p_slashFwd := FindNthString( sp_localTraceFilename, "/", -1 );
						p_slashBwd := FindNthString( sp_localTraceFilename, "\\", -1 );
						p_slash := max( p_slashFwd, p_slashBwd);
						if p_slash then
							p_len := StringLength( sp_localTraceFilename );
							fileLocation := SubString( sp_localTraceFilename, p_slash+1, p_len); 
							FileCopy( sp_localTraceFilename, fileLocation );
						else
							fileLocation := sp_localTraceFilename;
						endif ;
						if pro::GetPROEndPoint() then
							pro::management::LocalLogInfo("pr_downloadModelLog(): fileLocation = " + fileLocation);
						endif ;
						sp_fullFileLocation := webui::GetIOFilePath(FileLocation);
						if pro::GetPROEndPoint() then
							pro::management::LocalLogInfo("pr_downloadModelLog(): sp_fullFileLocation = " + sp_fullFileLocation);
						endif ;
						if FileLocation <> sp_fullFileLocation then
							FileCopy( FileLocation, sp_fullFileLocation );
						endif ;
					
						StatusCode := webui::ReturnStatusCode('CREATED');
						StatusDescription := "Nice.";
					OnError ep_err Do
						if errh::Severity( ep_err ) <> 'warning' then
							StatusCode := webui::ReturnStatusCode('ERROR');
							StatusDescription := "Oops: " + errh::Message(ep_err) ;
							errh::MarkAsHandled(ep_err);
							break ; ! Trick to reporting one error.
						endif ;
					EndBlock ;
				}
				StringParameter sp_proStorageFilename;
				StringParameter sp_localTraceFilename;
				StringParameter FileLocation {
					Property: Output;
				}
				Parameter StatusCode {
					Property: Output;
				}
				StringParameter StatusDescription {
					Property: Output;
				}
				StringParameter sp_fullFileLocation;
				ElementParameter ep_err {
					Range: errh::PendingErrors;
				}
				Parameter p_slashFwd;
				Parameter p_slashBwd;
				Parameter p_slash;
				Parameter p_len;
				StringParameter sp_slash;
			}
		}
	}
	Section Private_Section {
		Property: NoSave;
		Section Main_Library_procedures {
			Procedure LibraryInitialization {
				Body: {
					ep_jobIncident := '' ;
					ep_dataSessionIncident := '' ;
				}
				Comment: "Add initialization statements here that do not require any other library being initialized already.";
			}
			Procedure PostLibraryInitialization {
				Body: {
					CurrentInputs -=  serverSessionErrorData;
					
					pr_GetThisSession(); 
					
					
					block ! Initialize logging
						if pro::GetPROEndPoint() then
							if not pro::IsRunningAtServer() then
								ep_trackedSession := stringToElement( s_trackedSessions, sp_thisSession, create:1);
							endif ;
							if pro::management::IsRunningOnCloud() then
								! if DirectoryExists( "MainProject/WebUI" to be tested (WinUI apps might be ble to log to file version of session logs anyway).
								bp_loggingOnCloud := 1 ;
								bp_loggingToFile  := 1 ;
							else
								bp_loggingOnCloud := 0 ;
								bp_loggingToFile  := 1 ;
							endif ;
						else
							ep_trackedSession := stringToElement( s_trackedSessions, sp_thisSession, create:1);
							bp_loggingOnCloud := 0 ;
							bp_loggingToFile  := 1 ;
						endif ;
					
						if sp_thisSession then
							sp_traceFilename := sp_tracingsFoiderName + "/" + sp_thisSession + ".modelLog" ;
						endif ;
					
						if bp_loggingToFile then
							if not  DirectoryExists( sp_tracingsFoiderName ) then
								DirectoryCreate( sp_tracingsFoiderName );
							endif ;
							if fileExists( sp_traceFilename ) then
								FileDelete( sp_traceFilename );
							endif ;
						endif ;
					endblock ;
					pr_openLogFile();
					! log file of a week old are to be deleted
				}
				Comment: {
					"Add initialization statements here that require another library to be initialized already,
					or add statements that require the Data Management module to be initialized."
				}
				ElementParameter ep_trackedSession {
					Range: s_trackedSessions;
				}
			}
			Procedure PreLibraryTermination {
				Body: {
					!if pro::GetPROEndPoint() then
					!	pro::Initialize();
					!
					!	if pro::CurrentDelegationLevel() then ! Only for solver sessions.
					!
					!		if FileExists( sp_traceFilename ) then
					!
					!			pr_saveModelLogFile();
					!
					!		endif ;
					!
					!	endif ;
					!endif ;
					
					return 1;
				}
				Comment: {
					"Add termination statements here that require all other libraries to be still alive.
					Return 1 if you allow the termination sequence to continue.
					Return 0 if you want to cancel the termination sequence."
				}
			}
			Procedure LibraryTermination {
				Body: {
					return 1;
				}
				Comment: {
					"Add termination statements here that do not require other libraries to be still alive.
					Return 1 to allow the termination sequence to continue.
					Return 0 if you want to cancel the termination sequence.
					It is recommended to only use the procedure PreLibraryTermination to cancel the termination sequence and let this procedure always return 1."
				}
			}
		}
		Section Guard_utilities {
			Parameter bp_locSeenErrorsAreHandled {
				Range: binary;
				InitialData: 0;
			}
			Index i_errorSeverity {
				Range: errh::AllErrorSeverities;
			}
			ElementParameter ep_errorToMessageLevelMap {
				IndexDomain: i_errorSeverity;
				Range: s_messageLevels;
				Definition: data { 'severe' : 'fatal', 'error' : 'error', 'warning' : 'warn' };
			}
			Procedure pr_sampleProc {
				Body: {
					! Do not delete this procedure, it is used as default of element parameter gss::ep_Work.
				}
			}
			Procedure pr_writeErrorDataToJSONFile {
				Arguments: (sp_finalLocation);
				Body: {
					dex::AddMapping("JSONERRORmap","GuardServerSession/mappings/JSONErrors.xml");
					dex::WriteToFile(
						dataFile    :  sp_finalLocation, 
						mappingName :  "JSONERRORmap", 
						pretty      :  1);
				}
				StringParameter sp_finalLocation {
					Property: Input;
				}
			}
			Procedure pr_readErrorDataFromJSONFile {
				Arguments: (sp_finalLocation);
				Body: {
					dex::AddMapping("JSONERRORmap","GuardServerSession/mappings/JSONErrors.xml");
					dex::ReadFromFile(
						dataFile    	 :  sp_finalLocation, 
						mappingName 	 :  "JSONERRORmap", 
						emptyIdentifiers :  0, 
						emptySets        :  0, 
						resetCounters    :  1);
				}
				StringParameter sp_finalLocation {
					Property: Input;
				}
			}
			Procedure pr_newIncidentDataSession {
				Body: {
					if ep_dataSessionIncident then
						if ep_dataSessionIncident = last( s_jobErrorMessageNumbers ) then
							p_maxNoErrorsPerSession *= 2 ;		
						endif ;
						ep_dataSessionIncident += 1 ;
					else
						ep_dataSessionIncident := first( s_jobErrorMessageNumbers );
					endif;
				}
			}
			Procedure pr_newIncidentJob {
				Body: {
					if ep_jobIncident then
						if ep_jobIncident = last( s_jobErrorMessageNumbers ) then
							p_maxNoErrorsPerSession *= 2 ;		
						endif ;
						ep_jobIncident += 1 ;
					else
						ep_jobIncident := first( s_jobErrorMessageNumbers );
					endif;
				}
			}
		}
		Section Inspect_utilities {
			Procedure pr_ensurePath {
				Arguments: (sp_path);
				Body: {
					if not pr_proFolderExists( sp_path ) then
					        pro::CreateStorageFolder( sp_path );
					endif ;
				}
				StringParameter sp_path {
					Property: Input;
				}
			}
			Function spfnc_fileFriendlyName {
				Arguments: (ep_id);
				Range: string;
				Body: {
					sp_retVal := formatString("%e", ep_id );
					sp_retVal := FindReplaceStrings( sp_retVal, ":", "_" );
					
					spfnc_fileFriendlyName := sp_retVal ;
				}
				ElementParameter ep_id {
					Range: AllIdentifiers;
					Property: Input;
				}
				StringParameter sp_retVal;
			}
			Procedure pr_proFolderExists {
				Arguments: (sp_filepath);
				Body: {
					! proFolderExists, proDirectoryExists, FolderExists, DirectoryExists
					pro::NormalizeStoragePath(sp_filepath);
					p_ret := pro::storage::ListBuckets(
								path       :  sp_filepath, 
								BucketSet  :  s_locBucketSet, 
								BucketSize :  p_locBucketSize, 
								BucketAuth :  sp_locBucketAuth, 
								BucketDate :  sp_locBucketDate);
					return p_ret ;
				}
				StringParameter sp_filepath {
					Property: Input;
				}
				Parameter p_ret;
				Set s_locBucketSet {
					Index: bs;
				}
				Parameter p_locBucketSize {
					IndexDomain: bs;
				}
				StringParameter sp_locBucketAuth {
					IndexDomain: bs;
				}
				StringParameter sp_locBucketDate {
					IndexDomain: bs;
				}
			}
			Procedure pr_proFileExists {
				Arguments: (sp_filename);
				Body: {
					pro::NormalizeStoragePath(sp_filename);
					pro::SplitStoragePath(sp_filename,sp_storageBucketPath,sp_storageFileWithoutPath);
					if not pr_proFolderExists( sp_storageBucketPath ) then return 0 ; endif ;
					p_ret := pro::storage::GetObjectInfo(sp_storageBucketPath, sp_storageFileWithoutPath,
							sp_tmpLocalFileName, sp_tmpType, p_tmpNum, sp_tmpAuth, p_tmpVersion );
					if p_ret = 0 or p_tmpNum <= 0 then
						return 0 ;
					endif ;
					return 1 ;
				}
				Comment: {
					"d:\\u\\s\\aimms3\\deps\\vc120_x64_Debug\\Libraries\\AimmsWebUI\\AimmsWebUI.ams line 1600
					d:\\u\\s\\Customers\\K3 Delta\\Escalation March 2017\\6763\\UploadTool\\UploadTool\\UploadTool\\FileExistsFolderExists.ams line 40"
				}
				StringParameter sp_filename {
					Property: Input;
				}
				Parameter p_ret;
				StringParameter sp_storageBucketPath;
				StringParameter sp_storageFileWithoutPath;
				Parameter p_tmpNum;
				StringParameter sp_tmpLocalFileName;
				StringParameter sp_tmpType;
				StringParameter sp_tmpAuth;
				Parameter p_tmpVersion;
			}
			Function fnc_hasProPrefix {
				Arguments: (sp_filename);
				Range: binary;
				Body: {
					p_retval := 0 ;
					
					if Stringlength( sp_filename ) > 4 then
						if findstring( substring( sp_filename, 1, 4 ), "pro:", CaseSensitive:0 ) then
							p_retval := 1 ;
						else
							p_retval := 0 ;
						endif ;
					else
						p_retval := 0 ;
					endif ;
					
					fnc_hasProPrefix := p_retval ;
				}
				StringParameter sp_filename {
					Property: Input;
				}
				Parameter p_retval {
					Range: binary;
				}
			}
		}
		Section Logging_utilities {
			Procedure pr_openLogFile {
				Body: {
					f_traceFile.pagewidth := 32000 ;
					putclose f_traceFile ;
					put f_traceFile;
					put "Opening log file ", sp_traceFilename, " at ", CurrentToSTring("%c%y-%m-%d %H:%M:%S"), / ;
					if pro::GetPROEndPoint() then
						if pro::openedAsWorker then
							put "This file contains the log of a data session on behalf of ", 
								pro::GetPROUserName(), "@", pro::GetPROEnvironment(), / ;
						else
							put "This file contains the log of a solver session handling request ", 
								pro::workerRequestDescription, / ;
						endif ;
					else
						put "This file contains the log of an AIMMS Developer session ", / ;
					endif ;
					putclose ;
					!gss::pr_setTracingLevel('trace'); ! Force all logging.
				}
			}
			Procedure pr_GetThisSession {
				Body: {
					if pro::GetPROEndPoint() then
						if pro::ReadArguments('_pro-webui-session-id') then
							sp_thisSession := pro::ReadArguments('_pro-webui-session-id');
					
						else
							sp_thisSession := pro::ReadArguments('_pro-session-id');
						endif ;
					else
						sp_thisSession := CurrentToString("%c%y%m%dT%H%M%S%t%TZ('UTC')");
					endif ;
				}
				Comment: {
					"Get a unique identifier for this session. 
					Whenever possible, align with AIMMS PRO - to make matching with AIMMS PRO generated logging information easier."
				}
			}
			Procedure pr_actuallySaveModelLogFile {
				Arguments: (sp_fn,sp_folder);
				Body: {
					sp_slash := "/" ;
					if fileExists( sp_fn ) then
						sp_proStorageFileName := sp_folder + sp_slash + sp_fn ;
						pro::SaveFileToCentralStorage(
							localPath     :  sp_fn, 
							storagePath   :  sp_proStorageFileName);
					else
						pro::management::LocalLogInfo(
							"pr_actuallySaveModelLogFile() sp_fn = " + 
							sp_fn + 
							" does not exist."
						);
					endif ;
				}
				StringParameter sp_fn {
					Property: Input;
				}
				StringParameter sp_folder {
					Property: Input;
				}
				StringParameter sp_slash;
				StringParameter sp_proStorageFileName;
			}
			Procedure pr_artificialDataGSSPage {
				Body: {
					block
						raise warning "Cry wolf" ;
					onerror ep_err do
						gss::pr_appendError(ep_err);
						errh::MarkAsHandled(ep_err);
					endblock ;
				}
				ElementParameter ep_err {
					Range: errh::PendingErrors;
				}
			}
			StringParameter sp_tracingsFoiderName {
				Definition: "tracings";
			}
			StringParameter sp_thisSession {
				InitialData: "this-session";
			}
			ElementParameter ep_tracinglevel {
				Range: s_messageLevels;
				InitialData: 'info';
			}
			Parameter p_noLogLinesWritten {
				InitialData: 0;
			}
			File f_traceFile {
				Name: sp_traceFilename;
				Device: Disk;
				Mode: merge;
			}
			ElementParameter ep_traceTimezone {
				Range: AllTimeZones;
				InitialData: {
					'LocalDST'
					! 'UTC'
				}
			}
			Parameter bp_loggingOnCloud {
				Range: binary;
				InitialData: 0;
			}
			Parameter bp_loggingToFile {
				Range: binary;
				InitialData: 1;
				Comment: {
					"Both vi AIMMS Developer, and when running in the cloud, this binary will be initialized to 1.
					0 otherwise."
				}
			}
		}
	}
}
