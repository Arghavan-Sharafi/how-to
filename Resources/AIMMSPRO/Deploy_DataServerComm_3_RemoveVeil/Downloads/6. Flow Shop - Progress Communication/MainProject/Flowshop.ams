## ams_version=1.0

Model Main_Flow_Shop {
    Comment: {
        "Keywords:
        CallBackNewIncumbent, MIP model, Gantt chart, AsynchronousExecute, GMP."
    }
    Section WebUI_support {
        Set AllPublicIdentifiers {
            SubsetOf: AllIdentifiers;
            Definition: Main_Flow_Shop;
        }
        Section Loading_server_session_results {
            Property: NoSave;
            StringParameter spSavedRequestID {
                InitialData: "";
            }
            Parameter bpResultsAvailable {
                Range: binary;
                InitialData: 0;
            }
            Procedure myLoadResultsCallback {
                Arguments: (RequestID);
                Body: {
                    spSavedRequestID := RequestID;
                    bpResultsAvailable := 1;
                }
                StringParameter RequestID {
                    Property: Input;
                }
            }
            Procedure prLoadResults {
                Body: {
                    pro::session::LoadResultsCallBack(spSavedRequestID);
                    bpResultsAvailable := 0;
                    spSavedRequestID := "";
                }
            }
        }
        Section Gantt_Chart {
            Procedure prepInterface {
                Body: {
                    pGCJobStart(j,m)  := StartTime( first(s | JobSchedule(j,s)),m);
                    pGCJobDuration(j,m) := ProcesTime(j,m);
                }
            }
            Parameter noIncumbents {
                Property: NoSave;
            }
            Parameter pGCJobStart {
                IndexDomain: (j,m);
            }
            Parameter pGCJobDuration {
                IndexDomain: (j,m);
            }
            StringParameter JobDescription {
                IndexDomain: (j);
                Text: "Description of jobs that can be used inside the Gantt Chart";
                Definition: {
                    FormatString("J%i", ord(j));
                }
            }
            StringParameter MachineDescription {
                IndexDomain: (m);
                Text: "Description of machines that can be used inside the Gantt Chart";
                Definition: {
                    FormatString("M%i", ord(m));
                }
            }
        }
        Section GapCurves {
            Property: NoSave;
            Parameter pSolveInterruptable {
                InitialData: 1;
            }
            Set sObservations {
                Index: iObs;
                Parameter: epLastObservation;
            }
            Set sShownObservations {
                SubsetOf: sObservations;
                Index: iSobs;
                Definition: {
                    { iobs | ( pNoObservations <= ( 2 * pPointsShownInCurve ) ) or 
                             ( mod(ord(iobs), pDividerForPointSelection ) = 1 ) or 
                             ( iobs = last(sObservations)                     )    }
                }
            }
            Parameter pBestBound {
                IndexDomain: (iObs);
            }
            Parameter pIncumbent {
                IndexDomain: (iObs);
            }
            Parameter pPointsShownInCurve {
                InitialData: 30;
            }
            Parameter pDividerForPointSelection {
                Definition: {
                    if pNoObservations <= ( 2 * pPointsShownInCurve ) then
                    	1
                    else
                    	div( pNoObservations, pPointsShownInCurve )
                    endif
                }
            }
            Parameter pNoObservations {
                Definition: card(sObservations);
            }
            Parameter pProgressWillBeSupplied {
                InitialData: 1;
            }
            StringParameter spTitleGapCurve {
                InitialData: "Gap curve";
            }
            Procedure NewTimeCallback {
                Body: {
                    if pProgressWillBeSupplied then
                    	UpdateGapToClient(FlowShopModel.bestbound,FlowShopModel.Incumbent);
                    endif ;
                }
            }
            Procedure UpdateGapToClient {
                Arguments: (bb,icb);
                Body: {
                    if pro::GetPROEndPoint() then
                    	if pro::DelegateToClient(flags: pro::PROMFLAG_LIVE) then
                    		return 1; 
                    	endif ;
                    endif ;
                    if pSolveInterruptable then
                    	SetElementAdd( sObservations, epLastObservation, FormatString("%i", pNoObservations+1) );
                    	pBestBound(epLastObservation) := if mapval(bb ) then 0 else bb  endif ;
                    	pIncumbent(epLastObservation) := if mapval(icb) then 0 else icb endif ;
                    	if mapval(bb) or mapval(icb) then 
                    		gap := 100  ;
                    	else
                    		if bb then
                    			gap := ( ( icb - bb  ) / bb ) * 100 ;
                    		else
                    			gap := 0 ;
                    		endif ;
                    	endif ;
                    	spTitleGapCurve := FormatString("Gap curve: best: %n, incumbent: %n, gap: %n%%",
                    		bb, icb, gap );
                    endif ;
                }
                Parameter bb {
                    Property: Input;
                }
                Parameter icb {
                    Property: Input;
                }
                Parameter gap;
            }
        }
        Section Progress_Updating {
            Procedure NewIncumbentCallback {
                Body: {
                    empty JobSchedule;
                    
                    RetrieveCurrentVariableValues(AllVariables);
                    TimeSpan := FlowShopModel.Incumbent;
                    
                    prepInterface();
                    
                    UpdateIncumbentToClient(pGCJobStart(j,m),pGCJobDuration(j,m),Timespan);
                }
            }
            Procedure UpdateIncumbentToClient {
                Arguments: (js,jd,ts);
                Body: {
                    if pro::GetPROEndPoint() then
                    	if pro::DelegateToClient(flags: pro::PROMFLAG_LIVE) then
                    		return 1; 
                    	endif ;
                    endif ;
                    pGCJobStart(j,m)    := js(j,m) ;
                    pGCJobDuration(j,m) := jd(j,m) ;
                    Timespan            := ts ;
                    noIncumbents+=1 ;
                }
                Parameter js {
                    IndexDomain: (j,m);
                    Property: Input;
                }
                Parameter jd {
                    IndexDomain: (j,m);
                    Property: Input;
                }
                Parameter ts {
                    Property: Input;
                }
            }
        }
    }
    DeclarationSection Flowshop_Mathematical_Program_Declarations {
        Parameter MaxJobs {
            Text: "Number of elements in the set Jobs";
            Range: integer;
        }
        Set Jobs {
            Text: "Set of all Jobs";
            Index: j, j2;
            Definition: {
                ElementRange(1,MaxJobs, prefix: "Job-");
            }
        }
        Set Schedules {
            Text: "Set of all schedules";
            Index: s;
            Definition: {
                ElementRange(1,MaxJobs, prefix: "Pos-");
            }
        }
        Parameter MaxMachines {
            Text: "Number of elements in the set Machines";
            Range: integer;
        }
        Set Machines {
            Text: "Set of all machines";
            Index: m;
            Definition: {
                ElementRange(1,MaxMachines, prefix: "M-");
            }
        }
        Parameter ProcesTime {
            IndexDomain: (j,m);
            Text: "Time required to process job j on machine m";
        }
        Variable JobSchedule {
            IndexDomain: (j,s);
            Text: "Determining the place of the job";
            Range: binary;
        }
        Variable StartTime {
            IndexDomain: (s,m);
            Text: "The time at which job in schedule position s commences processing on machine m";
            Range: nonnegative;
        }
        Constraint OneJobPerSchedule {
            IndexDomain: (s);
            Text: "Only one job is related to every schedule";
            Definition: sum(j, JobSchedule(j,s)) = 1;
        }
        Constraint OneSchedulePerJob {
            IndexDomain: (j);
            Text: "Only one schedule is related to every job";
            Definition: sum(s, JobSchedule(j,s)) = 1;
        }
        Constraint MachineStartTime {
            IndexDomain: (s,m) | m <> last(Machines);
            Text: "The commencement of schedule s on machine m+1 is no earlier then its finish on machine m";
            Definition: StartTime(s,m + 1) >=  StartTime(s,m) + sum(j, ProcesTime(j,m)*JobSchedule(j,s));
        }
        Constraint ScheduleStartTime {
            IndexDomain: (s,m) | s <> last(Schedules);
            Text: "The commencement of schedule s + 1 on machine m is no earlier then the finish time of job j on machine m";
            Definition: StartTime(s + 1,m) >=  StartTime(s,m) + sum(j, ProcesTime(j,m)*JobSchedule(j,s));
        }
        Variable TimeSpan {
            Text: "Total time to process all jobs on all machines";
            Definition: StartTime(Last(s),last(m)) + sum(j, ProcesTime(j,last(m))*JobSchedule(j,Last(s)));
        }
        MathematicalProgram FlowShopModel {
            Objective: TimeSpan;
            Direction: minimize;
            Constraints: AllConstraints;
            Variables: AllVariables;
        }
    }
    Section MainModelProcedures {
        Procedure myExistsState {
            Body: {
                return 0 ;
            }
        }
        Procedure MyRestoreState;
        Procedure MySaveState;
        Procedure MainInitialization {
            Body: {
                webui::ExistsWebUIStateHook := 'MyExistsState';
                webui::RestoreWebUIStateHook := 'MyRestoreState';
                webui::SaveWebUIStateHook := 'MySaveState';
                
                
                MaxJobs 	:= 20;
                MaxMachines 	:= 30;
                
                GenerateData;
            }
        }
        Procedure MainExecution;
        Procedure MainTermination {
            Body: {
                return 1 ;
            }
        }
    }
    Procedure GenerateData {
        Body: {
            ProcesTime(j,m) := round(Uniform(1,20));
        }
    }
    Procedure prSolve {
        Body: {
            Empty sObservations ;
            noIncumbents := 0 ;
            prDelegateSolve();
        }
    }
    Procedure prDelegateSolve {
        Body: {
            if pro::GetPROEndPoint() then
            	if pro::DelegateToServer( waitForCompletion  :  0, 
            				  completionCallback :  'myLoadResultsCallback' 
            				  ) then	
            		return 1;
            	endif ;
            endif ;
            
            prDoSolve();
        }
    }
    Procedure prDoSolve {
        Body: {
            Empty AllVariables;
            GenerateData();
            
            FlowShopModel.CallbackNewIncumbent := 'NewIncumbentCallback';
            FlowShopModel.CallbackTime := 'NewTimeCallback';
            option progress_time_interval := 1 ;
            
            solve FlowShopModel;
        }
    }
}
