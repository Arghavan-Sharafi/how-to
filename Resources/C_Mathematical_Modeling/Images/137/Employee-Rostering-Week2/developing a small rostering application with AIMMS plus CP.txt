On the development of a small rostering application. 

Picture of a small home for the old? (klein bejaardentehuis)

Solutions from rostering applications affect the daily life of the people rostered. Therefore, the application developers and planners iteratively improve the rostering applications and the quality of the solutions, often based on the feedback of those affected by the rosters created. The close link between the modeling language and GUI pages in AIMMS makes it easy to study the solutions and (re)formulate constraints.  

In this post, the steps are described to develop a small rostering application in AIMMS. This application is based on an assignment given in "Integrated methods for Optimization" by John N. Hooker, section 2.2.5. The problem is to create a weekly roster for 4 nurses to help in a home for the elderly. A day has three shifts: day, evening, and night. Each shift is staffed by one nurse. In addition, each day one nurse is free. We try to balance the free days per nurse, require at least 16 hours between shifts, and minimize the nurses per particular shift, and the number of changes in staffing per shift. 

<--- more ->

A roster can be viewed in two ways, for each day d:
- which shift s is staffed by which employee: Employee( d, s ) -> Employees
- which shift is assigned to each employee e: Shift( d, e ) -> Shifts
These variables have distinct values and are inverses:
cp::AllDifferent(e,Shift(e,d))
cp::AllDifferent(s,Employee(s,d))
cp::Channel( s, Employee(s,d), e, Shift(e,d) ) 

So lets solve this base model:
The solution is presented in the following two tables of the variables:  (alternative data pages below each other?)

< take picture Solution Base >

Which nurse do you want to be, the one not earning anything, or one of those not having a free day to spend the earnings?
This is the first feedback we have to work: distribute free time evenly.
FreeDays(e) -> { 1 ..2 },
cp::Count(d,Shift(e,d),'free','=',FreeDays(e))
sum(e,FreeDays(e)) = card(Days)

Lets solve this and take again a look at the solution:
 
< take picture Solution Free distributed>

Inspecting the solution, we see that nurse C does the night shift on Wednesday and the evening shift on Thursday. There are only 8 hours between these two shifts. It is reasonable to require at least 16 hours between shifts. 

CONSTRAINT:
   identifier   :  SuccessorShiftRestriction
   index domain :  (e,d,s) | card( permittedNextShifts(s) ) < card(shifts)
   definition   :  if Shift(e,d) = s then Shift(e,d++1) in permittedNextShifts( s ) endif 
Here PermittedNextShifts is an Indexed Set with the following contents:
< Permitted Next Shifts.PNG >
As an aside: note the use of the circular ++ operator here: d++1, is the next day, with one exception: 'last day'++1 is the first day.

Lets solve this and see what the result is now:

< Applying successor shift restriction.PNG >

Checking the result; indeed there is now at least 16 hours between two shifts of each nurse. However, the current roster comes across as rather messy.  More to the point: three different nurses are staffing each of the working shifts. There is a lot of change of staffing the shifts and elderly people do not like these changes. For starters, would it be possible to limit the number of nurses staffing these shifts to two?

First, we introduce an element variable for each of the working shifts: ShiftValue(s,{1..2}) -> Employees.  For each day, the nurse staffing shift s, should be equal to one of the values of ShiftValue:
Employee(s,d) = ShiftValue(s,1) or Employee(s,d) = ShiftValue(s,2).

We are ready for the next iteration and then looking at the solution:

<Limited to two nurses per shift.PNG>

Well, that solution certainly looks less messy than the previous one. 

A staff change is a change of nurse from one day to the next for a particular shift; for instance on the evening shift there is a staff change from Thursday, nurse A, to Friday, nurse B. The current solution has 8 staff changes. Can we have less of those staff changes to make the solution come across even more placid?

We do this via the objective by counting the staff changes:
obj = sum( (as,d), Employee(as,d) <> Employee(as,d++1) )
and minimizing that.

With this objective we get the following solution:

<Minimal staff changes.PNG>

But...

In the previous solves we got an answer instantaneous, and now we had to wait more that 5 seconds.  We do not want to wait that long.
It is possible to reduce the solve time again using the following two techniques.

The first technique is to reduce the symmetry. In our example, changing who is actually nurse A, B, C, or D does not matter.
So we might as well fix the solution of the first day; this fixing will not really change the problem.

The second technique is to add redundant constraints. A redundant constraint is a constraint that can be derived from the other constraints and helps to reduce the search. In our example, the minimum found is 6. By observing that each working shift requires at least two nurses, there are at least two shift changes for the working shift, we can also derive the minimum is 6. Actually, you may want to point out to me that the two cp::AllDifferent constraints given in the base model are also redundant.

Applying these two techniques, gives us instantaneous feedback again.





 

At the end of this post I will show how you can demonstrate each of the steps presented in this post with just a simple drag and drop action.

Reference:
[1] John Hooker "Integrated methods for Optimization" Springer 2007 