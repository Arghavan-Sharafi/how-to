## ams_version=1.0

Model Employee_rostering {
    Comment: "[1]: Integrated methods for Optimization by John N. Hooker";
    Section Data_handling {
        Set Employees {
            Index: e;
            Definition: data { A, B, C, D };
        }
        Set Shifts {
            Index: s;
            Definition: data { free, day, evening, night };
        }
        Set ActualShifts {
            SubsetOf: Shifts;
            Index: as;
            Definition: data { day, evening, night };
        }
        Set Days {
            Index: d;
            Definition: data { Mon, Tue, Wed, Thu, Fri, Sat, Sun };
        }
    }
    Section Constraint_Programming_Model {
        DeclarationSection CP_Utility_parameters_and_sets {
            Set ShiftValuesIndexSet {
                SubsetOf: Integers;
                Index: isv;
                Definition: ElementRange(1,MaxEmployeesPerShift);
            }
            Parameter MaxEmployeesPerShift {
                InitialData: 2;
            }
            Set permittedNextShifts {
                IndexDomain: (s);
                SubsetOf: Shifts;
                Definition: {
                    data {
                    	free    : { free, day, evening, night },
                    	day     : { free, day, evening, night },
                    	evening : { free,      evening, night },
                    	night   : { free,               night } }
                }
            }
        }
        Section Constraint_Programming_Variables_and_Constraints {
            DeclarationSection CP_Base_concept_declarations {
                ElementVariable Employee {
                    IndexDomain: (s,d);
                    Range: Employees;
                }
                ElementVariable Shift {
                    IndexDomain: (e,d);
                    Range: Shifts;
                }
                Constraint DuplicateModelingView {
                    IndexDomain: (d);
                    Definition: cp::Channel( s, Employee(s,d), e, Shift(e,d) );
                    Comment: "For all d: Employee(Shift(e,d),d)=e and Shift(Employee(s,d),d)=s";
                }
                Constraint distinctShiftsPerDay {
                    IndexDomain: (d);
                    Definition: cp::AllDifferent(e,Shift(e,d));
                }
                Constraint distinctEmployeesPerDay {
                    IndexDomain: (d);
                    Definition: cp::AllDifferent(s,Employee(s,d));
                }
            }
            DeclarationSection CP_Concept_1_declarations {
                Variable FreeDays {
                    IndexDomain: (e);
                    Range: {
                        {1..2}
                    }
                }
                Constraint EachEmployeeHasOneOrTwoDaysOff {
                    IndexDomain: e;
                    Definition: {
                        ! We can either count the days worked of an
                        ! employee, or, equivalently, the number of
                        ! days free.
                        ! Here FreeDays is a variable with range {1..2}
                        ! so this constraint will force each employee
                        ! to have at least 1 day free and at most 2.
                        cp::Count(d,Shift(e,d),'free','=',FreeDays(e))
                    }
                }
                Constraint TotalFreeDays {
                    Definition: {
                        ! Each day an employee is free
                        ! Not really fair; there will be
                        ! one employee with one day free
                        ! whilst the others will have
                        ! two days free.
                        sum(e,FreeDays(e)) = card(Days)
                    }
                }
            }
            DeclarationSection CP_Concept_2_declarations {
                Constraint SuccessorShiftRestriction {
                    IndexDomain: (e,d,s) | card( permittedNextShifts(s) ) < card(shifts);
                    Definition: if Shift(e,d) = s then Shift(e,d++1) in permittedNextShifts( s ) endif;
                    Comment: "For instance, it is not allowed to work a day shift right after a night shift.";
                }
            }
            DeclarationSection CP_Concept_3_declarations {
                ElementVariable SV {
                    IndexDomain: (s,isv)|s<>first(Shifts);
                    Range: Employees;
                    Comment: "This variable is used to implement the nValues global constraint as presented in 2.11 nValues.";
                }
                Constraint LimitedNumberOfEmployeesHandlingShift {
                    IndexDomain: {
                        (s,d)|s<>first(Shifts) ! Each employee has free time.
                                               ! thus this constraint does not apply to free time.
                    }
                    Definition: {
                        exists(isv,SV(s,isv)=Employee(s,d))
                        ! sv(ochtend,1) = Employee(ochtend,d) of sv(ochtend,2) = Employee(ochtend,d)
                    }
                }
            }
            DeclarationSection CP_Concept_4_declarations {
                Variable obj {
                    Text: "Total number of staffing changes summed over the shifts.";
                    Range: free;
                    Definition: sum( (as,d), Employee(as,d) <> Employee(as,d++1) );
                    Comment: "A Staffing change is when a shift is staffed by a different person the next day.";
                }
            }
            DeclarationSection CP_Concept_5_declarations {
                Constraint ObjectiveLowerBound {
                    Definition: obj >= 6;
                    Comment: {
                        "There are three actual shifts and in each of those shifts the shift changes are counted.
                        Each shift is staffed by at least two nurses, say nurse 1 and nurse 2.  Thus there will
                        be at least two staff changes within a single shift: from nurse 1 to nurse 2 and a reverse.
                        Thus a lower bound on the objective is 6."
                    }
                }
                Constraint SymmetryReducDay1 {
                    IndexDomain: s;
                    Definition: Employee(s, first(Days)) = Element(Employees,ord(s));
                    Comment: "As no distinction is made between the different nurses, the solution to the first day may as well be fixed.";
                }
            }
        }
        Section Add_the_declaration_sections_below_one_by_one_to_the_section_above;
        DeclarationSection Administration_Constraint_Pogramming_Model {
            Set CP_Variables {
                SubsetOf: AllVariables;
                Definition: Constraint_Programming_Variables_and_Constraints * AllVariables;
            }
            Set CP_Constraints {
                SubsetOf: AllConstraints;
                Definition: Constraint_Programming_Variables_and_Constraints * AllConstraints;
            }
            MathematicalProgram RosteringProblem {
                Objective: obj;
                Direction: minimize;
                Constraints: CP_Constraints;
                Variables: CP_Variables;
                Type: Automatic;
            }
            ElementParameter RosteringProblemInstance {
                Range: AllGeneratedMathematicalPrograms;
            }
        }
        Procedure GenerateCPModel {
            Body: {
                RosteringProblemInstance := gmp::Instance::Generate( RosteringProblem );
                ! gmp::Instance::Solve( RosteringProblemInstance );
                if RosteringProblemInstance then
                    GMP::Solution::RetrieveFromModel( RosteringProblemInstance, 1 );
                    GMP::Solution::ConstraintListing( RosteringProblemInstance, 1, "RosteringProblem.Instance.txt" );
                endif ;
            }
        }
        Procedure SolveCPModel {
            Body: {
                ShowProgressWindow ;
                Solve RosteringProblem where time_limit := 10 /* seconds */ ;
            }
        }
    }
    Procedure MainInitialization;
    Procedure MainExecution {
        Body: {
            SolveCPModel ;
        }
    }
    Procedure MainTermination {
        Body: {
            return 1; ! No questions asked.
        }
    }
}
