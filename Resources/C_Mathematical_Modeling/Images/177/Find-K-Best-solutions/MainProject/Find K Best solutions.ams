## ams_version=1.0

Model Find_K_Best_solutions {
    DeclarationSection Knapsack_input_declarations {
        Parameter N {
            InitialData: 30;
        }
        Parameter K {
            InitialData: 5;
        }
        Set Items {
            SubsetOf: Integers;
            Index: i;
            Definition: {
                {1..n}
            }
        }
        Parameter ItemWeight {
            IndexDomain: (i);
            Definition: i * sqrt(i);
        }
        Parameter ItemValue {
            IndexDomain: (i);
            Definition: i*i;
        }
        Parameter Capacity {
            Definition: (2/3) * sum( i , ItemWeight(i) );
        }
    }
    DeclarationSection Knapsack_model {
        Variable x {
            IndexDomain: (i);
            Range: binary;
        }
        Variable TotalValue {
            Range: free;
            Definition: sum( i, ItemValue(i) * x(i) );
        }
        Constraint TotalCapacity {
            Definition: sum( i, ItemWeight(i) * x(i) ) <= Capacity;
        }
        MathematicalProgram Knapsack {
            Objective: TotalValue;
            Direction: maximize;
            Constraints: AllConstraints;
            Variables: AllVariables;
            Type: MIP;
        }
    }
    DeclarationSection Solution_pool_declarations {
        Parameter PoolReplacementStrategy {
            Range: {
                {0..2}
            }
            InitialData: 1;
        }
        Parameter PoolIntensity {
            Range: {
                {0..4}
            }
            InitialData: 1;
        }
        Parameter PoolLimit {
            Range: integer;
            InitialData: 20;
        }
    }
    DeclarationSection Result_overview_declarations {
        Set Solutions {
            SubsetOf: Integers;
            Index: s;
            Definition: {
                {1..K}
            }
        }
        Parameter SolutionPoolObjective {
            IndexDomain: (s);
        }
        Parameter IntegerEliminationObjective {
            IndexDomain: (s);
        }
        Parameter TimeForSolutionPool;
        Parameter TimeForEliminationRows;
    }
    Procedure MainInitialization;
    Procedure MainExecution {
        Body: {
            n := 30 ;
            k := 5 ;
            
            PoolReplacementStrategy := 1 ;
            PoolLimit := 200 ;
            PoolIntensity := 3 ;
            
            ApplyBothApproaches ;
            
            display SolutionPoolObjective, IntegerEliminationObjective ;
        }
    }
    Procedure UseSolutionPool {
        Body: {
            !Empty any previous results and (re)generate the GMP
            empty SolutionPoolObjective ;
            epGMP := gmp::Instance::Generate( Knapsack ) ;
            
            !Some sanity-checking, as solution pools are only useful
            !with cplex.
            if substring( CurrentSolver('MIP') , 1,5) <> "CPLEX" then
            	raise error "Solution pool can only be used with CPLEX." +
            		    " Please set your default solver for MIP problems to CPLEX"  ;
            	return ;
            endif ;
            
            !Set the CPLEX options that are related to the solution pool
            OptionSetValue( "pool_replacement_strategy", PoolReplacementStrategy) ;
            OptionSetValue( "pool_intensity", PoolIntensity) ;
            OptionSetValue( "population_limit", PoolLimit) ;
            OptionSetValue( "pool_capacity", k) ;
            OptionSetValue( "do_populate", 1) ;
            
            !We want to know how much time this takes, so start the stopwatch
            StartStopwatch ;
            
            !This will solve the MIP problem and because of the do_populate
            !option it will also populate the solution pool based on the
            !values for the other options. AIMMS will store these solutions
            !in the solution repository of the GMP.
            gmp::instance::Solve( epGMP ) ;
            
            !Setting the pool capacity to a certain value will ensure only
            !that number of solutions are generated.
            while LoopCount <= gmp::Solution::Count( epGMP ) do
            	!For each solution, we send the values from the solution
            	!repository to the model and store the objective value
            	gmp::Solution::SendToModel( epGMP , LoopCount )  ;
            	SolutionPoolObjective(LoopCount) := totalValue ;
            endwhile ;
            
            !Stop the stopwatch and store the time required for finding the
            !k best solutions.
            StopStopwatch ;
            TimeForSolutionPool := (ElapsedTime)[-] ;
        }
        ElementParameter epGMP {
            Range: AllGeneratedMathematicalPrograms;
        }
    }
    Procedure UseEliminationConstraints {
        Body: {
            !Empty any previous results and (re)generate the GMP
            empty IntegerEliminationObjective ;
            epGMP := gmp::Instance::Generate( Knapsack ) ;
            
            !We are creating the k best solutions ourselves now, so we
            !don't need to populate any solution pool.
            OptionSetValue( "do_populate", 0) ;
            
            !We want to know how much time this takes, so start the stopwatch
            StartStopwatch ;
            
            !Solve the problem exactly k times
            while Loopcount <= k do
            	gmp::Instance::Solve( epGMP ) ;
            
            	!store the objective that corresponds to the current solution
            	IntegerEliminationObjective( loopcount ) := totalValue ;
            
            	!Instruct AIMMS to generate a new constraint that will
            	!eliminate the solution at postion 1 of the solutions for
            	!this GMP. The elimNo allows you to add these elimination
            	!rows incrementally
            	GMP::Instance::AddIntegerEliminationRows(
            			GMP      :  epGMP,
            			solution :  1,
            			elimNo   :  LoopCount) ;
            endwhile ;
            
            !Stop the stopwatch and store the time required for finding the
            !k best solutions.
            StopStopwatch ;
            TimeForEliminationRows := (ElapsedTime)[-] ;
        }
        ElementParameter epGMP {
            Range: AllGeneratedMathematicalPrograms;
        }
    }
    Procedure ApplyBothApproaches {
        Body: {
            UseSolutionPool  ;
            UseEliminationConstraints ;
        }
    }
    Procedure MainTermination {
        Body: {
            return 1;
        }
    }
    Section Stopwatch_support {
        DeclarationSection Stopwatch_Declarations {
            Quantity SI_Time_Duration {
                BaseUnit: s;
                Conversions: tick -> s : # -> # / 100;
                Comment: "Expresses the value for the duration of periods.";
            }
            StringParameter StopwatchStartTime {
                Comment: "Time the stopwatch was started";
            }
            Parameter ElapsedTime {
                Unit: s;
                Comment: {
                    "Time that has elapsed since the stopwatch was started. The value for this is updated
                    by the StopStopwatch procedure"
                }
            }
        }
        Procedure StartStopwatch {
            Body: {
                !Use the CurrentToString AIMMS function to store the current time in YYYY-MM-DD HH:MM:SS:TT format
                StopwatchStartTime := CurrentToString( "%c%y-%m-%d %H:%M:%S:%t");
            }
            Comment: "Set the StopwatchStartTime of the stopwatch";
        }
        Procedure StopStopwatch {
            Body: {
                !Using the CurrentToMoment AIMMS function, we can ask for the number of ticks that have elapsed at the moment
                !since the given StopwatchStartTime (which was stored by calling the StartStopwatch procedure).
                !Please note that we do not actually 'stop' the stopwatch, but only store the time elapsed.
                ElapsedTime := CurrentToMoment( [tick], StopwatchStartTime );
            }
            Comment: "Deterine how many ticks have elapsed since the start of the stopwatch";
        }
    }
}
