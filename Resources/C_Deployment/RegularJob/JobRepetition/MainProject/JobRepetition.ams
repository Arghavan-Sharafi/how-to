## ams_version=1.0

Model Main_JobRepetition {
    DeclarationSection Global_identifiers_not_saved_in_case {
        Property: NoSave;
        Quantity SI_Time_Duration {
            BaseUnit: s;
            Conversions: {
                minute->s : #-># * 60,
                second->s : #->#
            }
            Comment: "Expresses the value for the duration of periods.";
        }
        StringParameter sp_Filename {
            Definition: "c:\\tmp\\logFile.txt";
        }
        File f_Out {
            Name: sp_Filename;
            Device: Disk;
            Mode: merge;
        }
        StringParameter sp_NextJobStart;
        StringParameter sp_StdTimFmt {
            Definition: "%c%y-%m-%d %H:%M:%S";
        }
        StringParameter sp_UtcTimFmt {
            Definition: "%c%y-%m-%d %H:%M:%S%TZ('UTC')";
        }
        StringParameter sp_DataSessionMessageQueue {
            InitialData: "";
        }
        Set s_MsgNos {
            SubsetOf: Integers;
            Index: i_MsgNo;
            Parameter: e_MsgNo;
        }
        StringParameter sp_Msgs {
            IndexDomain: i_MsgNo;
        }
        ElementParameter ep_PayloadProcedure {
            Range: AllProcedures;
            Default: 'MainExecution';
        }
    }
    Section Worker_procedures {
        Procedure pr_Friesian {
            Body: {
                sp_Msg := FormatString("pr_Friesian(): At %s (UTC) delegation level is %i",
                	CurrentToString(sp_UtcTimFmt), pro::CurrentDelegationLevel() );
                pro::management::LocalLogInfo(sp_Msg);
                pr_NotifyDataSession(sp_DataSessionMessageQueue,sp_Msg);
            }
            Comment: {
                "Frisians are excellent work horses.
                This is the procedure that \"actually performs the Job\""
            }
            StringParameter sp_Msg;
        }
        Procedure pr_NotifyDataSession {
            Arguments: (sp_DataSessionQueue,sp_Msg);
            Body: {
                if pro::DelegateToPeer(
                	requestQueue  :  sp_DataSessionQueue, 
                	flags         :  pro::PROMFLAG_LIVE) then
                	return ;
                endif ;
                pr_ReceiveNotification(sp_Msg);
            }
            StringParameter sp_DataSessionQueue {
                Property: Input;
            }
            StringParameter sp_Msg {
                Property: Input;
            }
        }
        Procedure pr_ReceiveNotification {
            Arguments: (sp_Msg);
            Body: {
                s_MsgNos += card( s_MsgNos )+1;
                e_MsgNo := last( s_MsgNos );
                sp_Msgs( e_MsgNo ) := sp_Msg ;
            }
            StringParameter sp_Msg {
                Property: Input;
            }
        }
        Procedure pr_DataSessionCreateQueueStartListening {
            Body: {
                ! Create a new queue, with full access for everyone.
                if not sp_DataSessionMessageQueue then
                
                	! Create the queue
                	sp_AuthorizationString := "#7+16777087";
                	pro::messaging::CreateQueue(sp_AuthorizationString,sp_DataSessionMessageQueue);
                
                	! ... and start listening to it.
                	pro::messaging::AddQueueToConnection(sp_DataSessionMessageQueue, pro::ListeningConnectionId);
                endif ;
            }
            Comment: "This procedure should be called directly by the button procedures.";
            StringParameter sp_AuthorizationString;
        }
    }
    Section Server_session_sequence_generation {
        Procedure pr_OnButtonStartServerSessions {
            Body: {
                pr_DataSessionCreateQueueStartListening();
                ep_PayloadProcedure := StringToElement( AllProcedures, "pr_Frisian", create: 0 );
                pr_IterativeJobScheduling(
                	delegateLevel      :  0, 
                	maxDelegateLevel   :  4,
                	timeIncrement      :  2[second], 
                	epPayloadProcedure :  ep_PayloadProcedure, 
                	spDataSessionQueue :  sp_DataSessionMessageQueue);
            }
            Comment: "The place to put zebras and other horses in.";
        }
        Procedure pr_IterativeJobScheduling {
            Arguments: (delegateLevel,maxDelegateLevel,timeIncrement,epPayloadProcedure,spDataSessionQueue);
            Body: {
                ! pro::DelegateToServer uses the *current* values of local arguments to create a call for a new server session.
                ! We modify the values of these arguments before calling pro::DelegateToServer
                delegateLevel += 1 ;
                spRequestDescription := formatString("Start %i'th iteration of %e at %s", delegateLevel, epPayloadProcedure, sp_jobTime );
                
                ! Switch to server sessions.
                if delegateLevel = 1 then
                	! The first job starts immediately
                	if pro::DelegateToServer( 
                			requestDescription :  spRequestDescription,
                			waitForCompletion  :  0, 
                			completionCallback :  'pro::session::EmptyCallback',
                			delegationOverride :  delegateLevel  ) then
                		return 1 ;
                	endif ;
                elseif delegateLevel <= maxDelegateLevel then	! Schedule the next job.
                	sp_jobTime := MomentToString( sp_UtcTimFmt, [second], CurrentToString(sp_UtcTimFmt), timeIncrement );
                	pro::DelegateToServer( 
                		requestDescription :  spRequestDescription,
                		waitForCompletion  :  0, 
                		completionCallback :  'pro::session::EmptyCallback',
                		delegationOverride :  delegateLevel,
                		scheduledAt        :  sp_jobTime );
                endif ;
                
                ! Selected initializations from arguments
                sp_DataSessionMessageQueue := spDataSessionQueue ;
                
                Apply( epPayloadProcedure );
            }
            Parameter delegateLevel {
                Property: Input;
            }
            Parameter maxDelegateLevel {
                Property: Input;
            }
            Parameter timeIncrement {
                Unit: second;
                Property: Input;
            }
            ElementParameter epPayloadProcedure {
                Range: AllProcedures;
                Default: 'MainExecution';
                Property: Input;
            }
            StringParameter sp_jobTime;
            StringParameter spRequestDescription;
            StringParameter spDataSessionQueue {
                Property: Input;
            }
            StringParameter sp_Msg;
        }
    }
    Section MainModelProcedures {
        Procedure MainInitialization {
            Comment: "Add initialization statements here that do NOT require any library being initialized already.";
        }
        Procedure PostMainInitialization {
            Body: {
                if pro::GetPROEndPoint() then 
                	 pro::Initialize();
                endif ;
            }
            Comment: {
                "Add initialization statements here that require that the libraries are already initialized properly,
                or add statements that require the Data Management module to be initialized."
            }
        }
        Procedure MainExecution;
        Procedure PreMainTermination {
            Body: {
                return 1;
            }
            Comment: {
                "Add termination statements here that require all libraries to be still alive.
                Return 1 if you allow the termination sequence to continue.
                Return 0 if you want to cancel the termination sequence."
            }
        }
        Procedure MainTermination {
            Body: {
                return 1;
            }
            Comment: {
                "Add termination statements here that do not require all libraries to be still alive.
                Return 1 to allow the termination sequence to continue.
                Return 0 if you want to cancel the termination sequence.
                It is recommended to only use the procedure PreMainTermination to cancel the termination sequence and let this procedure always return 1."
            }
        }
    }
}
