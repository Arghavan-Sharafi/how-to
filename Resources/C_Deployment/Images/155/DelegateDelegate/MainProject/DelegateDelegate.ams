## ams_version=1.0

Model Main_DelegateDelegate {
    Parameter pi;
    Procedure pr_ButtonComputation {
        Body: {
            p01_DelegateCompleted := 0 ;
            while not p01_DelegateCompleted do
            	sp_msg := "" ;
            
            	block 
            		! Happy flow here.
            		pr_DelegateComputation();
            
            		! Mark task as completed.
            		p01_DelegateCompleted := 1 ;
            
            	onerror ep_err do
            
            		! Error handling here.
            		p01_errorHandled := 0 ;
            		sp_msg := errh::Message(ep_err);
            		if StringOccurrences(sp_msg, "timed out") then
            
            			! On timed out, provide user with the opportunity to retry. 
            			p_ret := DialogAsk(
            					message :  sp_msg, 
            					button1 :  "Retry", 
            					button2 :  "Cancel", 
            					title   :  "Press Retry, if you want to retry the solve, cancel if you want to handle the issue otherwise");
            			if p_ret = 1 then
            				! Retry button pressed by user.
            				errh::MarkAsHandled(ep_err);
            				p01_errorHandled := 1;
            				! Note, p01_DelegateCompleted is still 0, so the 
            				! while loop will re-iterate and 
            				! pr_DelegateComputation() will be called again.
            			endif ;
            		endif ;
            	endblock ;
            	if sp_msg and ( p01_errorHandled = 0 ) then
            		break ; ! Error (perhaps intentionally) not handled by user.
            	endif ;
            endwhile ;
        }
        ElementParameter ep_err {
            Range: errh::PendingErrors;
        }
        StringParameter sp_msg;
        Parameter p_ret;
        Parameter p01_DelegateCompleted {
            Range: binary;
        }
        Parameter p01_errorHandled {
            Range: binary;
        }
    }
    Procedure pr_DelegateComputation {
        Body: {
            delay( 5 ); 
            raise error "oops, timed out again, sigh." ;
            
            if pro::DelegateToServer(                    
            		waitForCompletion:1,
                            completionCallback: 'pro::session::LoadResultsCallback' ) then
                    return ;
            endif ;
            
            ! Do the actual work.
            pr_Computation();
        }
    }
    Procedure pr_Computation {
        Body: {
            pi := 3.14159265359 ;
        }
    }
    Procedure MainInitialization {
        Comment: "Add initialization statements here that do NOT require any library being initialized already.";
    }
    Procedure PostMainInitialization {
        Comment: {
            "Add initialization statements here that require that the libraries are already initialized properly,
            or add statements that require the Data Management module to be initialized."
        }
    }
    Procedure MainExecution;
    Procedure PreMainTermination {
        Body: {
            return 1;
        }
        Comment: {
            "Add termination statements here that require all libraries to be still alive.
            Return 1 if you allow the termination sequence to continue.
            Return 0 if you want to cancel the termination sequence."
        }
    }
    Procedure MainTermination {
        Body: {
            return 1;
        }
        Comment: {
            "Add termination statements here that do not require all libraries to be still alive.
            Return 1 to allow the termination sequence to continue.
            Return 0 if you want to cancel the termination sequence.
            It is recommended to only use the procedure PreMainTermination to cancel the termination sequence and let this procedure always return 1."
        }
    }
}
