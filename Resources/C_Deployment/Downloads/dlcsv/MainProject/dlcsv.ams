## ams_version=1.0

Model Main_dlcsv {
    DeclarationSection data_declarations {
        dl::Category: DataPersistedViaCSVFiles;
        Set sLocs {
            Index: iLoc;
        }
        Set sProd {
            Index: iPrd;
        }
        Parameter pDem {
            IndexDomain: (iLoc,iPrd);
        }
        StringParameter spCmt {
            IndexDomain: (iLoc,iPrd);
        }
    }
    DeclarationSection comm_declarations {
        StringParameter spCommunicationAttributes {
            IndexDomain: dl::rwattr;
        }
        StringParameter spColAttr {
            IndexDomain: dl::colattr;
            Definition: data {};
        }
        StringParameter DataMap {
            IndexDomain: (dl::dt,dl::idn,dl::cn,dl::dn);
        }
    }
    Procedure ReadCSV_CommonDataMap {
        Body: {
            Empty data_declarations ;
            dl::DataTables += {'fourRows'} ; ! komma/fourRows.csv is the file we're gonna read from.
            DataMap(dl::dt,dl::idn,dl::cn,dl::dn) := data {
            	( fourRows, sLocs, 1, 1 ) : "location",
            	( fourRows, sProd, 2, 2 ) : "product",
            	( fourRows, pDem , 3, 0 ) : "demand", 
            	( fourRows, spCmt, 4, 0 ) : "comment"
            };
            dl::RemoveDataSourceMapping("TheMapping");
            dl::AddDataSourceMapping("TheMapping", DataMap, dl::DependEmpty, dl::TableAttributesEmpty, dl::ColAttributeEmpty);
        }
        Comment: "This procedure contains the common part of procedures ReadCSV_KommaSeparated and ReadCSV_SemiSeparated";
    }
    Procedure ReadCSV_KommaSeparated {
        Body: {
            ReadCSV_CommonDataMap();
            
            spCommunicationAttributes := 
                  { 'DataProvider' : csvprov::DataLink , 
                    'ContainsHeaders' : "yes"
                    ! Note that Separator attribute is left to its default of ",".
                  };
            
            dl::DataRead("komma",                 ! reading from data source "komma" - because we use csvprovider this data source is a folder.
                    "TheMapping" ,                ! using relation "TheMapping" between folder komma and AIMMS identifiers.
                    spCommunicationAttributes);   ! Technicalities on how to communicate.
        }
    }
    Procedure ReadCSV_SemiSeparated {
        Body: {
            ReadCSV_CommonDataMap();
            
            spCommunicationAttributes := 
                  { 'DataProvider' : csvprov::DataLink , 
                    'ContainsHeaders' : "yes",
                    'Separator' : ";"
                  };
            
            dl::DataRead("semi",                  ! reading from data source "semi" - because we use csvprovider this data source is a folder.
                    "TheMapping" ,                ! using relation "TheMapping" between folder komma and AIMMS identifiers.
                    spCommunicationAttributes);   ! Technicalities on how to communicate.
        }
    }
    Section attic {
        Procedure MainInitialization {
            Comment: "Add initialization statements here that do NOT require any library being initialized already.";
        }
        Procedure PostMainInitialization {
            Comment: {
                "Add initialization statements here that require that the libraries are already initialized properly,
                or add statements that require the Data Management module to be initialized."
            }
        }
        Procedure MainExecution;
        Procedure PreMainTermination {
            Body: {
                return 1;
            }
            Comment: {
                "Add termination statements here that require all libraries to be still alive.
                Return 1 if you allow the termination sequence to continue.
                Return 0 if you want to cancel the termination sequence."
            }
        }
        Procedure MainTermination {
            Body: {
                return 1;
            }
            Comment: {
                "Add termination statements here that do not require all libraries to be still alive.
                Return 1 to allow the termination sequence to continue.
                Return 0 if you want to cancel the termination sequence.
                It is recommended to only use the procedure PreMainTermination to cancel the termination sequence and let this procedure always return 1."
            }
        }
    }
}
