## ams_version=1.0

Model Main_MultiRunExcel {
    Section Handling_the_transportation_Problem {
        DeclarationSection Input_For_Transportation_Problem {
            Set s_Suppliers {
                Index: i_Sup;
            }
            Set s_DCs {
                Index: i_dc;
            }
            Parameter p_Sup {
                IndexDomain: i_Sup;
            }
            Parameter p_Dem {
                IndexDomain: i_dc;
            }
            Parameter p_Dist {
                IndexDomain: (i_sup, i_dc);
            }
        }
        DeclarationSection Simple_Transportation_Problem {
            Variable v_X {
                IndexDomain: (i_Sup,i_dc);
                Range: nonnegative;
            }
            Variable v_Obj {
                Range: free;
                Definition: sum( (i_Sup, i_dc), p_Dist(i_Sup, i_dc) * v_X(i_Sup, i_dc) );
            }
            Constraint c_MeetDemand {
                IndexDomain: i_dc;
                Definition: sum(i_sup, v_X(i_Sup, i_dc)) >= p_Dem(i_dc);
            }
            Constraint c_RespectSupply {
                IndexDomain: i_Sup;
                Definition: sum( i_dc, v_X(i_Sup, i_dc)) <= p_Sup(i_Sup);
            }
            MathematicalProgram mp_STP {
                Objective: v_Obj;
                Direction: minimize;
                Constraints: AllConstraints;
                Variables: AllVariables;
                Type: Automatic;
            }
        }
        Procedure pr_SolveSimpleTransportationProblem {
            Body: {
                solve mp_STP ;
            }
        }
    }
    Section Handling_Excel_File {
        DeclarationSection Interaction_data {
            Parameter p_noSup;
            Parameter p_noDC;
            StringParameter sp_Workbook;
        }
        Procedure pr_ReadDataFromExcelWorkbook {
            Arguments: (sp_ArgWB);
            Body: {
                Empty s_Suppliers, s_DCs ;
                
                axll::OpenWorkBook(sp_ArgWB);
                
                axll::SelectSheet("Config");
                axll::ReadSingleValue(p_noSup, "B3");
                axll::ReadSingleValue(p_noDC,  "B4");
                
                axll::SelectSheet("Supply");
                axll::ReadList(
                	IdentifierReference    :  p_Sup, 
                	RowHeaderRange         :  FormatString("A1:A%i", p_noSup),
                	DataRange              :  FormatString("B1:B%i", p_noSup),
                	ModeForUnknownElements : 1);
                
                axll::SelectSheet("Demand");
                axll::ReadList(
                	IdentifierReference    :  p_Dem, 
                	RowHeaderRange         :  FormatString("A1:A%i", p_noDC),
                	DataRange              :  FormatString("B1:B%i", p_noDC),
                	ModeForUnknownElements : 1);
                
                axll::SelectSheet("Dist");
                axll::ColumnName(p_noDC+1,sp_locColName );
                axll::ReadTable(
                    IdentifierReference : p_Dist,
                    RowHeaderRange      : FormatString("A2:A%i",p_noSup+1),
                    ColumnHeaderRange   : FormatString("B1:%s1",sp_locColName),
                    DataRange           : FormatString("B2:%s%i",sp_locColName,p_noSup+1));
                
                axll::CloseAllWorkBooks();
            }
            StringParameter sp_ArgWB {
                Property: Input;
            }
            StringParameter sp_locColName;
        }
        Procedure pr_WriteSolutionToExcelWorkbook {
            Arguments: (sp_ArgWB);
            Body: {
                axll::OpenWorkBook(sp_ArgWB);
                
                axll::SelectSheet("Solution");
                axll::ColumnName(p_noDC+1,sp_locColName );
                axll::WriteTable(
                    IdentifierReference : v_X,
                    RowHeaderRange      : FormatString("A2:A%i",p_noSup+1),
                    ColumnHeaderRange   : FormatString("B1:%s1",sp_locColName),
                    DataRange           : FormatString("B2:%s%i",sp_locColName,p_noSup+1),
                    WriteZeros          : 0 );
                
                axll::CloseWorkBook(WorkbookFilename :  sp_ArgWB);
            }
            StringParameter sp_ArgWB {
                Property: Input;
            }
            StringParameter sp_locColName;
        }
    }
    Section Batch_handling {
        StringParameter sp_BatchExcelInputFolder;
        Set s_FileNumbers {
            SubsetOf: Integers;
            Index: i_fn;
        }
        StringParameter sp_InputFileNames {
            IndexDomain: i_fn;
        }
        Procedure pr_SelectInputfolder {
            Body: {
                CurrentErrorMessage := "" ;
                ret := DirectorySelect(
                	directoryname :  sp_BatchExcelInputFolder, 
                	directory     :  ".", 
                	title         :  "Please select folder to read the .xlsx input files from.");
                if not ret then
                	if CurrentErrorMessage then
                		raise error "Selecting input batch folder failed: " + CurrentErrorMessage ;
                	else 
                		raise error "Selecting input batch folder failed: " + "User cancelled" ;
                	endif ;
                endif ;
                if not DirectoryExists( sp_BatchExcelInputFolder ) then
                	raise error "Selecting input batch folder failed: " + 
                	            " the folder " + sp_BatchExcelInputFolder + 
                	            " doesn't exist." ;
                endif ;
            }
            Parameter ret;
        }
        Procedure pr_ExecuteBatch {
            Body: {
                if not sp_BatchExcelInputFolder then
                	raise error "Input folder not specified." ;
                endif ;
                
                Empty s_FileNumbers ;
                DirectoryGetFiles(
                	directory       :  sp_BatchExcelInputFolder, 
                	filter          :  "*.xlsx", 
                	filenames       :  sp_InputFileNames, 
                	recursive       :  0);
                if not card( s_FileNumbers ) then
                	raise error "No input files found." ;
                endif ;
                
                for i_fn do
                	sp_Workbook := sp_BatchExcelInputFolder + sp_InputFileNames(i_fn);
                	pr_ExecuteSingleRun( sp_Workbook );
                endfor ;
            }
            StringParameter sp_Workbook;
        }
        Procedure pr_ExecuteSingleRun {
            Arguments: (sp_ArgWb);
            Body: {
                pr_ReadDataFromExcelWorkbook( sp_ArgWb );
                pr_SolveSimpleTransportationProblem();
                pr_WriteSolutionToExcelWorkbook( sp_ArgWb );
            }
            StringParameter sp_ArgWb {
                Property: Input;
            }
        }
    }
    Procedure MainInitialization {
        Comment: "Add initialization statements here that do NOT require any library being initialized already.";
    }
    Procedure PostMainInitialization {
        Comment: {
            "Add initialization statements here that require that the libraries are already initialized properly,
            or add statements that require the Data Management module to be initialized."
        }
    }
    Procedure MainExecution {
        Body: {
            !sp_Workbook := "..\\ExcelInputs\\InpNorthWest.xlsx";
            sp_Workbook := "..\\ExcelInputs\\InpJohnsY.xlsx";
            
            pr_ReadDataFromExcelWorkbook( sp_Workbook );
            pr_SolveSimpleTransportationProblem();
            pr_WriteSolutionToExcelWorkbook( sp_Workbook );
        }
    }
    Procedure PreMainTermination {
        Body: {
            return 1;
        }
        Comment: {
            "Add termination statements here that require all libraries to be still alive.
            Return 1 if you allow the termination sequence to continue.
            Return 0 if you want to cancel the termination sequence."
        }
    }
    Procedure MainTermination {
        Body: {
            return 1;
        }
        Comment: {
            "Add termination statements here that do not require all libraries to be still alive.
            Return 1 to allow the termination sequence to continue.
            Return 0 if you want to cancel the termination sequence.
            It is recommended to only use the procedure PreMainTermination to cancel the termination sequence and let this procedure always return 1."
        }
    }
}
