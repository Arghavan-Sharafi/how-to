## ams_version=1.0

LibraryModule DeprecateCompoundSetUtilities {
    Prefix: dcsu;
    Interface: PublicSection;
    Property: NoSave;
    Section PublicSection {
        Section Identify_compound_sets {
            Procedure prIdentifyCompoundSets {
                Body: {
                    sCompoundRootSets := {} ;
                    pCompoundSetNo := 0;
                    for IndexSets do
                    	pSubsetOfStr := AttributeToString( IndexSets, 'subset of' );	
                    	if StringOccurrences( pSubsetOfStr, "," ) then
                    		if AttributeToString( IndexSets, 'index'     ) or
                    		   AttributeToString( IndexSets, 'parameter' )    then
                    		   	sCompoundRootSets += IndexSets ;
                    		   	! Add the compound set referenced by IndexSets to the collection of compound sets.
                    		   	pCompoundSetNo += 1 ;
                    		   	sFoundCompoundSetNumbers += pCompoundSetNo ;
                    		   	eCompoundSetNo := pCompoundSetNo ;
                    		   	epFoundCompoundSets( eCompoundSetNo ) := IndexSets ;
                    		endif ;
                    	endif ;
                    endfor ;
                    
                    sCompoundSets := sCompoundRootSets ;
                    p01AdditionMade := Card( sCompoundRootSets ) <> 0 ;
                    while p01AdditionMade do
                    	p01AdditionMade := 0;
                    	for IndexSets do
                    		if not ( IndexSets in sCompoundSets ) then
                    
                    			pSubsetOfstr := AttributeToString( IndexSets, 'subset of' );
                    
                    			! Eat away the parentheses '(' and ')' possibly surrounding the domain identifier.
                    			if pSubsetOfStr then 
                    				if substring(pSubsetOfStr,1,1) = "(" then
                    					pSubsetOfStr := substring(pSubsetOfStr,2,StringLength(pSubsetOfStr)-1);
                    				endif ;
                    			endif ;
                    
                    			! Check if the domain set of this IndexSet is a compound set.
                    			if pSubsetOfStr and not StringOccurrences( pSubsetOfStr, "," ) then
                    				epDomainSet := StringToElement(AllIdentifiers, pSubsetOfStr, create:0);
                    				if epDomainSet and epDomainSet in sCompoundSets then
                    					sCompoundSets += IndexSets;
                    					p01AdditionMade := 1;
                    					! Add the compound set referenced by IndexSets to the collection of compound sets.
                    					pCompoundSetNo += 1 ;
                    					sFoundCompoundSetNumbers += pCompoundSetNo ;
                    					eCompoundSetNo := pCompoundSetNo ;
                    					epFoundCompoundSets( eCompoundSetNo ) := IndexSets ;
                    				endif ;
                    			endif ;
                    
                    		endif ;
                    	endfor ;
                    endwhile ;
                }
                Comment: {
                    "This procedure will search the application for compound sets and put the names in the set dcsu::sCompoundSets.
                    In addition, the compound root sets will be placed in the set dcsu::sCompoundRootSets."
                }
                StringParameter pSubsetOfStr;
                Parameter p01AdditionMade {
                    Range: binary;
                }
                ElementParameter epDomainSet {
                    Range: AllSets;
                }
                Parameter pCompoundSetNo;
            }
        }
        Section create_compound_set_mappings {
            Procedure prCreateSetMappingsCompoundSet {
                Body: {
                    !block
                    	prIdentifyCompoundSets();
                    	prWorkCreateSetMappingsCompoundSet();
                    !onerror err do
                    !	DialogMessage( errh::Message( err ));
                    !	errh::MarkAsHandled(err);
                    !endblock ;
                }
                ElementParameter err {
                    Range: errh::PendingErrors;
                }
            }
            Procedure prEnourageToCopySection {
                Body: {
                    DialogMessage("Pleae use AIMMS - Edit - Export Section ; AIMMS Edit Import Section for \"Mapping Set Declarations\"");
                }
            }
            Procedure prCreateShadowCompoundSet {
                Body: {
                    prIdentifyCompoundSets();
                    prWorkCreateShadowCompoundSet();
                }
            }
            Procedure prForwardDataToShadow {
                Body: {
                    if not epCompoundSetShadowRuntimeLibrary then
                    	prCreateShadowCompoundSet();
                    endif ;
                    me::Compile( epCompoundSetShadowRuntimeLibrary  );
                    Apply( epProcForwardCopyProcedure );
                }
            }
            Procedure prForwardShadowToCase {
                Body: {
                    prWorkSaveShadowToCase();
                }
            }
            Procedure prGenerateBackward {
                Body: {
                    prWorkGenerateBackward();
                }
            }
            Set sRuntimeIds {
                SubsetOf: AllIdentifiers;
                Index: iRuntimeId;
            }
        }
    }
    Section PrivateSection {
        Section Internal_utilities {
            ElementParameter epSectionCompoundSetMappingDeclarations {
                Range: AllIdentifiers;
            }
            ElementParameter epElementParameterForTag {
                IndexDomain: (IndexIdentifiers,iIDP);
                Range: AllIdentifiers;
            }
            ElementParameter epElementParameterHelp {
                IndexDomain: (IndexIdentifiers,iIDP);
                Range: AllIdentifiers;
            }
            ElementParameter epMappingSetSet {
                IndexDomain: IndexIdentifiers;
                Range: AllIdentifiers;
            }
            ElementParameter epMappingSetRelation {
                IndexDomain: IndexIdentifiers;
                Range: AllIdentifiers;
            }
            Procedure prRemoveSpaces {
                Arguments: (spStr);
                Body: {
                    pSpacePos := FindString( spStr, " " );
                    while pSpacePos do
                    	if pSpacePos = 1 then
                    		spStr := substring( spStr, 2, StringLength( spStr ) );
                    	elseif pSpacePos = StringLength( spStr ) then
                    		spStr := substring( spStr, 1, StringLength( spStr ) - 1 );	
                    	else
                    		spStr := 
                    			substring( spStr, 1, pSpacePos - 1 ) + 
                    			substring( spStr, pSpacePos + 1, StringLength( spStr ) );
                    	endif ;
                    	pSpacePos := FindString( spStr, " " );
                    endwhile ;
                }
                StringParameter spStr {
                    Property: InOut;
                }
                Parameter pSpacePos;
            }
            Function fncRequiresDataShadow {
                Arguments: (epId);
                Range: binary;
                Body: {
                    fncRequiresDataShadow := 0 ;
                    pDim := IdentifierDimension( epId );
                    while loopCount <= pDim do
                    	epIndex := DomainIndex( epId, loopCount );
                    	epSet := IndexRange( epIndex );
                    	if epSet in sCompoundSets then
                    		fncRequiresDataShadow := 1 ;
                    		break ;
                    	endif ;
                    endwhile ;
                }
                ElementParameter epId {
                    Range: AllIdentifiers;
                    Property: Input;
                }
                ElementParameter epIndex {
                    Range: AllSymbols;
                }
                ElementParameter epSet {
                    Range: AllSymbols;
                }
                Parameter pDim;
            }
            Function fncIndexDomainString {
                Arguments: (epId,p01MappedIndex);
                Range: string;
                Body: {
                    fncIndexDomainString := "(" ;
                    pDim := IdentifierDimension( epId );
                    while loopCount <= pDim do
                    	epIndex := DomainIndex( epId, loopCount );
                    	epSet := IndexRange( epIndex );
                    	if p01MappedIndex and ( epSet in sCompoundSets ) then
                    		spMappedIndex := spCompoundSetMappedIndex( epSet );
                    		fncIndexDomainString += spMappedIndex ;
                    	else
                    		fncIndexDomainString += formatString("%e", epIndex); ;
                    	endif ;
                    	if loopCount < pDim then
                    		fncIndexDomainString += ", " ;
                    	endif ;
                    endwhile ;
                    fncIndexDomainString += ")" ;
                }
                ElementParameter epId {
                    Range: AllIdentifiers;
                    Property: Input;
                }
                ElementParameter epIndex {
                    Range: AllSymbols;
                }
                StringParameter spMappedIndex;
                Parameter p01MappedIndex {
                    Range: binary;
                    Property: Input;
                    Comment: {
                        "When this argument is
                        0, then use original compound index
                        1, then for each compound index, find its set mapped set index and use that."
                    }
                }
                ElementParameter epSet {
                    Range: AllSymbols;
                }
                Parameter pDim;
            }
            Function fncNoCompoundIndices {
                Arguments: (epId);
                Body: {
                    fncNoCompoundIndices := 0 ;
                    pDim := IdentifierDimension( epId );
                    while loopCount <= pDim do
                    	epIndex := DomainIndex( epId, loopCount );
                    	epSet := IndexRange( epIndex );
                    	if epSet in sCompoundSets then
                    		fncNoCompoundIndices += 1 ;
                    	endif ;
                    endwhile ;
                }
                ElementParameter epId {
                    Range: AllIdentifiers;
                    Property: Input;
                }
                ElementParameter epIndex {
                    Range: AllSymbols;
                }
                ElementParameter epSet {
                    Range: AllSymbols;
                }
                Parameter pDim;
            }
            Function fncCompoundIndex {
                Arguments: (epId,pCompoundIndexNo);
                Range: AllIdentifiers;
                Body: {
                    fncCompoundIndex := '' ;
                    pPos := 0 ;
                    pDim := IdentifierDimension( epId );
                    while loopCount <= pDim do
                    	epIndex := DomainIndex( epId, loopCount );
                    	epSet := IndexRange( epIndex );
                    	if epSet in sCompoundSets then
                    		pPos += 1 ;
                    		if pPos = pCompoundIndexNo then
                    			fncCompoundIndex := epIndex ;
                    		endif ;
                    	endif ;
                    endwhile ;
                }
                ElementParameter epId {
                    Range: AllIdentifiers;
                    Property: Input;
                }
                ElementParameter epIndex {
                    Range: AllSymbols;
                }
                ElementParameter epSet {
                    Range: AllSymbols;
                }
                Parameter pDim;
                Parameter pCompoundIndexNo {
                    Property: Input;
                }
                Parameter pPos;
            }
            Function fncCompoundIterateCondition {
                Arguments: (epCompoundIndex);
                Range: string;
                Body: {
                    ! epElementParameterRelationCompoundSet
                    epSet := IndexRange( epCompoundIndex );
                    epP01 := epElementParameterRelationCompoundSet( epSet );
                    fncCompoundIterateCondition := formatString( "%e(%e,%s)", 
                    	epP01, epCompoundIndex,  spCompoundSetMappedIndex(epSet) );
                }
                ElementParameter epCompoundIndex {
                    Range: AllIdentifiers;
                    Property: Input;
                }
                ElementParameter epSet {
                    Range: AllIdentifiers;
                }
                ElementParameter epP01 {
                    Range: AllIdentifiers;
                }
            }
        }
        DeclarationSection secundary_runtime_library_administration {
            Set sCompoundRootSets {
                SubsetOf: AllSets;
                Index: iCompoundRootSet;
                Parameter: eCompoundRootSet;
            }
            Set sCompoundSets {
                SubsetOf: AllSets;
                Index: iCompoundSet;
                Parameter: eCompoundSet;
            }
            Set sCompoundSetsThatAreNotRootSets {
                SubsetOf: AllSets;
                Index: iCompoundSetNotRootSet;
                Parameter: eCompoundSetNotRootSet;
                Definition: sCompoundSets - sCompoundRootSets;
            }
            Set sFoundCompoundSetNumbers {
                SubsetOf: Integers;
                Index: iCompoundSetNo;
                Parameter: eCompoundSetNo;
            }
            ElementParameter epFoundCompoundSets {
                IndexDomain: iCompoundSetNo;
                Range: AllSets;
            }
            ElementParameter epSectionRelationCompoundSetSetMappingSetDeclarations {
                Range: AllIdentifiers;
            }
            ElementParameter epSectionRelationCompoundSetSetMappingSetDeclarationsDeclarations {
                Range: AllIdentifiers;
            }
            ElementParameter epSectionDataShadowDeclarations {
                Range: AllIdentifiers;
            }
            ElementParameter epSectionForwardCopyProcedures {
                Range: AllIdentifiers;
            }
            ElementParameter epProcForwardCopyProcedure {
                Range: AllIdentifiers;
                Default: 'MainExecution';
            }
            ElementParameter epProcBackwardCopyProcedure {
                Range: AllIdentifiers;
                Default: 'MainExecution';
            }
            StringParameter spBodyForwardCopyProcedure;
            StringParameter spBodyLineForwardCopyProcedure;
            ElementParameter epSectionBacwardCopyProcedures {
                Range: AllIdentifiers;
            }
            Set sDataIdentifiers {
                SubsetOf: AllIdentifiers;
                Index: iDataIdentifier;
            }
            Set sDataIdentifiersRequiringShadow {
                SubsetOf: AllIdentifiers;
                Index: iDataIdentifierRequiringDataShadow;
            }
            ElementParameter epShadowsDataIdentifiers {
                IndexDomain: IndexIdentifiers;
                Range: AllIdentifiers;
            }
            StringParameter spCompoundSetMappedIndex {
                IndexDomain: IndexIdentifiers;
            }
            ElementParameter epElementParameterRelationCompoundSet {
                IndexDomain: IndexIdentifiers;
                Range: AllIdentifiers;
            }
            StringParameter spCompoundSetName {
                IndexDomain: IndexIdentifiers;
            }
            StringParameter spCompoundIndexName {
                IndexDomain: (IndexIdentifiers);
            }
            Parameter pCompoundDimension {
                IndexDomain: IndexIdentifiers;
                InitialData: 2;
            }
            Set sIndexDomainPositions {
                SubsetOf: Integers;
                Index: iIDP;
            }
            ElementParameter epIndexDomainSets {
                IndexDomain: (IndexIdentifiers,iIDP);
                Range: AllSets;
            }
            StringParameter spIndexDomainTags {
                IndexDomain: iIDP;
            }
            StringParameter spTag {
                IndexDomain: (IndexIdentifiers,iIDP);
            }
            StringParameter spMappingSetIndex {
                IndexDomain: IndexIdentifiers;
            }
            StringParameter spMappingSetParameter {
                IndexDomain: IndexIdentifiers;
            }
            ElementParameter epElementParameterRelateCompoundSetMappingSetSet {
                Range: AllIdentifiers;
            }
        }
        Section Compound_set_mapping {
            DeclarationSection mapping_set_runtime_library_adminstration {
                StringParameter spCompoundSetMappingRuntimeLibraryName {
                    Definition: "CompoundSetMappingRuntimeLibrary";
                }
                StringParameter spCompoundSetMappingRuntimePrefixName {
                    Definition: "csmrl";
                }
                ElementParameter epCompoundSetMappingRuntimeLibrary {
                    Range: AllIdentifiers;
                }
            }
            Procedure prWorkCreateSetMappingsCompoundSet {
                Body: {
                    empty pCompoundDimension ;
                    sDataIdentifiers := 
                    	{ IndexIdentifiers | IndexIdentifiers in ( AllSets + AllParameters + AllVariables + AllConstraints ) and 
                    	                     ( not ( isRuntimeIdentifier( IndexIdentifiers ) ) ) and 
                    	                     ( not ( IndexIdentifiers in DeprecateCompoundSetUtilities ) ) } ;
                    block where single_column_display := 1 ;
                    	put outf ;
                    	display sDataIdentifiers ;
                    	putclose ;
                    endblock ;	                     
                    
                    ! 0. Ensure there is no previous library with that name.
                    epCompoundSetMappingRuntimeLibrary := StringToElement( AllIdentifiers, 
                    	spCompoundSetMappingRuntimeLibraryName, create: 0);
                    if epCompoundSetMappingRuntimeLibrary then
                    	me::Delete( epCompoundSetMappingRuntimeLibrary );
                    endif ;
                    
                    ! 1. Create a runtime library and a procedure to be filled with assignment statements.
                    epCompoundSetMappingRuntimeLibrary  := 
                    	me::CreateLibrary(spCompoundSetMappingRuntimeLibraryName, 
                    		spCompoundSetMappingRuntimePrefixName );
                    epSectionCompoundSetMappingDeclarations := me::Create( "Mapping_Set_Declarations", 'section', epCompoundSetMappingRuntimeLibrary );
                    
                    for iCompoundSetNo do
                    	prWorkCreateMappingSet1(epFoundCompoundSets(iCompoundSetNo));
                    endfor ;
                    
                    me::Compile( epCompoundSetMappingRuntimeLibrary );
                    
                    block where single_column_display := 1 ;
                    	write secundary_runtime_library_administration to file "secundary.txt" ;
                    endblock ;
                }
                StringParameter spIndexDomainStr0;
                StringParameter spIndexDomainStr1;
                StringParameter spIndexDomainMap0;
                Parameter pNoCompoundIndices;
                StringParameter spIterate;
                StringParameter spIterCond;
                StringParameter spIterFull;
                ElementParameter epCompoundIndex {
                    Range: AllIdentifiers;
                }
                ElementParameter epCompoundSet {
                    Range: AllIdentifiers;
                }
                StringParameter spCompoundSetName;
                File outf {
                    Name: "sDataIdentifiers.txt";
                    Device: Disk;
                    Mode: replace;
                }
            }
            Procedure prWorkCreateMappingSet1 {
                Arguments: (eCompoundSet);
                Body: {
                    block ! Check for erreneous input
                    	if not eCompoundSet then
                    		! Probably the button is pressed before selecting a specific compound root set.
                    		dialogMessage("No compound root set selected");
                    		return ;
                    	endif ;
                    	if not ( eCompoundSet in sCompoundSets ) then
                    		! Shouldn't be possible, but alas, no harm in checking.
                    		dialogMessage("The " + eCompoundSet + " is not a compound set");
                    		return ;
                    	endif ;
                    endblock ;
                    
                    
                    block ! Parse structure of Compound Set
                    
                    	block  ! Get domain string with kommas
                    		spSubsetOfString := AttributeToString( eCompoundSet, 'subset of' );
                     		pNoKommas := StringOccurrences( spSubsetOfString, "," );
                    		while not pNoKommas do
                    			! Go find the root set.
                    			if SubString( spSubsetOfString, 1, 1 ) = "("  then
                    				spSubsetOfString := SubString( spSubsetOfString, 2, StringLength( spSubsetOfString ) -1 );
                    			endif ;
                    			epDomainSet := StringToElement( AllSets, spSubsetOfString, create:0);
                    			if not epDomainSet then
                    				raise error "bug" ;
                    			endif ;
                    			spSubsetOfString := AttributeToString( epDomainSet, 'subset of' );
                    			pNoKommas := StringOccurrences( spSubsetOfString, "," );
                    		endwhile ;
                    	endblock ;
                    
                    	block ! Parse the subset of string into atomic domain sets.
                    		prRemoveSpaces( spSubsetOfString );
                    		pCompoundDimension(eCompoundSet) := pNoKommas + 1 ;
                    		sIndexDomainPositions := ElementRange(1,pCompoundDimension(eCompoundSet));
                    		for iIDP do
                    			if iIDP = first( sIndexDomainPositions ) then
                    				pBegPos := 2 ;
                    				pEndPos := FindNthString( spSubsetOfString, ",", 1 ) - 1 ;
                    			elseif iIDP = last( sIndexDomainPositions ) then
                    				pBegPos := FindNthString( spSubsetOfString, ",", pNoKommas ) + 1 ;
                    				pEndPos := StringLength( spSubsetOfString  ) - 1 ;
                    			else
                    				pIndexNo := iIDP ;
                    				pBegPos := FindNthString( spSubsetOfString, ",", pIndexNo - 1 ) + 1 ;
                    				pEndPos := FindNthString( spSubsetOfString, ",", pIndexNo     ) - 1 ;
                    			endif ;
                    			spAtomicDomainSetName := SubString( spSubsetOfString, pBegPos, pEndPos );
                    			epIndexDomainSets(eCompoundSet, iIDP ) := 
                    				StringToElement( AllSets, spAtomicDomainSetName, create:0);
                    			if not epIndexDomainSets(eCompoundSet, iIDP ) then raise error "bug" ; endif ;
                    		endfor ;
                    	endblock ;
                    
                    	block ! Parse the tags string into atomic tag strings
                    		spTagsString := AttributeToString( eCompoundSet, 'tags' );
                    		if spTagsString then
                    			prRemoveSpaces( spTagsString );
                    			for iIDP do
                    				if iIDP = first( sIndexDomainPositions ) then
                    					pBegPos := 2 ;
                    					pEndPos := FindNthString( spTagsString, ",", 1 ) - 1 ;
                    				elseif iIDP = last( sIndexDomainPositions ) then
                    					pBegPos := FindNthString( spTagsString, ",", pNoKommas ) + 1 ;
                    					pEndPos := StringLength( spTagsString  ) - 1 ;
                    				else
                    					pIndexNo := iIDP ;
                    					pBegPos := FindNthString( spTagsString, ",", pIndexNo - 1 ) + 1 ;
                    					pEndPos := FindNthString( spTagsString, ",", pIndexNo     ) - 1 ;
                    				endif ;
                    				spTag(eCompoundSet,iIDP) := SubString( spTagsString, pBegPos, pEndPos );
                    			endfor ;
                    		else
                    			raise error "Please specify tags for " + spCompoundSetName(eCompoundSet) + ".  We'll need them for the data conversion.";
                    		endif ;
                    	endblock ;
                    
                    endblock ;
                    
                    ! display "--------DEBUG---------------", eCompoundSet, epIndexDomainSets, spTag ;
                    
                    block ! Create and fill runtime declaration section Declarations_Mapping_Set_<Cname>
                    
                    	block ! comment
                    	! <CName> below is the name of the compound set.
                    	!
                    	! Per compound set, we create a declaration section Declarations_Mapping_Set_<Cname> with the following declarations:
                    	! 
                    	! Actual Mapping Set:
                    	! CM --> sMappingSet_<CName>_Set with index iMS_<CName>
                    	! RM --> sMappingSet_<CName>_Relation
                    	!
                    	! Element parameters for tags (only if tags string)
                    	! EPTS(i_cm) --> epTag_<CName>_<Tag>(iMS_<CName>)
                    	! ...
                    	!
                    	! Element parameters for caching
                    	! EPHS --> epHelper_<CName>_pos
                    	! ...
                    	endblock ;
                    
                    	block ! Determine name of compound set and compound index.
                    		spCompoundSetName(eCompoundSet) := FormatString("%e", eCompoundSet );
                    		spCompoundIndexName(eCompoundSet) := AttributeToString( eCompoundSet, 'index' );
                    		if spCompoundIndexName(eCompoundSet) then ! if there are multiple indices take the first one.
                    			pBegPos := FindString( spCompoundIndexName(eCompoundSet), "," );
                    			if pBegPos then
                    				spCompoundIndexName(eCompoundSet) := SubString( spCompoundIndexName(eCompoundSet), 1, pBegPos -1 );
                    			endif ;
                    		else ! Require an index, it is needed later on.
                    			raise error "Compound set " + spCompoundSetName(eCompoundSet) + " does not have an index.  " +
                    			            "Perhaps the set can be deleted anyway, or perhaps you can give this se an index." ;
                    		endif ;
                    	endblock ;
                    
                    	epDeclarationSectionMappingSet :=  me::Create( "Mapping_Set_Declarations_" + spCompoundSetName(eCompoundSet), 
                    		'declaration', epSectionCompoundSetMappingDeclarations );
                    
                    	block ! Declare Set Mapping Set.
                    		epMappingSetSet(eCompoundSet) := me::Create( "sMappingSet_"+ spCompoundSetName(eCompoundSet)+"_Set" , 'set', epDeclarationSectionMappingSet );
                    		spMappingSetIndex(eCompoundSet) := "iMS_"+ spCompoundSetName(eCompoundset) ;
                    		me::SetAttribute( epMappingSetSet(eCompoundSet), 'index', spMappingSetIndex(eCompoundSet));
                    		spMappingSetParameter(eCompoundSet) := "epMS_"+ spCompoundSetName(eCompoundset) ;
                    		me::SetAttribute( epMappingSetSet(eCompoundSet), 'parameter', spMappingSetParameter(eCompoundSet));
                    		spCompoundSetMappedIndex( eCompoundSet ) := spMappingSetIndex(eCompoundSet) ;
                    	endblock ;
                    
                    	block ! Declare set mapping relation.
                    		epMappingSetRelation(eCompoundSet) := me::Create( "sMappingSet_"+ spCompoundSetName(eCompoundset)+"_Relation" , 
                    			'set', epDeclarationSectionMappingSet );
                    		spMappingSetRelationSubsetOf := "(";
                    		for iIDP do
                    			spMappingSetRelationSubsetOf += formatString("%e,", epIndexDomainSets(eCompoundSet,iIDP) );
                    		endfor ;
                    		spMappingSetRelationSubsetOf += formatString("%e)", epMappingSetSet(eCompoundSet) );
                    		me::SetAttribute( epMappingSetRelation(eCompoundSet), 'subset of', spMappingSetRelationSubsetOf);
                    	endblock ;
                    
                    	block ! Declare element parameters that are to be used as a substitution for tags.
                    		if spTagsString then
                    			for iIDP do
                    				epElementParameterForTag(eCompoundSet,iIDP) := 
                    					me::Create( "epTag_"+ spCompoundSetName(eCompoundset)+"_"+spTag(eCompoundSet,iIDP), 
                    						'element parameter', epDeclarationSectionMappingSet );
                    				me::SetAttribute( epElementParameterForTag(eCompoundSet,iIDP), 'index domain', spMappingSetIndex(eCompoundSet) );
                    				me::SetAttribute( epElementParameterForTag(eCompoundSet,iIDP), 'range',
                    					formatString("%e",epIndexDomainSets(eCompoundSet,iIDP)) );
                    			endfor ;
                    		endif ;
                    	endblock ;
                    
                    	block ! Declare the helper element parameters.
                    		for iIDP do
                    			epElementParameterHelp(eCompoundSet,iIDP) := 
                    				me::Create( formatString("epHelp_%s_%e",spCompoundSetName(eCompoundset), iIDP),
                    					'element parameter', epDeclarationSectionMappingSet );
                    			me::SetAttribute( epElementParameterHelp(eCompoundSet,iIDP), 'range',
                    				formatString("%e",epIndexDomainSets(eCompoundSet,iIDP)) );
                    		endfor ;
                    	endblock ;
                    
                    
                    endblock ;
                }
                DeclarationSection Argument_Declaration {
                    ElementParameter eCompoundSet {
                        Range: sCompoundSets;
                        Property: Input;
                    }
                }
                DeclarationSection Local_Declarations {
                    StringParameter spSubsetOfString;
                    ElementParameter epDomainSet {
                        Range: AllIdentifiers;
                    }
                    Parameter pNoKommas;
                    StringParameter spAtomicDomainSetName;
                    Parameter pBegPos;
                    Parameter pEndPos;
                    Parameter pIndexNo;
                    StringParameter spTagsString;
                    ElementParameter epDeclarationSectionMappingSet {
                        Range: AllIdentifiers;
                    }
                    StringParameter spMappingSetRelationSubsetOf;
                    ElementParameter epProcFillSetMapping {
                        Range: AllIdentifiers;
                    }
                }
            }
        }
        Section Compound_set_shadow {
            DeclarationSection shadow_runtime_library_adminstration {
                StringParameter spCompoundSetShadowRuntimeLibraryName {
                    Definition: "CompoundSetShadowRuntimeLibrary";
                }
                StringParameter spCompoundSetShadowRuntimePrefixName {
                    Definition: "cssrl";
                }
                ElementParameter epCompoundSetShadowRuntimeLibrary {
                    Range: AllIdentifiers;
                }
            }
            Procedure prWorkCreateShadowCompoundSet {
                Body: {
                    
                    Read from file "sDataIdentifiers.txt" ;
                    Read from file "secundary.txt" ;
                    
                    epSectionCompoundSetMappingDeclarations := StringToElement( AllIdentifiers, "Mapping_Set_Declarations" );
                    if not epSectionCompoundSetMappingDeclarations then
                    	raise error "Please ensure that the section you just imported in the main model is named \"Mapping_Set_Declarations\"" ;
                    endif ; 
                    
                    
                    ! 0. Ensure there is no previous library with that name.
                    epCompoundSetShadowRuntimeLibrary := StringToElement( AllIdentifiers, spCompoundSetShadowRuntimeLibraryName, create: 0);
                    if epCompoundSetShadowRuntimeLibrary then
                    	me::Delete( epCompoundSetShadowRuntimeLibrary );
                    endif ;
                    
                    ! 1. Create a runtime library and a procedure to be filled with assignment statements.
                    epCompoundSetShadowRuntimeLibrary  := 
                    	me::CreateLibrary(spCompoundSetShadowRuntimeLibraryName, 
                    		spCompoundSetShadowRuntimePrefixName );
                    epSectionRelationCompoundSetSetMappingSetDeclarations := me::Create( "Relation_Compound_Set_Set_Mapping_Set_Declarations", 'section', epCompoundSetShadowRuntimeLibrary );
                    epSectionDataShadowDeclarations := me::Create( "Data_Shadow_Declarations", 'section', epCompoundSetShadowRuntimeLibrary );
                    epSectionForwardCopyProcedures := me::Create( "Forward_Copy_Procedures", 'section', epCompoundSetShadowRuntimeLibrary );
                    epProcForwardCopyProcedure := me::Create( "prProcForwardCopyProcedure", 'procedure', epSectionForwardCopyProcedures );
                    epSectionBacwardCopyProcedures := me::Create( "Backward_Copy_Procedures", 'section', epCompoundSetShadowRuntimeLibrary );
                    epSectionRelationCompoundSetSetMappingSetDeclarationsDeclarations := me::Create( "Relation_Compound_Set_Set_Mapping_Set_Declarations_Declarations", 'declaration', epSectionRelationCompoundSetSetMappingSetDeclarations );
                    
                    for iCompoundSetNo do
                    	eCompoundSet := epFoundCompoundSets(iCompoundSetNo) ;
                    	sIndexDomainPositions := ElementRange( 1, pCompoundDimension(eCompoundSet) );
                    	epElementParameterForTag( eCompoundSet, iIDP ) := 
                    		StringToElement( AllIdentifiers,
                    			formatString("epTag_%s_%s", spCompoundSetName( eCompoundSet ), spTag( eCompoundSet, iIDP ) ) );
                    	epElementParameterHelp( eCompoundSet, iIDP ) := 
                    		StringToElement( AllIdentifiers,
                    			formatString("epHelp_%s_%e", spCompoundSetName( eCompoundSet ), iIDP ) );
                    	epMappingSetSet( eCompoundSet ) := StringToElement( AllIdentifiers,
                    		formatSTring("sMappingSet_%s_Set", spCompoundSetName(eCompoundSet) ) );
                    	epMappingSetRelation( eCompoundSet ) := StringToElement( AllIdentifiers,
                    		formatSTring("sMappingSet_%s_Relation", spCompoundSetName(eCompoundSet) ) );
                    	prWorkCreateMappingSet2(eCompoundSet);
                    endfor ;
                    
                    block ! Determine set of identifiers that require a data shadow
                    	empty sDataIdentifiersRequiringShadow ;
                    	empty epShadowsDataIdentifiers ;
                    	spBodyForwardCopyProcedure := "" ;
                    	for iCompoundSetNo do
                    		!prWorkCreateMappingSet(epFoundCompoundSets(iCompoundSetNo));
                    		!"prProcFillSetMapping" + spCompoundSetName
                    		epCompoundSet := epFoundCompoundSets(iCompoundSetNo);
                    		spCompoundSetName(epCompoundSet) := FormatString("%e", epCompoundSet );
                    		spBodyLineForwardCopyProcedure := "prProcFillSetMapping"+spCompoundSetName(epCompoundSet)+"();\n";
                    		spBodyForwardCopyProcedure += spBodyLineForwardCopyProcedure ;
                    	endfor ;
                    	spBodyForwardCopyProcedure += "\n" ;
                    	for iDataIdentifier do 
                    		if fncRequiresDataShadow( iDataIdentifier ) then
                    			sDataIdentifiersRequiringShadow += iDataIdentifier;
                    			epShadowsDataIdentifiers(iDataIdentifier) := me::Create( iDataIdentifier,
                    				IdentifierType(iDataIdentifier), epSectionDataShadowDeclarations);
                    			me::SetAttribute( epShadowsDataIdentifiers(iDataIdentifier), 'index domain',
                    				fncIndexDomainString( iDataIdentifier, p01MappedIndex: 1 ) );
                    			spIndexDomainStr0 := fncIndexDomainString( iDataIdentifier, 0 );
                    			spIndexDomainStr1 := fncIndexDomainString( iDataIdentifier, 1 );
                    			pNoCompoundIndices := fncNoCompoundIndices( iDataIdentifier );
                    			if pNoCompoundIndices = 1 then
                    				epCompoundIndex := fncCompoundIndex( iDataIdentifier, 1 );
                    				spIterate := formatString("%e", epCompoundIndex );
                    				spIterCond := fncCompoundIterateCondition( epCompoundIndex );
                    			else
                    				raise error "NIY" ;
                    			endif ;
                    			spIterFull := spIterate + " | " + spIterCond ;
                    			spBodyLineForwardCopyProcedure := formatString( "%e%s := sum( %s, ::%e%s );\n", 
                    				epShadowsDataIdentifiers(iDataIdentifier), spIndexDomainStr1, spIterFull,			
                    				iDataIdentifier, spIndexDomainStr0);
                    			spBodyForwardCopyProcedure += spBodyLineForwardCopyProcedure ;
                    		endif ;
                    	endfor ;
                    	me::SetAttribute( epProcForwardCopyProcedure, 'body', spBodyForwardCopyProcedure );
                    	!display "------------DEBUG---------", sDataIdentifiersRequiringShadow ;
                    endblock ;
                    
                    me::Compile( epCompoundSetShadowRuntimeLibrary  );
                    
                    block where single_column_display := 1 ;
                    	write epShadowsDataIdentifiers to file "IdentifiersWithShadows.txt" ;
                    endblock ;
                }
                StringParameter spIndexDomainStr0;
                StringParameter spIndexDomainStr1;
                StringParameter spIndexDomainMap0;
                Parameter pNoCompoundIndices;
                StringParameter spIterate;
                StringParameter spIterCond;
                StringParameter spIterFull;
                ElementParameter epCompoundIndex {
                    Range: AllIdentifiers;
                }
                ElementParameter epCompoundSet {
                    Range: AllIdentifiers;
                }
            }
            Procedure prWorkCreateMappingSet2 {
                Arguments: (eCompoundSet);
                Body: {
                    
                    prWorkCreateBinaryRelatingCompoundIndexMappingIndex(eCompoundSet);
                    
                    prWorkCreateFillSetMappingProcedure(eCompoundSet);
                }
                DeclarationSection Argument_Declaration {
                    ElementParameter eCompoundSet {
                        Range: sCompoundSets;
                        Property: Input;
                    }
                }
            }
            Procedure prWorkCreateBinaryRelatingCompoundIndexMappingIndex {
                Arguments: (eCompoundSet);
                Body: {
                    block ! Relate the compound set index and the set mapping set index
                    	spCompoundSetName(eCompoundSet) := FormatString( "%e", eCompoundSet );
                    	epElementParameterRelateCompoundSetMappingSetSet := me::Create(
                    		formatString( "p01CompoundSetMappingSet_%s", spCompoundSetName(eCompoundSet)), 'parameter',
                    			epSectionRelationCompoundSetSetMappingSetDeclarationsDeclarations );
                    	me::SetAttribute( epElementParameterRelateCompoundSetMappingSetSet, 'index domain', 
                    		formatString( "(%s,%s)",spCompoundIndexName(eCompoundSet), spMappingSetIndex(eCompoundSet)));
                    	me::SetAttribute( epElementParameterRelateCompoundSetMappingSetSet, 'range', "binary" );
                    	epElementParameterRelationCompoundSet(eCompoundSet) := epElementParameterRelateCompoundSetMappingSetSet;
                    endblock ;
                }
                ElementParameter eCompoundSet {
                    Range: sCompoundSets;
                    Property: Input;
                }
            }
            Procedure prWorkCreateFillSetMappingProcedure {
                Arguments: (eCompoundSet);
                Body: {
                    block ! Create procedure to fill the data of all the set mapping identifiers 
                    	epProcFillSetMapping := me::Create( "prProcFillSetMapping" + spCompoundSetName(eCompoundSet),
                    		'procedure', epSectionForwardCopyProcedures );
                    	spBody := "" ;
                    
                    	spBodyLine := FormatString( "for %s do \n\n", spCompoundIndexName(eCompoundSet) ); 
                    	spBody += spBodyLine ;
                    
                    	block ! Assign values to the cache element parameters.
                    		spBodyLine := "        ! Cache the components of tuple h in element parameters.\n" ; 
                    		spBody += spBodyLine ;
                    		for iIDP do
                    			spBodyLine := FormatString( "       %e := %s.%s ;\n", 
                    				epElementParameterHelp(eCompoundSet,iIDP), 
                    				spCompoundIndexName(eCompoundSet), spTag(eCompoundSet,iIDP) );			
                    			spBody += spBodyLine ;
                    		endfor ;
                    	endblock ;
                    
                    	block ! Create the look alike element.
                    		spBodyLine := "\n        ! Create an element that looks like a tuple, but is just a string and\n" ; 
                    		spBody += spBodyLine ;
                    		spBodyLine := "        ! add this element to the set mapping set " + spCompoundSetName(eCompoundSet) + "\n"; 
                    		spBody += spBodyLine ;
                    		spBodyLine := formatString("        SetElementAdd(%e,%s,\n                formatString(\"(", 
                    			epMappingSetSet(eCompoundSet),spMappingSetParameter(eCompoundSEt));
                    		for iIDP do
                    			spBodyLine += "%e" ;
                    			if iIDP = last(sIndexDomainPositions) then
                    				spBodyLine += ")\"\n                        " ;
                    			else
                    				spBodyLine += "," ;
                    			endif ;
                    		endfor ;
                    		for iIDP do
                    			spBodyLine += formatString(",%e", epElementParameterHelp(eCompoundSet,iIDP));
                    		endfor ;
                    		spBodyLine += "));\n\n" ;
                    		spBody += spBodyLine ;
                    	endblock ;
                    
                    	block ! Add N+1 dim tuple to the relation.
                    		spBodyLine := "        ! Create a N+1 dim tuple and add this to the set mapping relation\n" ;
                    		spBody += spBodyLine ;
                    		spBodyLine := formatString("        %e += {(", epMappingSetRelation(eCompoundSet) );
                    		for iIDP do
                    			spBodyLine += formatString("%e,",epElementParameterHelp(eCompoundSet,iIDP));
                    		endfor ;
                    		spBodyLine += spMappingSetParameter(eCompoundSet) + ")};\n\n";
                    		spBody += spBodyLine ;
                    	endblock ;
                    
                    	block ! Fill in the element parameters that map the tags.
                    		spBodyLine := "        ! Fill in the element parameters that map the tags.\n" ;
                    		spBody += spBodyLine ;
                    		for iIDP do
                    			spBodyLine := formatString("        %e(%s) := %s ;\n",
                    				epElementParameterForTag(eCompoundSet,iIDP), 
                    				spMappingSetParameter(eCompoundSet), epElementParameterHelp(eCompoundSet,iIDP) );
                    			spBody += spBodyLine ;
                    		endfor ;
                    	endblock ;
                    
                    	block ! fill the relation between compound element and look alike element.
                    		spBodyLine := "\n        !  fill the relation between compound element and look alike element.\n" ;
                    		spBody += spBodyLine ;
                    		spBodyLine := formatString("        %e(%s,%s) := 1 ;\n",
                    			epElementParameterRelateCompoundSetMappingSetSet, 
                    			spCompoundIndexName(eCompoundSet), spMappingSetParameter(eCompoundSEt) );
                    		spBody += spBodyLine ;
                    	endblock ;
                    
                    	spBodyLine := "\n" ; spBody += spBodyLine ;
                    	spBodyLine := "endfor ;\n" ; spBody += spBodyLine ;
                    	me::SetAttribute( epProcFillSetMapping, 'body', spBody );
                    
                    endblock ;
                }
                ElementParameter eCompoundSet {
                    Range: sCompoundSets;
                    Property: Input;
                }
                DeclarationSection Local_Declarations {
                    ElementParameter epProcFillSetMapping {
                        Range: AllIdentifiers;
                    }
                    StringParameter spBody;
                    StringParameter spBodyLine;
                }
            }
        }
        Section Shadow_To_Case {
            Set sContentTypeForward {
                SubsetOf: AllIdentifiers;
            }
            Procedure prWorkSaveShadowToCase {
                Body: {
                    sContentTypeForward := { IndexIdentifiers | not epShadowsDataIdentifiers( IndexIdentifiers ) } ;
                    AllCaseFileContentTypes += data { 'dcsu::sContentTypeForward' } ;
                    CurrentCaseFileContentType := 'dcsu::sContentTypeForward' ;
                    CaseFileSave( "forward/example.data", CurrentCaseFileContentType );
                }
                Set sTemp {
                    SubsetOf: AllIdentifiers;
                }
            }
        }
        Section Case_to_Original {
            Procedure prWorkGenerateBackward {
                Body: {
                    read from file "IdentifiersWithShadows.txt" ;
                    if epProcBackwardCopyProcedure then
                    	me::Delete( epProcBackwardCopyProcedure );
                    endif ;
                    epProcBackwardCopyProcedure := StringToElement( AllIdentifiers, "cssrl::prProcBackwardCopyProcedure", create:0);
                    if epProcBackwardCopyProcedure then
                    	me::Delete( epProcBackwardCopyProcedure );
                    endif ;
                    epProcBackwardCopyProcedure := me::Create( "prProcBackwardCopyProcedure", 'procedure', epSectionBacwardCopyProcedures );
                    spBody := "";
                    spBodyLine := "";
                    for IndexIdentifiers | dcsu::epShadowsDataIdentifiers(IndexIdentifiers) do
                    	spIndexDomain := fncIndexDomainString(IndexIdentifiers,0);
                    	spBodyLine := FormatString( "%s%s := %s%s;\n", 
                    		IndexIdentifiers, spIndexDomain,
                    		dcsu::epShadowsDataIdentifiers(IndexIdentifiers), fncIndexDomainString(IndexIdentifiers,0) );
                    	spBody += spBodyLine ;
                    endfor ;
                    me::SetAttribute( epProcBackwardCopyProcedure, 'body', spBody);
                    me::Compile( epCompoundSetShadowRuntimeLibrary  );
                }
                Comment: "This procedure copies the data in the shadow identifiers, as read in from the forwarded case, to the original identifiers.";
                StringParameter spBody;
                StringParameter spBodyLine;
                StringParameter spIndexDomain;
            }
        }
        Section Attic {
            Procedure LibraryInitialization {
                Comment: "Add initialization statements here that do not require any other library being initialized already.";
            }
            Procedure PostLibraryInitialization {
                Comment: {
                    "Add initialization statements here that require another library to be initialized already,
                    or add statements that require the Data Management module to be initialized."
                }
            }
            Procedure PreLibraryTermination {
                Body: {
                    return 1;
                }
                Comment: {
                    "Add termination statements here that require all other libraries to be still alive.
                    Return 1 if you allow the termination sequence to continue.
                    Return 0 if you want to cancel the termination sequence."
                }
            }
            Procedure LibraryTermination {
                Body: {
                    return 1;
                }
                Comment: {
                    "Add termination statements here that do not require other libraries to be still alive.
                    Return 1 to allow the termination sequence to continue.
                    Return 0 if you want to cancel the termination sequence.
                    It is recommended to only use the procedure PreLibraryTermination to cancel the termination sequence and let this procedure always return 1."
                }
            }
        }
    }
}
