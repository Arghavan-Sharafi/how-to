## ams_version=1.0

LibraryModule DeprecateCompoundSetUtilities {
    Prefix: dcsu;
    Interface: PublicSection;
    Property: NoSave;
    Section PublicSection {
        Section Identify_compound_sets {
            Set sCompoundRootSets {
                SubsetOf: AllSets;
                Index: iCompoundRootSet;
                Parameter: eCompoundRootSet;
            }
            Set sCompoundSets {
                SubsetOf: AllSets;
                Index: iCompoundSet;
                Parameter: eCompoundSet;
            }
            Set sCompoundSetsThatAreNotRootSets {
                SubsetOf: AllSets;
                Index: iCompoundSetNotRootSet;
                Parameter: eCompoundSetNotRootSet;
                Definition: sCompoundSets - sCompoundRootSets;
            }
            Set sFoundCompoundSetNumbers {
                SubsetOf: Integers;
                Index: iCompoundSetNo;
                Parameter: eCompoundSetNo;
            }
            ElementParameter epFoundCompoundSets {
                IndexDomain: iCompoundSetNo;
                Range: AllSets;
            }
            Procedure prIdentifyCompoundSets {
                Body: {
                    sCompoundRootSets := {} ;
                    pCompoundSetNo := 0;
                    for IndexSets do
                    	pSubsetOfStr := AttributeToString( IndexSets, 'subset of' );	
                    	if StringOccurrences( pSubsetOfStr, "," ) then
                    		if AttributeToString( IndexSets, 'index'     ) or
                    		   AttributeToString( IndexSets, 'parameter' )    then
                    		   	sCompoundRootSets += IndexSets ;
                    		   	! Add the compound set referenced by IndexSets to the collection of compound sets.
                    		   	pCompoundSetNo += 1 ;
                    		   	sFoundCompoundSetNumbers += pCompoundSetNo ;
                    		   	eCompoundSetNo := pCompoundSetNo ;
                    		   	epFoundCompoundSets( eCompoundSetNo ) := IndexSets ;
                    		endif ;
                    	endif ;
                    endfor ;
                    
                    sCompoundSets := sCompoundRootSets ;
                    p01AdditionMade := Card( sCompoundRootSets ) <> 0 ;
                    while p01AdditionMade do
                    	p01AdditionMade := 0;
                    	for IndexSets do
                    		if not ( IndexSets in sCompoundSets ) then
                    
                    			pSubsetOfstr := AttributeToString( IndexSets, 'subset of' );
                    
                    			! Eat away the parentheses '(' and ')' possibly surrounding the domain identifier.
                    			if pSubsetOfStr then 
                    				if substring(pSubsetOfStr,1,1) = "(" then
                    					pSubsetOfStr := substring(pSubsetOfStr,2,StringLength(pSubsetOfStr)-1);
                    				endif ;
                    			endif ;
                    
                    			! Check if the domain set of this IndexSet is a compound set.
                    			if pSubsetOfStr and not StringOccurrences( pSubsetOfStr, "," ) then
                    				epDomainSet := StringToElement(AllIdentifiers, pSubsetOfStr, create:0);
                    				if epDomainSet and epDomainSet in sCompoundSets then
                    					sCompoundSets += IndexSets;
                    					p01AdditionMade := 1;
                    					! Add the compound set referenced by IndexSets to the collection of compound sets.
                    					pCompoundSetNo += 1 ;
                    					sFoundCompoundSetNumbers += pCompoundSetNo ;
                    					eCompoundSetNo := pCompoundSetNo ;
                    					epFoundCompoundSets( eCompoundSetNo ) := IndexSets ;
                    				endif ;
                    			endif ;
                    
                    		endif ;
                    	endfor ;
                    endwhile ;
                }
                Comment: {
                    "This procedure will search the application for compound sets and put the names in the set dcsu::sCompoundSets.
                    In addition, the compound root sets will be placed in the set dcsu::sCompoundRootSets."
                }
                StringParameter pSubsetOfStr;
                Parameter p01AdditionMade {
                    Range: binary;
                }
                ElementParameter epDomainSet {
                    Range: AllSets;
                }
                Parameter pCompoundSetNo;
            }
        }
        Section create_compound_set_mappings {
            Procedure prCreateSetMappingsCompoundSet {
                Body: {
                    !block
                    	prIdentifyCompoundSets();
                    	prWorkCreateSetMappingsCompoundSet();
                    !onerror err do
                    !	DialogMessage( errh::Message( err ));
                    !	errh::MarkAsHandled(err);
                    !endblock ;
                }
                ElementParameter err {
                    Range: errh::PendingErrors;
                }
            }
        }
    }
    Section PrivateSection {
        DeclarationSection runtime_library_adminstration {
            StringParameter spCompoundSetMappingRuntimeLibraryName {
                Definition: "CompoundSetMappingRuntimeLibrary";
            }
            StringParameter spCompoundSetMappingRuntimePrefixName {
                Definition: "csmrl";
            }
            ElementParameter epCompoundSetMappingRuntimeLibrary {
                Range: AllIdentifiers;
            }
            ElementParameter epSectionCompoundSetMappingDeclarations {
                Range: AllIdentifiers;
            }
            ElementParameter epSectionRelationCompoundSetSetMappingSetDeclarations {
                Range: AllIdentifiers;
            }
            ElementParameter epSectionRelationCompoundSetSetMappingSetDeclarationsDeclarations {
                Range: AllIdentifiers;
            }
            ElementParameter epSectionDataShadowDeclarations {
                Range: AllIdentifiers;
            }
            ElementParameter epSectionForwardCopyProcedures {
                Range: AllIdentifiers;
            }
            ElementParameter epProcForwardCopyProcedure {
                Range: AllIdentifiers;
            }
            StringParameter spBodyForwardCopyProcedure;
            StringParameter spBodyLineForwardCopyProcedure;
            ElementParameter epSectionBacwardCopyProcedures {
                Range: AllIdentifiers;
            }
            Set sDataIdentifiers {
                SubsetOf: AllIdentifiers;
                Index: iDataIdentifier;
            }
            Set sDataIdentifiersRequiringShadow {
                SubsetOf: AllIdentifiers;
                Index: iDataIdentifierRequiringDataShadow;
            }
            ElementParameter epShadowsDataIdentifiers {
                IndexDomain: IndexIdentifiers;
                Range: AllIdentifiers;
            }
            StringParameter spCompoundSetMappedIndex {
                IndexDomain: IndexIdentifiers;
            }
            ElementParameter epElementParameterRelationCompoundSet {
                IndexDomain: IndexIdentifiers;
                Range: AllIdentifiers;
            }
        }
        Section Private_Identify_Compound_Sets;
        Section Creating_compound_set_mappings {
            Section Internal_utilities {
                Procedure prRemoveSpaces {
                    Arguments: (spStr);
                    Body: {
                        pSpacePos := FindString( spStr, " " );
                        while pSpacePos do
                        	if pSpacePos = 1 then
                        		spStr := substring( spStr, 2, StringLength( spStr ) );
                        	elseif pSpacePos = StringLength( spStr ) then
                        		spStr := substring( spStr, 1, StringLength( spStr ) - 1 );	
                        	else
                        		spStr := 
                        			substring( spStr, 1, pSpacePos - 1 ) + 
                        			substring( spStr, pSpacePos + 1, StringLength( spStr ) );
                        	endif ;
                        	pSpacePos := FindString( spStr, " " );
                        endwhile ;
                    }
                    StringParameter spStr {
                        Property: InOut;
                    }
                    Parameter pSpacePos;
                }
            }
            DeclarationSection Declarations_for_creating_compound_set_mappings;
            Procedure prWorkCreateSetMappingsCompoundSet {
                Body: {
                    sDataIdentifiers := 
                    	{ IndexIdentifiers | IndexIdentifiers in ( AllSets + AllParameters + AllVariables + AllConstraints ) and 
                    	                     ( not ( isRuntimeIdentifier( IndexIdentifiers ) ) ) and 
                    	                     ( not ( IndexIdentifiers in DeprecateCompoundSetUtilities ) ) } ;
                    
                    ! 0. Ensure there is no previous library with that name.
                    epCompoundSetMappingRuntimeLibrary := StringToElement( AllIdentifiers, spCompoundSetMappingRuntimeLibraryName, create: 0);
                    if epCompoundSetMappingRuntimeLibrary then
                    	me::Delete( epCompoundSetMappingRuntimeLibrary );
                    endif ;
                    
                    ! 1. Create a runtime library and a procedure to be filled with assignment statements.
                    epCompoundSetMappingRuntimeLibrary  := 
                    	me::CreateLibrary(spCompoundSetMappingRuntimeLibraryName, 
                    		spCompoundSetMappingRuntimePrefixName );
                    !e_proc := me::Create( "WorkCreateCopyOfElement", 'procedure', e_lib );
                    epSectionCompoundSetMappingDeclarations := me::Create( "Mapping_Set_Declarations", 'section', epCompoundSetMappingRuntimeLibrary );
                    epSectionRelationCompoundSetSetMappingSetDeclarations := me::Create( "Relation_Compound_Set_Set_Mapping_Set_Declarations", 'section', epCompoundSetMappingRuntimeLibrary );
                    epSectionDataShadowDeclarations := me::Create( "Data_Shadow_Declarations", 'section', epCompoundSetMappingRuntimeLibrary );
                    epSectionForwardCopyProcedures := me::Create( "Forward_Copy_Procedures", 'section', epCompoundSetMappingRuntimeLibrary );
                    epProcForwardCopyProcedure := me::Create( "prProcForwardCopyProcedure", 'procedure', epSectionForwardCopyProcedures );
                    epSectionBacwardCopyProcedures := me::Create( "Backward_Copy_Procedures", 'section', epCompoundSetMappingRuntimeLibrary );
                    epSectionRelationCompoundSetSetMappingSetDeclarationsDeclarations := me::Create( "Relation_Compound_Set_Set_Mapping_Set_Declarations_Declarations", 'declaration', epSectionRelationCompoundSetSetMappingSetDeclarations );
                    
                    for iCompoundSetNo do
                    	prWorkCreateMappingSet(epFoundCompoundSets(iCompoundSetNo));
                    endfor ;
                    
                    block ! Determine set of identifiers that require a data shadow
                    	empty sDataIdentifiersRequiringShadow ;
                    	empty epShadowsDataIdentifiers ;
                    	spBodyForwardCopyProcedure := "" ;
                    	for iCompoundSetNo do
                    		!prWorkCreateMappingSet(epFoundCompoundSets(iCompoundSetNo));
                    		!"prProcFillSetMapping" + spCompoundSetName
                    		epCompoundSet := epFoundCompoundSets(iCompoundSetNo);
                    		spCompoundSetName := FormatString("%e", epCompoundSet );
                    		spBodyLineForwardCopyProcedure := "        prProcFillSetMapping"+spCompoundSetName+"();\n";
                    		spBodyForwardCopyProcedure += spBodyLineForwardCopyProcedure ;
                    	endfor ;
                    	spBodyForwardCopyProcedure += "\n" ;
                    	for iDataIdentifier do 
                    		if fncRequiresDataShadow( iDataIdentifier ) then
                    			sDataIdentifiersRequiringShadow += iDataIdentifier;
                    			epShadowsDataIdentifiers(iDataIdentifier) := me::Create( iDataIdentifier,
                    				IdentifierType(iDataIdentifier), epSectionDataShadowDeclarations);
                    			me::SetAttribute( epShadowsDataIdentifiers(iDataIdentifier), 'index domain',
                    				fncIndexDomainString( iDataIdentifier, p01MappedIndex: 1 ) );
                    			spIndexDomainStr0 := fncIndexDomainString( iDataIdentifier, 0 );
                    			spIndexDomainStr1 := fncIndexDomainString( iDataIdentifier, 1 );
                    			pNoCompoundIndices := fncNoCompoundIndices( iDataIdentifier );
                    			if pNoCompoundIndices = 1 then
                    				epCompoundIndex := fncCompoundIndex( iDataIdentifier, 1 );
                    				spIterate := formatString("%e", epCompoundIndex );
                    				spIterCond := fncCompoundIterateCondition( epCompoundIndex );
                    			else
                    				raise error "NIY" ;
                    			endif ;
                    			spIterFull := spIterate + " | " + spIterCond ;
                    			spBodyLineForwardCopyProcedure := formatString( "         %e%s := sum( %s, ::%e%s );\n", 
                    				epShadowsDataIdentifiers(iDataIdentifier), spIndexDomainStr1, spIterFull,			
                    				iDataIdentifier, spIndexDomainStr0);
                    			spBodyForwardCopyProcedure += spBodyLineForwardCopyProcedure ;
                    		endif ;
                    	endfor ;
                    	me::SetAttribute( epProcForwardCopyProcedure, 'body', spBodyForwardCopyProcedure );
                    	!display "------------DEBUG---------", sDataIdentifiersRequiringShadow ;
                    endblock ;
                    
                    me::Compile( epCompoundSetMappingRuntimeLibrary );
                }
                StringParameter spIndexDomainStr0;
                StringParameter spIndexDomainStr1;
                StringParameter spIndexDomainMap0;
                Parameter pNoCompoundIndices;
                StringParameter spIterate;
                StringParameter spIterCond;
                StringParameter spIterFull;
                ElementParameter epCompoundIndex {
                    Range: AllIdentifiers;
                }
                ElementParameter epCompoundSet {
                    Range: AllIdentifiers;
                }
                StringParameter spCompoundSetName;
            }
            Procedure prWorkCreateMappingSet {
                Arguments: (eCompoundSet);
                Body: {
                    block ! Check for erreneous input
                    	if not eCompoundSet then
                    		! Probably the button is pressed before selecting a specific compound root set.
                    		dialogMessage("No compound root set selected");
                    		return ;
                    	endif ;
                    	if not ( eCompoundSet in sCompoundSets ) then
                    		! Shouldn't be possible, but alas, no harm in checking.
                    		dialogMessage("The " + eCompoundSet + " is not a compound set");
                    		return ;
                    	endif ;
                    endblock ;
                    
                    block ! Parse structure of Compound Set
                    
                    	block  ! Get domain string with kommas
                    		spSubsetOfString := AttributeToString( eCompoundSet, 'subset of' );
                     		pNoKommas := StringOccurrences( spSubsetOfString, "," );
                    		while not pNoKommas do
                    			! Go find the root set.
                    			if SubString( spSubsetOfString, 1, 1 ) = "("  then
                    				spSubsetOfString := SubString( spSubsetOfString, 2, StringLength( spSubsetOfString ) -1 );
                    			endif ;
                    			epDomainSet := StringToElement( AllSets, spSubsetOfString, create:0);
                    			if not epDomainSet then
                    				raise error "bug" ;
                    			endif ;
                    			spSubsetOfString := AttributeToString( epDomainSet, 'subset of' );
                    			pNoKommas := StringOccurrences( spSubsetOfString, "," );
                    		endwhile ;
                    	endblock ;
                    
                    	block ! Parse the subset of string into atomic domain sets.
                    		prRemoveSpaces( spSubsetOfString );
                    		pCompoundDimension := pNoKommas + 1 ;
                    		sIndexDomainPositions := ElementRange(1,pCompoundDimension);
                    		for iIDP do
                    			if iIDP = first( sIndexDomainPositions ) then
                    				pBegPos := 2 ;
                    				pEndPos := FindNthString( spSubsetOfString, ",", 1 ) - 1 ;
                    			elseif iIDP = last( sIndexDomainPositions ) then
                    				pBegPos := FindNthString( spSubsetOfString, ",", pNoKommas ) + 1 ;
                    				pEndPos := StringLength( spSubsetOfString  ) - 1 ;
                    			else
                    				pIndexNo := iIDP ;
                    				pBegPos := FindNthString( spSubsetOfString, ",", pIndexNo - 1 ) + 1 ;
                    				pEndPos := FindNthString( spSubsetOfString, ",", pIndexNo     ) - 1 ;
                    			endif ;
                    			spAtomicDomainSetName := SubString( spSubsetOfString, pBegPos, pEndPos );
                    			epIndexDomainSets( iIDP ) := StringToElement( AllSets, spAtomicDomainSetName, create:0);
                    			if not epIndexDomainSets( iIDP ) then raise error "bug" ; endif ;
                    		endfor ;
                    	endblock ;
                    
                    	block ! Parse the tags string into atomic tag strings
                    		spTagsString := AttributeToString( eCompoundSet, 'tags' );
                    		if spTagsString then
                    			prRemoveSpaces( spTagsString );
                    			for iIDP do
                    				if iIDP = first( sIndexDomainPositions ) then
                    					pBegPos := 2 ;
                    					pEndPos := FindNthString( spTagsString, ",", 1 ) - 1 ;
                    				elseif iIDP = last( sIndexDomainPositions ) then
                    					pBegPos := FindNthString( spTagsString, ",", pNoKommas ) + 1 ;
                    					pEndPos := StringLength( spTagsString  ) - 1 ;
                    				else
                    					pIndexNo := iIDP ;
                    					pBegPos := FindNthString( spTagsString, ",", pIndexNo - 1 ) + 1 ;
                    					pEndPos := FindNthString( spTagsString, ",", pIndexNo     ) - 1 ;
                    				endif ;
                    				spTag(iIDP) := SubString( spTagsString, pBegPos, pEndPos );
                    			endfor ;
                    		else
                    			raise error "Please specify tags for " + spCompoundSetName + ".  We'll need them for the data conversion.";
                    		endif ;
                    	endblock ;
                    
                    endblock ;
                    
                    ! display "--------DEBUG---------------", eCompoundSet, epIndexDomainSets, spTag ;
                    
                    block ! Create and fill runtime declaration section Declarations_Mapping_Set_<Cname>
                    
                    	block ! comment
                    	! <CName> below is the name of the compound set.
                    	!
                    	! Per compound set, we create a declaration section Declarations_Mapping_Set_<Cname> with the following declarations:
                    	! 
                    	! Actual Mapping Set:
                    	! CM --> sMappingSet_<CName>_Set with index iMS_<CName>
                    	! RM --> sMappingSet_<CName>_Relation
                    	!
                    	! Element parameters for tags (only if tags string)
                    	! EPTS(i_cm) --> epTag_<CName>_<Tag>(iMS_<CName>)
                    	! ...
                    	!
                    	! Element parameters for caching
                    	! EPHS --> epHelper_<CName>_pos
                    	! ...
                    	endblock ;
                    
                    	block ! Determine name of compound set and compound index.
                    		spCompoundSetName := FormatString("%e", eCompoundSet );
                    		spCompoundIndexName := AttributeToString( eCompoundSet, 'index' );
                    		if spCompoundIndexName then ! if there are multiple indices take the first one.
                    			pBegPos := FindString( spCompoundIndexName, "," );
                    			if pBegPos then
                    				spCompoundIndexName := SubString( spCompoundIndexName, 1, pBegPos -1 );
                    			endif ;
                    		else ! Require an index, it is needed later on.
                    			raise error "Compound set " + spCompoundSetName + " does not have an index.  " +
                    			            "Perhaps the set can be deleted anyway, or perhaps you can give this se an index." ;
                    		endif ;
                    	endblock ;
                    
                    	epDeclarationSectionMappingSet :=  me::Create( "Mapping_Set_Declarations_" + spCompoundSetName, 
                    		'declaration', epSectionCompoundSetMappingDeclarations );
                    
                    	block ! Declare Set Mapping Set.
                    		epMappingSetSet := me::Create( "sMappingSet_"+ spCompoundSetName+"_Set" , 'set', epDeclarationSectionMappingSet );
                    		spMappingSetIndex := "iMS_"+ spCompoundSetName ;
                    		me::SetAttribute( epMappingSetSet, 'index', spMappingSetIndex);
                    		spMappingSetParameter := "epMS_"+ spCompoundSetName ;
                    		me::SetAttribute( epMappingSetSet, 'parameter', spMappingSetParameter);
                    		spCompoundSetMappedIndex( eCompoundSet ) := spMappingSetIndex ;
                    	endblock ;
                    
                    	block ! Declare set mapping relation.
                    		epMappingSetRelation := me::Create( "sMappingSet_"+ spCompoundSetName+"_Relation" , 'set', epDeclarationSectionMappingSet );
                    		spMappingSetRelationSubsetOf := "(";
                    		for iIDP do
                    			spMappingSetRelationSubsetOf += formatString("%e,", epIndexDomainSets(iIDP) );
                    		endfor ;
                    		spMappingSetRelationSubsetOf += formatString("%e)", epMappingSetSet );
                    		me::SetAttribute( epMappingSetRelation, 'subset of', spMappingSetRelationSubsetOf);
                    	endblock ;
                    
                    	block ! Declare element parameters that are to be used as a substitution for tags.
                    		if spTagsString then
                    			for iIDP do
                    				epElementParameterForTag(iIDP) := 
                    					me::Create( "epTag_"+ spCompoundSetName+"_"+spTag(iIDP), 
                    						'element parameter', epDeclarationSectionMappingSet );
                    				me::SetAttribute( epElementParameterForTag(iIDP), 'index domain', spMappingSetIndex );
                    				me::SetAttribute( epElementParameterForTag(iIDP), 'range',
                    					formatString("%e",epIndexDomainSets(iIDP)) );
                    			endfor ;
                    		endif ;
                    	endblock ;
                    
                    	block ! Declare the helper element parameters.
                    		for iIDP do
                    			epElementParameterHelp(iIDP) := 
                    				me::Create( formatString("epTag_%s_%e",spCompoundSetName, iIDP),
                    					'element parameter', epDeclarationSectionMappingSet );
                    			me::SetAttribute( epElementParameterHelp(iIDP), 'range',
                    				formatString("%e",epIndexDomainSets(iIDP)) );
                    		endfor ;
                    	endblock ;
                    
                    	block ! Relate the compound set index and the set mapping set index
                    		epElementParameterRelateCompoundSetMappingSetSet := me::Create(
                    			formatString( "p01CompoundSetMappingSet_%s", spCompoundSetName), 'parameter',
                    				epSectionRelationCompoundSetSetMappingSetDeclarationsDeclarations );
                    		me::SetAttribute( epElementParameterRelateCompoundSetMappingSetSet, 'index domain', 
                    			formatString( "(%s,%s)",spCompoundIndexName, spMappingSetIndex));
                    		me::SetAttribute( epElementParameterRelateCompoundSetMappingSetSet, 'range', "binary" );
                    		epElementParameterRelationCompoundSet(eCompoundSet) := epElementParameterRelateCompoundSetMappingSetSet;
                    	endblock ;
                    
                    endblock ;
                    
                    block ! Create procedure to fill the data of all the set mapping identifiers 
                    	epProcFillSetMapping := me::Create( "prProcFillSetMapping" + spCompoundSetName,
                    		'procedure', epSectionDataShadowDeclarations );
                    	spBody := "" ;
                    
                    	spBodyLine := FormatString( "for %s do \n\n", spCompoundIndexName ); 
                    	spBody += spBodyLine ;
                    
                    	block ! Assign values to the cache element parameters.
                    		spBodyLine := "        ! Cache the components of tuple h in element parameters.\n" ; 
                    		spBody += spBodyLine ;
                    		for iIDP do
                    			spBodyLine := FormatString( "       %e := %s.%s ;\n", 
                    				epElementParameterHelp(iIDP), spCompoundIndexName, spTag(iIDP) );			
                    			spBody += spBodyLine ;
                    		endfor ;
                    	endblock ;
                    
                    	block ! Create the look alike element.
                    		spBodyLine := "\n        ! Create an element that looks like a tuple, but is just a string and\n" ; 
                    		spBody += spBodyLine ;
                    		spBodyLine := "        ! add this element to the set mapping set " + spCompoundSetName + "\n"; 
                    		spBody += spBodyLine ;
                    		spBodyLine := formatString("        SetElementAdd(%e,%s,\n                formatString(\"(", 
                    			epMappingSetSet,spMappingSetParameter);
                    		for iIDP do
                    			spBodyLine += "%e" ;
                    			if iIDP = last(sIndexDomainPositions) then
                    				spBodyLine += ")\"\n                        " ;
                    			else
                    				spBodyLine += "," ;
                    			endif ;
                    		endfor ;
                    		for iIDP do
                    			spBodyLine += formatString(",%e", epElementParameterHelp(iIDP));
                    		endfor ;
                    		spBodyLine += "));\n\n" ;
                    		spBody += spBodyLine ;
                    	endblock ;
                    
                    	block ! Add N+1 dim tuple to the relation.
                    		spBodyLine := "        ! Create a N+1 dim tuple and add this to the set mapping relation\n" ;
                    		spBody += spBodyLine ;
                    		spBodyLine := formatString("        %e += {(", epMappingSetRelation );
                    		for iIDP do
                    			spBodyLine += formatString("%e,",epElementParameterHelp(iIDP));
                    		endfor ;
                    		spBodyLine += spMappingSetParameter + ")};\n\n";
                    		spBody += spBodyLine ;
                    	endblock ;
                    
                    	block ! Fill in the element parameters that map the tags.
                    		spBodyLine := "        ! Fill in the element parameters that map the tags.\n" ;
                    		spBody += spBodyLine ;
                    		for iIDP do
                    			spBodyLine := formatString("        %e(%s) := %s ;\n",
                    				epElementParameterForTag(iIDP), spMappingSetParameter, epElementParameterHelp(iIDP) );
                    			spBody += spBodyLine ;
                    		endfor ;
                    	endblock ;
                    
                    	block ! fill the relation between compound element and look alike element.
                    		spBodyLine := "\n        !  fill the relation between compound element and look alike element.\n" ;
                    		spBody += spBodyLine ;
                    		spBodyLine := formatString("        %e(%s,%s) := 1 ;\n",
                    			epElementParameterRelateCompoundSetMappingSetSet, 
                    			spCompoundIndexName, spMappingSetParameter );
                    		spBody += spBodyLine ;
                    	endblock ;
                    
                    	spBodyLine := "\n" ; spBody += spBodyLine ;
                    	spBodyLine := "endfor ;\n" ; spBody += spBodyLine ;
                    	me::SetAttribute( epProcFillSetMapping, 'body', spBody );
                    
                    endblock ;
                }
                DeclarationSection Argument_Declaration {
                    ElementParameter eCompoundSet {
                        Range: sCompoundSets;
                        Property: Input;
                    }
                }
                DeclarationSection Local_Declarations {
                    StringParameter spCompoundSetName;
                    StringParameter spCompoundIndexName;
                    StringParameter spSubsetOfString;
                    Set sIndexDomainPositions {
                        SubsetOf: Integers;
                        Index: iIDP;
                    }
                    ElementParameter epIndexDomainSets {
                        IndexDomain: iIDP;
                        Range: AllSets;
                    }
                    StringParameter spIndexDomainTags {
                        IndexDomain: iIDP;
                    }
                    ElementParameter epDomainSet {
                        Range: AllIdentifiers;
                    }
                    Parameter pNoKommas;
                    Parameter pCompoundDimension {
                        InitialData: 2;
                    }
                    StringParameter spAtomicDomainSetName;
                    Parameter pSpacePos;
                    Parameter pBegPos;
                    Parameter pEndPos;
                    Parameter pIndexNo;
                    StringParameter spTagsString;
                    StringParameter spTag {
                        IndexDomain: iIDP;
                    }
                    ElementParameter epElementParameterForTag {
                        IndexDomain: iIDP;
                        Range: AllIdentifiers;
                    }
                    ElementParameter epElementParameterHelp {
                        IndexDomain: iIDP;
                        Range: AllIdentifiers;
                    }
                    ElementParameter epElementParameterRelateCompoundSetMappingSetSet {
                        Range: AllIdentifiers;
                    }
                    ElementParameter epDeclarationSectionMappingSet {
                        Range: AllIdentifiers;
                    }
                    ElementParameter epMappingSetSet {
                        Range: AllIdentifiers;
                    }
                    StringParameter spMappingSetIndex;
                    StringParameter spMappingSetParameter;
                    ElementParameter epMappingSetRelation {
                        Range: AllIdentifiers;
                    }
                    StringParameter spMappingSetRelationSubsetOf;
                    ElementParameter epProcFillSetMapping {
                        Range: AllIdentifiers;
                    }
                    StringParameter spBody;
                    StringParameter spBodyLine;
                }
            }
            Function fncRequiresDataShadow {
                Arguments: (epId);
                Range: binary;
                Body: {
                    fncRequiresDataShadow := 0 ;
                    pDim := IdentifierDimension( epId );
                    while loopCount <= pDim do
                    	epIndex := DomainIndex( epId, loopCount );
                    	epSet := IndexRange( epIndex );
                    	if epSet in sCompoundSets then
                    		fncRequiresDataShadow := 1 ;
                    		break ;
                    	endif ;
                    endwhile ;
                }
                ElementParameter epId {
                    Range: AllIdentifiers;
                    Property: Input;
                }
                ElementParameter epIndex {
                    Range: AllSymbols;
                }
                ElementParameter epSet {
                    Range: AllSymbols;
                }
                Parameter pDim;
            }
            Function fncIndexDomainString {
                Arguments: (epId,p01MappedIndex);
                Range: string;
                Body: {
                    fncIndexDomainString := "(" ;
                    pDim := IdentifierDimension( epId );
                    while loopCount <= pDim do
                    	epIndex := DomainIndex( epId, loopCount );
                    	epSet := IndexRange( epIndex );
                    	if p01MappedIndex and ( epSet in sCompoundSets ) then
                    		spMappedIndex := spCompoundSetMappedIndex( epSet );
                    		fncIndexDomainString += spMappedIndex ;
                    	else
                    		fncIndexDomainString += formatString("%e", epIndex); ;
                    	endif ;
                    	if loopCount < pDim then
                    		fncIndexDomainString += ", " ;
                    	endif ;
                    endwhile ;
                    fncIndexDomainString += ")" ;
                }
                ElementParameter epId {
                    Range: AllIdentifiers;
                    Property: Input;
                }
                ElementParameter epIndex {
                    Range: AllSymbols;
                }
                StringParameter spMappedIndex;
                Parameter p01MappedIndex {
                    Range: binary;
                    Property: Input;
                    Comment: {
                        "When this argument is
                        0, then use original compound index
                        1, then for each compound index, find its set mapped set index and use that."
                    }
                }
                ElementParameter epSet {
                    Range: AllSymbols;
                }
                Parameter pDim;
            }
            Function fncNoCompoundIndices {
                Arguments: (epId);
                Body: {
                    fncNoCompoundIndices := 0 ;
                    pDim := IdentifierDimension( epId );
                    while loopCount <= pDim do
                    	epIndex := DomainIndex( epId, loopCount );
                    	epSet := IndexRange( epIndex );
                    	if epSet in sCompoundSets then
                    		fncNoCompoundIndices += 1 ;
                    	endif ;
                    endwhile ;
                }
                ElementParameter epId {
                    Range: AllIdentifiers;
                    Property: Input;
                }
                ElementParameter epIndex {
                    Range: AllSymbols;
                }
                ElementParameter epSet {
                    Range: AllSymbols;
                }
                Parameter pDim;
            }
            Function fncCompoundIndex {
                Arguments: (epId,pCompoundIndexNo);
                Range: AllIdentifiers;
                Body: {
                    fncCompoundIndex := '' ;
                    pPos := 0 ;
                    pDim := IdentifierDimension( epId );
                    while loopCount <= pDim do
                    	epIndex := DomainIndex( epId, loopCount );
                    	epSet := IndexRange( epIndex );
                    	if epSet in sCompoundSets then
                    		pPos += 1 ;
                    		if pPos = pCompoundIndexNo then
                    			fncCompoundIndex := epIndex ;
                    		endif ;
                    	endif ;
                    endwhile ;
                }
                ElementParameter epId {
                    Range: AllIdentifiers;
                    Property: Input;
                }
                ElementParameter epIndex {
                    Range: AllSymbols;
                }
                ElementParameter epSet {
                    Range: AllSymbols;
                }
                Parameter pDim;
                Parameter pCompoundIndexNo {
                    Property: Input;
                }
                Parameter pPos;
            }
            Function fncCompoundIterateCondition {
                Arguments: (epCompoundIndex);
                Range: string;
                Body: {
                    ! epElementParameterRelationCompoundSet
                    epSet := IndexRange( epCompoundIndex );
                    epP01 := epElementParameterRelationCompoundSet( epSet );
                    fncCompoundIterateCondition := formatString( "%e(%e,%s)", 
                    	epP01, epCompoundIndex,  spCompoundSetMappedIndex(epSet) );
                }
                ElementParameter epCompoundIndex {
                    Range: AllIdentifiers;
                    Property: Input;
                }
                ElementParameter epSet {
                    Range: AllIdentifiers;
                }
                ElementParameter epP01 {
                    Range: AllIdentifiers;
                }
            }
        }
        Section Attic {
            Procedure LibraryInitialization {
                Comment: "Add initialization statements here that do not require any other library being initialized already.";
            }
            Procedure PostLibraryInitialization {
                Comment: {
                    "Add initialization statements here that require another library to be initialized already,
                    or add statements that require the Data Management module to be initialized."
                }
            }
            Procedure PreLibraryTermination {
                Body: {
                    return 1;
                }
                Comment: {
                    "Add termination statements here that require all other libraries to be still alive.
                    Return 1 if you allow the termination sequence to continue.
                    Return 0 if you want to cancel the termination sequence."
                }
            }
            Procedure LibraryTermination {
                Body: {
                    return 1;
                }
                Comment: {
                    "Add termination statements here that do not require other libraries to be still alive.
                    Return 1 to allow the termination sequence to continue.
                    Return 0 if you want to cancel the termination sequence.
                    It is recommended to only use the procedure PreLibraryTermination to cancel the termination sequence and let this procedure always return 1."
                }
            }
        }
    }
}
